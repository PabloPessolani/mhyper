ATENCION:	Cuando se modifica el IS (Information Server) hay que hacer
		cd /usr/src/servers/is
		make clean
		make install
		cd /usr/src/tools
		make clean
		make hdboot

20131023: 	Se unio MHYPER (VMM, VMMCMD,etc) con KHYPER.
		Todo quedo en MHYPER
		Se modificaron login, getty y uname para que presenten el VMID
		Se modifico la tecla F10 para que entre los parametros del kernel presente nr_vms y running_vm

20131024:	Se incorporo el puntero global systask_ptr para tenerlo permanentemente referenciando a SYSTASK
		se modifico proc.c
			- PLANIFICACION: Cuando se planifica un proceso, se setea
				- running_vm=proc_ptr->p_vmid 
				- systask->p_vmid = running_vm;
				De esa forma la SYSTASK ya tiene la personalidad del proceso ejecutante.
			- IPC: Cuando el proceso hace un IPC, el caller_ptr es el es quien está ejecutando 
				por lo que el running_vm y systask_ptr->p_vmid ya se encuentran seteados.
			- send/notify: si el caller es distinto de SYSTASK pero dst = SYSTASK, dst_ptr = systask_ptr

			- receive: 	si el caller es SYSTASK y src=ANY, 
						entonces running_vm = systask_ptr->p_vmid = VM0;
					si hay procesos encolados, y caller es SYSTASK 			
						running_vm = systask_ptr->p_vmid = (*xpp)->p_vmid; <<< sender

		Se modifico exception.c para que running_vm = systask_ptr->p_vmid = VM proceso fallido.

		La SYSTASK recibe pedidos SYS_SETALARM que ejecuta do_setalarm(m_ptr)
		  /* Get the timer structure and set the parameters for this alarm. */
			 tp = &(priv(rp)->s_alarm_timer);	
  			 tp->tmr_func = cause_alarm; 
 			 tmr_arg(tp)->ta_int = m_ptr->m_source; <<<<< setea solo el ENDPOINT a quien enviar alarm

			Solo se puede pasar un argumento al timer, y en este caso pasa un ENDPOINT.
			Sería mejor pasar el puntero al proceso. POR SUERTE la estructura de argumentos lo soporta.
				typedef union { int ta_int; long ta_long; void *ta_ptr; } tmr_arg_t;

			tmr_arg(tp)->ta_ptr = (void *) proc_addr(rp); 

			cause_alarm usa el int, pero puede usar el puntero.

			int proc_nr_e = tmr_arg(tp)->ta_int;		/* get process number */

			saved_vm = running_vm;
			proc_ptr = (proc * ) tmr_arg(tp)->ta_ptr;
			systask_ptr->p_vmid = running_vm = proc_ptr->p_vmid;
			proc_nr_e = proc_ptr->p_endpoint;
			lock_notify(CLOCK, proc_nr_e);		/* notify process */
			systask_ptr->p_vmid = running_vm = saved_vm;


20131025:	Se creo la variable global clock_ptr que apunta al descriptor de proceso de CLOCK
		de tal modo que las IPCs hacia CLOCK tengan en consideración su direccion.
		Se modificaron las IPCs para ello.
		Se incorporaron los privilegios a la VM (Vectorizados)
		Se inicializan en main.c
		Se cambiaron las macros para localizar los privilegios en funcion de running_vm

20131026:  Se crear chvmid() como mecanismo para cambia el vmid de un proceso.
			Para ello el kernel copiar todo el descriptor desde una VM a otra.
			Ademas el nuevo descriptor se inserta en la cola de listo a continuacion del descriptor
			original. El proceso original invoca da dequeue() y de esa forma se llama 
			automaticamente a pick_proc() para que selecione al nuevo proceso que es el mismo
			solo que en otra VM
			Para probar se creo un programa test_chvmid 	
				ret = mh_chvmid(vmid)
				if( ret < 0) printf(ERROR)
				while(TRUE){
					mh_debug("ESTOY VIVO", ret);
					for(i=0; i< 1000000; i++);
				} 
LO BUENO:	Se ejecuta el programa en otra VM!!		
ERROR:		Seguramente algun NOTIFY o algo por el estilo y eso termina colgandolo
	

20131027:	Se modifico protect.c porque inicializa tantas LDT como procesos haya.
			Se modifico el irq_hook_t para que contenga la vmid del proceso solicitante.
			De esa forma cuando se produce una INT, el handler generico setea running_vm = hoot->vmid 
			Generalmente es un notify, y una vez finalizado retorna el running_vm al valor anterior a 
			producirse la INT.		


20131029:	FUNKA!!! 
		Se hizo la macro SET_RUNNING_VM(vm)	

20131029:	se hicieron test_server y test_client, ambos en la VM1
		Se levanta el server
			service up /usr/src/test/test_server
		se debe ver con ps o F1 que endpoint tiene el server
		Luego se arranca el client.
			service up /usr/src/test/test_client -args <server_ep>
		NOTA1: Para que el server pueda hacer el receive() y luego el send() hay que configurar
			/etc/system.conf  (VER GOOGLE: minix /etc/system.conf
			de lo contrario da error por falta de permisos para el IPC CALL.
		NOTA2: De igual forma hay que arrancar con service el client para poder asignarle permiso
			para enviar mensajes a cualquier server.

 hdebug: name=test_cl vmid=1 nr=35 ep=106652 CLIENT: vmid=:0
 sys_call next(test_cl,1) old(random,0)
 hdebug: name=test_cl vmid=1 nr=35 ep=106652 CLIENT: Before sendrec:0
 sys_call next(test_cl,1) old(random,0)
 hdebug: name=test_se vmid=1 nr=9 ep=71087 SERVER: Receive from::106652
 hdebug: name=test_cl vmid=1 nr=35 ep=106652 CLIENT: Receive from::71087
 do_clocktick test_cl vmid=1
 sys_call next(test_cl,1) old(random,0)
 mini_chvmid: vmid=0 proc_ptr->p_vmid=1
 mini_chvmid: rp->p_vmid=0
 dequeue new(test_cl,35,0) old(test_cl,35,1)
 mini_chvmid: proc_ptr->p_vmid=1
 hdebug: name=test_cl vmid=0 nr=35 ep=106652 CLIENT: EXIT OK!! :0
 sys_call next(test_se,1) old(fs,0)
 hdebug: name=test_se vmid=1 nr=9 ep=71087 SERVER: Before receive:0
 
 sys_call function=2 src_dst=31438 caller(fs,1,0) next(ds,6,1)
 hdebug: name=ds vmid=1 nr=6 ep=6 DS SERVER RUNNING !!!:0
 hdebug: name=ds vmid=1 nr=6 ep=6 DS VMID=:0
 dequeue new(tty,5,0) old(ds,6,1)
 
 source=119 type=0 m1i1=23228 m1i2=0 m1i3=0 m1p1=DF64 m1p2=FFFF <<<<<<<<<<<<<<<< source 119
 vmid=1684370531 nr=112 endp=1702129522 name=32-bit protected   <<<<<<<<<<<<<<<< ????????????????? Calculará mal get_proaddr()
 
 sys_call function=3 src_dst=-2 caller(ds,6,1) next(system,-2,1
 SYSTEM: do_getvmid: proc_nr=6, p_vmid=1
 sys_call function=2 src_dst=31438 caller(random,39,0) next(ds,
 hdebug: name=ds vmid=1 nr=6 ep=6 DS VMID=:1
 dequeue new(tty,5,0) old(ds,6,1)
 source=119 type=0 m1i1=23228 m1i2=0 m1i3=0 m1p1=DF64 m1p2=FFFF
 vmid=1684370531 nr=112 endp=1702129522 name=32-bit protected
 sys_call function=2 src_dst=31438 caller(ds,6,1) next(tty,5,0)
 
 20131101:
 20131102: 	Se modifico DS para que no haga sys_getvmid, sino que _mhdebug() retorna el vmid
			Evidentemente hay un problema cuando el DS1 hace un sendrec a SYSTASK.
			Por lo lo demas, funciona DS en VM1 OK

			sys_call function=2 src_dst=31438 caller(random,39,0) next(ds,6,1) 
			hdebug: name=ds vmid=1 nr=6 ep=6 DS SERVER RUNNING !!!:0  
			hdebug: name=ds vmid=1 nr=6 ep=6 DS VMID=:0
			hdebug: name=ds vmid=1 nr=6 ep=6 DS VMID=:1		
			dequeue new(tty,5,0) old(ds,6,1)
			sys_call function=2 src_dst=31438 caller(ds,6,1) next(tty,5,0)  ===>>> DS hace sendrec(ANY) para bloquearse.

20131102:	Se probó el funcionamiento de cliente y servidor en VM1 usando service up <archivo> -args <args>
			Debe configurarse el system.config
			Se incluyeron las estructuras KINFO, MACHINE dentro de la VM.
			Se modificaron funciones que usan KINFO, etc.
			ATENCION: Solo el kernel ve estas estructuras vectorizadas en funcion de la constate INSIDE_KERNEL
			
20131104:	Modificar el START de SYSTASK para que complete las estructuras KINFO de la VM correspondiente.
			Cada VM dispone de sus propios hooks. 
			Pero el Hypervisor solo hay una lista de irq_handlers, irq_actids, irq_use.
				EXTERN irq_hook_t *irq_handlers[NR_IRQ_VECTORS];/* list of IRQ handlers */
				EXTERN int irq_actids[NR_IRQ_VECTORS];		/* IRQ ID bits active */
				EXTERN int irq_use;				/* map of all in-use irq's */
			
20131105:	Se desarrollo MHDEBUG para debbuging en el kernel. Se incorporo la variable global debug_switch que permite
			habilitar/deshabilitar el debugging.
			El VMM informa al IS para imprimir informacion sobre VMs - Esto se hace con F8
			Se reemplazo la macro SET_RUNNING_VM por la funcion set_running_vm
			Se reviso el esquema de locking para que set_running_vm() sea atómica.
			Se modifico do_setalarm.c funcion cause_alarm porque la misma es ejecutada por CLOCK sin haber entrado al kernel (k_reenter <0)
			Por lo tanto las interrupciones estan habilitadas. Se controla el valor de k_reenter para ver si hay que hacer locking.
			
		
20131106:	Se incorporo vmm_desc_t del VMMM como componente de descriptor general de VM del kernel (vm_VMM).
			Se cambiaron las rutinas del kernel para que use vm_VMM. 
			Se modifico chvmid y da error de parametros

20131107:	Se modificaron muchos comandos afectados por el cambio de #include <vmachine.h> 
			Se hizo make world y se soluciono el problema del chvmid(vmid, endpoint)
			Se obtiene los datos de memoria de la VM system/do_vmmreq.c  fill_vmmap
 *    ------------------											*
 *     | loader STACK|											*
 *    ------------------	<<<  vmmap_top								*
 *     |                      |  											*
 *     |  VM free size |											*
 *     |                      |											*
 *    ------------------	<<< vmmap_bottom							*
 *     |  boot image     |											*
 *    ------------------	<<< vmmap_image								*
 *     |  loader DATA |											*
 *    ------------------	<<< vmmap_start								*	
 
			SYSTEM: fill_vmmap vmid=1
            addr=4000 stk_addr=3FFEF20 loadep=0 loadPID=105 vmsize=0 nr_bprocs=10 bytes=489472 name=/boot/image/3.1.2a-MHYPERr520
			mem_vir=0 mem_phys=961 mem_len=8194
			mem_vir=5 mem_phys=966 mem_len=0			
			mem_vir=7E mem_phys=9DF mem_len=0			
			mem_vir=3FFD mem_phys=495E mem_len=16255			
			
			FINALMENTE el tamaño de memoria libre a usar por la VM (despues de cargada la imagen es 
				vmm_ptr =&vmm_desc(vmid);
				img_ptr =&vmm_ptr->vmm_img;
				img_ptr->vmsize)

20131107:	Se setea correctamente en mh_start() de do_vmmreq() la estructura kinfo de la VM correspondiente.
			Tambien se copian todos los parametros de booteo de la VM0 sobre la VM que está arrancando, excepto 
			el parámetro memory=XXXX:XXXX que es el CHUNK de memoria libre a utilizar por el PM.
			En loadvmimg.c se crea una variable global boot_params donde la SYSTASK le copiara los parametros 
			de booteo de la VM. Para ello, en la estructura image_info que loadvmimg le pasa al VMM se encuentra
			la direccion de esa variable. Luego VMM le copia a la SYSTASK toda la estructura completa.


20131108:
20131109:
20131110:	Se corrigieron errores de running_vm y asignacion de vmid a SYSTASK,CLOCK, etc.
			Al ejecutar MEMORY1 parace funcionar todo OK.
						
			

20131111:	Se modifico MEMORY1  y se ejecuto despues de LOAD/START VM1. 
			Funciona OK sobre IMGRD_DEV (disco virtual en RAM)
			Quedan pendientes algunas colgada!! SIN INFO en salidad de DEBUG

20131112:	Se modifico MPX386.S las rutinas save, restore, exception y HWINTxx
			En las entradas se hace:
				proc_rvm que es una rutina en C 
			En las salidas se hace
				next_rvm que tambien es en C
			NOTA!!: Verificar dentro de estas rutinas si las INTs estan deshabilitadas!
			
20131113:	Se creo otra VM VMware con MHYPER2. El entorno de desarrollo sera:
				MHYPER: Hypervisor y VM0
				MHYPER2: Minix para la VM1
			
20131114:   Hay algun error en proc.c cuando se usa MHDEBUG. Antes no existia. Por ahora esta emparchado!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


20131115:	Se hicieron funcionar los esqueletos de msendas() y mrecvas() para ser usados por el PROXY SERVER
			Se incorporo vm_flags para disponer del estado de la VM en la estructura del kernel.
			Se modifico LOAD y START de do_vmmreq para que consideren estos estados.
			Al proceso loader que es el PROXY_SERVER se le otorgaron privilegios de servidor, de tal modo
			que pueda hacer msendas() y mrecvas() sin problemas.
			Para que loadvmimg.c pueda continuar, hay que crear un nuevo comando VMM_WAITVM
			por el cual el PROXY_SERVER(loader) espera el START de la VM.
			vmid = vmmcmd(VMM_WAITVM, vm_pid , 0, 0, 0,0);
			El VMM al recibir este comando cambia el estado de la VM a (VM_LOADED | VM_WAITING) para esperar el
			VMM_START. Si hay error al START retorna error sino retorna el VMID.
			Cuando se arranco correctamente la VM, se remueve el estado VM_WAITING, se agrega el estado
			VM_RUNNING, y se le responde al PROXY_SERVER porque ahora ya esta listo para ser reconocido como tal.
			Loadimg.c uso correctamente los esqueletos de msendas() y mrecvas()

20131123:	Se intento solucionar el problema de colgadas y TRAP del kernel. SIN RESULTADOS POSITIVOS!
			Se cambio en casi todas las funciones de system (do_xxxxxx.c) el uso de vir2phys por VIR2PHYS 
			A primera vista esta mas inestable. En realidad vir2phys deberia funcionar mal cuando se usa en otra VM != VM0

PRINCIPIOS DE FUNCIONAMIENTO:
=============================
		- Si no hay interrupciones/excepciones:
			- running_vm = systask_ptr->p_vmid = VM0 si SYSTEM hizo receive(ANY,&m)
			- running_vm = clock_ptr->p_vmid   = VM0 si CLOCK hizo receive(ANY,&m)
			- running_vm = next_ptr->p_vmid al volver a modo usuario
			- running_vm = proc_ptr->p_vmid al ingresar a modo kernel
			- systask_ptr->p_vmid= proc_ptr->p_vmid si el proceso hizo send(SYSTEM,&m) o notify(SYSTEM)
			- SYSTASK mantiene su p_vmid durante todo el ciclo de atención de una petición.
		- Si hay una interrucion de reloj
			- temporariamente durante el notify(HARDWARE, CLOCK) running_vm = clock_ptr->p_vmid = VM0
		- Si se vencio una alarma de tiempo
			- temporariamente durante el notify(CLOCK, proc) running_vm = clock_ptr->p_vmid =  proc->p_vmid
		- Si se envia una señal
			- temporariamente durante el notify(SYSTEM, proc) running_vm = clock_ptr->p_vmid =  proc->p_vmid


20131126:		POR FIN FUNCIONO EN VM0!!!  TOMAR COMO BASE ESTA VERSION
			El problema estaba en la implementacion de LOCK y UNLOCK.


20131127:		Se va a utilizar como servidor de pruebas al DS. Para ello cuando la VM!=VM0 entonces se ejecuta 
			ds_test() y alli podemos probar todo lo que querramos.
			RECORDAR: usar _mhdebug en lugar de printf
			Se probó con exito
				- getkinfo
				- getmachine
				- getmonparams
			Incluso se probaron recibir los memory chunks que usará el PM como memoria para gestionar.


PROBLEMA:	Siendo muy complicados los DRIVERs REALES, se me ocurre:
			1-PROXY SERVER: Hay un PROXY_SERVER en VM0 representando a todas las VIRTUAL_TASKS de una VMx
				En la VMx en lugar de existir las TASK reales hay VIRTUAL_TASK.
				Cada VMx tiene su propio PROXY_SERVER que es LOADER que la cargo y que pertenece a la VM0. 
				Este se comunicará basicamente con el FS de VM0 para realizar todas las operaciones de E/S. 
				Es decir, emulará a cada uno de los drivers que representa.

				Cuanda arranca la VMx detecta los drivers y crea los procesos con p_mis_flags |= MIS_VIRTUAL_TASK.

				Cuando el FS1 hace sendrec(VTASK1_VM1,&m), VTASK_VM1 esta NO ESTA en estado RECEIVING, por lo el descriptor de FS1
				se encola en el descriptor de VTASK_VM1.
				Cuando hace dequeue(FS1) realiza un NOTIFY(HARDWARE, PROXY_SERVER) para advertir al PROXY_SERVER que han llegado
				mensajes a los drivers que representa.
				
				Si el sender del notify() es HARDWARE se completa el campo NOTIFY_ARG con las IRQ  pendientes.
					priv(proxy_ptr)->s_int_pending |= (1 << driver_nr)
				En este caso, en lugar de ser las IRQ pendientes cada bit representará una VIRTUAL_TASK.
						(m_ptr)->NOTIFY_ARG = priv(dst_ptr)->s_int_pending
						#define NOTIFY_ARG		m2_l1
						irq_id_t s_int_pending;	/* pending hardware interrupts */
						typedef unsigned long irq_id_t;	
						
				PROXY_SERVER:
				    init_server(); /* inicializa el vector de emulaciones */
					while(1) {
						receive(ANY, &msg);
						if( msg.m_source == HARDWARE) {
							/* hay mensajes en algun driver de la VMx */ 
						    for(i=0; i < NR_DRIVERS; i++)
							    if(msg.NOTIFY_ARG & (1<<i)) {
									reply = call_emulator(i);
								}
							}
						} else {
							/* es algo que proviene de la VM0 */ 
						}
					}
					
				Cada driver tendra su propio emulador.
				wini_emulator(i)
				{
					ret = mini_recvas(driver[i], &m_in);	/* nueva primitiva que lee de la cola de un proceso de otra VM */
					rqtr = m_in.m_source;
					operacion(driver[i], &m_in);
					mini_sendas(driver[i], rqtr, m_out);	/* nueva primitiva que envia un mensaje a otra VM en nombre de otro emisor */
				}
					
				- mini_recvas(task_ep, &msg): se fija si hay mensajes en cola de task_ep. 
					Si esta vacia retorna EMPTY
					Si no, hace lo mismo que receive()
					
				- mini_sendas: Envia un mensaje en nombre TASK_VM1 por ejemplo a FS1 
									
				- En cuanto a la copia de datos, el hecho de que toda la VM1 se encuentre en el espacio de direcciones
					de PROXY_SERVER1, puede ser beneficioso porque le kernel de la VM0 puede copiar directamente 
					hacia el espacio de direcciones de PS1 a la posicion del buffer de FS1.
					La complejidad se podria presentar la conversion de direcciones.
	
			2- PROXY TASKS: Similar al PROXY SERVER solo que hay PROXY_TASK por cada VIRTUAL_TASK
				En cada VM hay VIRTUAL_TASKS (vmid, p_nr)
				En VM0 hay un PROXY_TASK (VM0, p_nr) por cada VIRTUAL_TASKS
 				Cuando un proceso de VMx envia un mensaje a VIRTUAL_TASKS, este lo preprocesa
				y el si tiene que hacer una solicitud a una TASK de la VM0, lo hace en nombre
				de PROXY_TASK.
				Hay 2 opciones: 
					- Poner la inteligencia en la VIRTUAL_TASK
					- Poner la inteligencia en la PROXY_TASK
				Creo q que en PROXY_TASK es mejor ya que simplifica el desarrollo porque se ejecuta en VM0.
							
				Problemas:
					- Quien crea las PROXY_TASKS?
						VMM 
					- En que momento?
						START
					- Que se necesita?
						Establecer la relacion PROXY_TASK <=> VIRTUAL_TASK

				Pseudocodigo PROXY_TASK:
					while(TRUE){
						receive(ANY, &msg);
						if( msg.m_source == HARDWARE) {
							ret = call_emulator(msg);
						} else {
							/* es algo que proviene de la VM0 */ 
						}						
					}
				
				VENTAJAS Y DESVENTAJAS:
					- PROXY SERVER: 
						- Ya es un proceso creado
						- Ya tiene relacion con la VMx
						- No usa ranuras adicionales en VM0
						- Tiene que multiplexar entradas y salidas.
						- Estan todos los "drivers" en un unico proceso
					- PROXY TASKS:
						- El VMM  tiene que crearlas
						- Hay que establecer la relacion con el VTASK de la VMx
						- Se usan ranuras adicionales en VM0
						- Hay una relacion biunívoca entre VTASK y PTASK.
						- Hay un driver por cada proceso				


20131127:		Se convertio a LOADER en un SERVICE en el momento de LOAD.
			Se habilito set_loader_priv en do_vmmreq.c

SYSTEM: fill_vmmap vmid=1
addr=4000 stk_addr=3FFEF1C loadep=0 loadPID=102 vmsize=0 nr_bprocs=10 bytes=496128 name=/boot/image/3.1.2H-MHYPERr758
mem_vir=0 mem_phys=9B1 mem_len=8195 !!!!!!!!!!!!!!!! PORQUE TIENE LONGITUD MITAD !!!!!!!!! recuerdo q en algun lado esto se calcula!
mem_vir=5 mem_phys=9B6 mem_len=0
mem_vir=80 mem_phys=A31 mem_len=0
mem_vir=3FFD mem_phys=49AE mem_len=16253


20131128: 	Se habilitar PM, FS y MEM en VMx

20131128/30: 	Se habilito el IS de la VM0 para que presente info del kernel de las otras VM.
				Se habilito la tecla F12 para que cambie de VM cuya info se va a presentar. Esto cambia la variable global IS_active_vm
					(solo entre las VMs habilitadas, (LOADED | RUNNING)). 
				Se modifico do_getinfo en la SYSTASK para detectar que el pedido viene de 
					IS de la VM0. 

20131201:		Se modifico  setup_bproc para que el uso de memoria de los procesos de las VMx de 
				CLOCK, IDLE, SYSTASK, HARDWARE sea consistente.
				
				-nr-----gen---endpoint--name--- -prior-quant- -user---sys----size-rts flags-
(-4)      0         -4  idle     15/08 04/08      0     0    264K M----- <<<<<<<<<<<<<<<<<<<< MEMORIA OK, CPU MAL.
[-3]      0         -3  clock    00/08 04/08      0     0    264K M----- <<<<<<<<<<<<<<<<<<<<
[-2]      0         -2  system   00/08 04/08      0     0    264K M----- <<<<<<<<<<<<<<<<<<<<
[-1]      0         -1  kernel   00/08 04/08      0     0    264K M----- <<<<<<<<<<<<<<<<<<<<
  0       0          0  pm       03/32 32/32      5     0    128K --R--- ANY
  1       0          1  fs       04/32 32/32      0     0   4956K M-----
  2       0          2  rs       03/04 04/04      0     0     48K M-----
  3       0          3  mem      03/04 04/04      2     0    304K --R--- ds
			
20131201:		Se agrego el campo vm_uptime, para contabilizar el tiempo cuando arranco la VM y 
				el  vm_time para contabilizar los ticks que se estuvieron ejecutando los procesos de la VMx
				Se cambio el tiempo uso de CPU de IDLE de la VMX como el tiempo usado por todas las otras VMs desde que
					la VMx arranco. 
				get_uptime() de CLOCK.C responde por VM.
			

20131201:		Se habilito el VMM de VMx como VIRTUAL_SERVER y se probó probar la comunicacion con PROXY_SERVER
20131202:		Se uso como VIRTUAL_TASK a TTY_PROC_NR  
20131203:		Se implementaron y probaron mini_sendas() y mini_recvas()

20131204:		Se probo desde PROXY SERVER (loadvmimg.c) operar sobre archivos. TODO OK
			Sin saber la razón del problema, cuando uno hace printf no imprime en la tty.
			Pero funciona OK cuando se hace un open("/dev/console","rw"); y luego fwrite()
			Se creo la infraestructura de funciones para:
				* inicializar los drivers
				* ejecutar el driver


20131205:		Se habilita la posibilidad de utilizar PROMISCUOUS_TASK.
20131206:		PROMISCUOUS_TASK:
				Es un Driver de la VM0 que puede antender peticiones de diferentes VMs.
				Para ello debería estar reprogramado para usar estas las nuevas primitivas y operar en funcion de 
				la VMx que tiene que atender.
			Se generaron nuevas primitivas
				mini_sendvm(caller, dest, &msg, vmid) 
				vmid = mini_recvvm(caller,src, &meg, vm)  vm: de que vm quiere recibir mensajes (ANY_VM)
					si vmid < 0 => ERROR
					sino, retorna el vmid del proceso del q recibio el mensaje
			Se modifico floppy.c para utilizar recvvm y sendvm
			Se necesito modificar libdriver que es utilizado por todos los disp de bloques
			Funcionó OK!


20131207:		Se concentraron las funciones
20131208:				send, sendvm, sendas    ==> mh_send
					receive, recvvm, recvas ==> mh_receive
				Para probar:
					-  recvvm/sendvm: se transformo a FLOPPY en una PROMISCUOUS_TASK reeemplazando en floppy.c y libdriver/driver.c 
						los receive(ANY, &msg) por recvvm(ANY, &msg, VM0) y send(dst, &msg) por sendvm(dst, msg, vm)
						Solo se provo en VM0
					- sendas/recvas:   Al arrancar una VMx, el DS ejecuta ds_test(), alli lo ultimo que hace es enviar un mensaje a 
						sendrec(TTY_PROC_NR, &msg). TTY_PROC_NR fue cargado por loadvmimg.c como VIRTUAL_TASK.
						Cuando el DS envia un mensaje a TTY_PROC_NR al ser una VIRTUAL_TASK le hace un notify_proxy() al proxy 
						que es loadvmimg.c (sender == HARDWARE, id = TTY_PROC_NR)
						Este está haciendo un receive, y al detectar q proviene de HARDWARE obtiene el driver_id
						Luego de eso hace un recvas(ANY, &msg, driver_id). Alli está encolado el mensaje de DS.

						Luego responde al mensaje de DS con sendas(m.source, &m, driver_id);
						
20131209:		Se incorporó el codigo original de minix en el #else /* MHYPER*/ de proc.c 
			Para facilitar la lectura se separaro completamente el codigo de MHYPER del de MINIX en proc.c
			Se incorporar el control de privilegios a las nuevas primitivas

			Para testear el funcionamiento de PROMISCUOUS_TASK (floppy) desde otras VMs, se modifico:
				-  floppy.c y driver.c para mostrar el pedido
				- do_vmmreq.c para establecer a floppy como una PROMISCOUS TASK de la VMx

RECVVM: caller_ep=35552 src=31438 vmid=-1						<==== FLOPPY hace recvvm(ANY,&msg,ANY_VM)

SENDREC: caller_ep=6 dst=35552 running_vm=1 					<==== DS de VM1 hace SENDREC al endpoint de FLOPPY en VM1 
proc.c:417 vmid=0 nr=13 endp=35552 name=floppy flags=8 misc=2		<==== se puede apreciar que misc=2=PROMISCUOUS_TASK		
hdebug: name=floppy vmid=0 nr=13 ep=35552 driver_task: rqst_vmid:1	<==== El recvvm de FLOPPY recibe la peticion de VM1
hdebug: name=floppy vmid=0 nr=13 ep=35552 driver_task: mess.IO_ENDPT:6  <==== de DS 
hdebug: name=floppy vmid=0 nr=13 ep=35552 driver_task: mess.m_type:1024 <==== recibe un CANCEL
hdebug: name=floppy vmid=0 nr=13 ep=35552 driver_task: CANCEL:1024

hdebug: name=floppy vmid=0 nr=13 ep=35552 floppy.c f_name fd:0 		<==== floppy imprime fd0
SENDVM: caller_ep=35552 dst=6 vmid=1						<==== le retorna al DS la respuesta
RECVVM: caller_ep=35552 src=31438 vmid=-1						<==== vuelve a hacer recvvm(ANY,&msg,ANY_VM)
hdebug: name=ds vmid=1 nr=6 ep=6 ds_test: sendrec floppy rcode:0		<==== DS de VM1 recibe todo OK.

			Se creo sys_vircopy_vm() 	
			s= sys_vircopy_vm(src_ep, src_vmid, src_addr, dst_ep, dst_vmid, dst_addr, len);
			que es usada por el RS como PROMISCUOUS_TASK cuando se le pide información sobre
			su tabla de procesos.
			
    		Se modifico RS para que sea PROMISCUOUS_PROC_TYPE usando sendvm y recvvm 
			y se seteo en kernel/table.c para que mh_start lo cargue como PROMISCUOUS_TASK en la VMx.
			
			Para probar el funcionamiento se modifico ds_test.c (DS) para que le copie a su espacio
			de direcciones la tabla de procesos del RS. FUNCIONO OK

20131210:	Se convirtio RS en una REAL_TASK para que a futuro pueda:
				- Reportar al IS acerca de sus procesos (propios de la VM)
				- Para que el comando service le permita setear el tipo de driver
						- REAL_PROC_TYPE
						- VIRTUAL_PROC_TYPE
						- PROMISCUOUS_PROC_TYPE
						- DISABLED_PROC_TYPE
			Se toco ds_test.c y se anulo la impresion de los datos de los procesos de RS
			porque da exception dado que los datos estan incompletos.

20131211:	Para comenzar con la habilitación del FS, debemos habilitar el arranque desde disco RAM
		Estos son los valores de los parametros al bootear VM0 desde RAM
ingresar los siguientes parametros en boot>
 	rootdev=ram
      ramimagedev=bootdev
      ramsize=0

# Dump of kernel environment strings set by boot monitor.(VM0)
rootdev=256 		<===================
ramimagedev=896		<===================
ramsize=0
processor=686
bus=at
video=vga
chrome=color
memory=800:92570,100000:FDF0000
image=boot/image

		En do_vmmreq.c se agrego el cambio del "rootdev" a 256 (=> disco ram mayor=1 minor=0 = mayor*256+minor)
		Se habilito en table.c FS e INIT
		Se intento abrir el archivo /etc/rc desde INIT de la VM0 lograndose con EXITO!!!

hdebug: name=init vmid=1 nr=8 ep=8 INIT: open mhfd:0 <= mhfd = open("/etc/rc", O_RDONLY);
hdebug: name=init vmid=1 nr=8 ep=8 INIT: read n:256 <= n = read(mhfd, buf, MAXBUF);
hdebug: name=init vmid=1 nr=8 ep=8 #!/bin/sh		<=!!!! contenido del /etc/rd del disco RAM de booteo!!!!!
set -e
/bin/service :256


20131212: 	Se habilitaron FLOPPY e IS como PROMISCUOUS_TASK en VMx
		Se modifico virtual_copy() en SYSTASK para que modifique la direccion de copiado
		si el caller->p_vmid != VM0  y el espacio de direcciones a copiar o desde donde copiar
		le pertenece a una PROMISCUOUS_TASK.
		Este es el caso del PM o FS o RS o DS de la VMx que quieren copiarle datos al IS de la VM0 que es PROMISCUOUS_TASK.
		
		Se modifico el IS para que le envíe un sys_getinfo() al PM de la VMx para obtener la info de procesos del PM (Shift-F1)
		Está dando error porque el IS de la VM0 le envia un sendrecvm al PMx y como este es un proceso que no se carga en el 
		booteo, el PMx no lo tiene registrado y su funcion pm_isokendpt().
		Para ello se TOCO EL PM (hay que volverlo atras cuando se quede habilitado el comando SERVICE ) para que cuando
		no tiene registrado un proceso (en nuestro caso el IS) le pregunte al kernel.

# Process manager (PM) process table dump
-process- -nr-prnt- -pid/ppid/grp- -uid--gid- -nice- -flags------
      pm    0   2     0   5   0    0(0)  0(0)   -10  ----------DP
      fs    1   2     4   5   0    0(0)  0(0)    -8  ----------DP
      rs    2   8     5   1   0    0(0)  0(0)   -10  ----------DP
     mem    3   2     8   5   0    0(0)  0(0)   -13  ----------DP
     log    4   2     9   5   0    0(0)  0(0)   -13  ----------DP
     tty    5   2     7   5   0    0(0)  0(0)   -16  ----------DP
      ds    6   2     6   5   0    0(0)  0(0)   -10  ----------DP
     vmm    7   2    10   5   0    0(0)  0(0)   -10  ----------DP
    init    8   2     1   5   1    0(0)  0(0)     0  W-----------


20131212:    Se incluye en do_vmmreq() la incorporacion ficticia a la imagen de booteo aquellos PROMISCUOUS_TASKS
		a los fines que el PM, FS los reconozcan como tales.
		Como se usa NR_BOOT_PROCS para reservar espacio y para hacer los loops se incluyo en kinfo el campo nr_bprocs
		y se cambiaron los loops para que lo usen y los espacios reservados al maximo
			struct boot_image image[PROCESS_MAX+NR_TASKS];			
		En este momento NO BOOTEA porque hay alguna falla en el RS.

20131216: Se incorporo FLOPPY e IS como PROMISCUOUS_TASKS en las VMx dentro de los procesos de booteo (kernel/table.c)
			Se cambio el corrige entonces el nro de proceso de booteo para considerarlos (get_vmmcmd.c)
			Se cambiaron RS y PM para que usen el nro de procesos de booteo que el kernel informa y 
			no la constante NR_BOOT_PROCS.
			
20131217:	Se modifico el IS pero sin el define MHYPER!!!
			Ahora funcionan todas las teclas relacionasdas con el KERNEL
			(excepto scheduling queues)y el PM

20131218:   Se creo el test_hdebug.c que solo imprime 
			hdebug: name=test_hd vmid=1 nr=9 ep=35548 012345678900123456789001234567:1234
			Este es el programa de pruebas de ejecución en la VM1
			En el driver/memory/ramdisk esta el archivo "proto" que dice cuales archivos deben
			incluirse en el directorio del root de booteo. Este es un truco que tiene el comando
			mkfs que permite crear el FS y cargarle archivos con determinado atributos
			Se modifico el Makefile y proto incluyendo 
					test_hdebug ---755 0 0 test_hdebug
			Para saber el formato hacer man mkfs
			FUNCIONA TODO OK!!
			Se copio el disco root para usarlo para booteo de la VM1
				/dev/c0d0p0s0 es el dispositivo (3,128) = 3*256+128 = 896 q es lo que dice F5
				/dev/c0d1p0s0 es el dispositivo (3,144) = 3*256+144 = 912
			Se modifico do_vmmreq.c para ello.
			Se modifico at_wini para que sea PROMISCUOUS_TASK 
			Se modifico kernel/table.c, minix/com.h, para que sea considerado promiscuo.
			INIT: funciona correctamente la apertura de archivos y la ejecucion de programas.
			Finalmente se anulo de init.c todo lo especifico de MHYPER para que puede ejecutar correctamente
			pero luego envia un mensaje a un tty (VIRTUAL) pero este tiene q enviar un mensaje a log que es REAL en la VM1.
			Por lo tanto se debe hacer NOTIFY_VM y asi permitir modificar TTY para que sea promiscuo.
					
			
20131218	Se implemento notifyvm() para ser usada por PROMISCUOUS_TASK

20131229:	Se modificaron proc.c y system.c removiendose MHDEBUG ya superfluos
			Se agregaron MHDEBUG mas completos para hacer un seguimiento de los mensaje enviados.

20131230:		Se implemento en lugar de chvmid, prtmsg que imprime un mensaje a los fines de debugging

20131231:		Se modifico TTY para que responda a la VMID correspondiente. 
				Resulta que funciona tan bien todo que como se puede ver abajo se levantan
				2 floppys (uno promiscuo)
				2 at_wini
				1 pci, 1 newroot, incluso la shell!!!!
				
			
-nr-----gen---endpoint--name--- -prior-quant- -user---sys----size-rts flags-
(-4)      0         -4  idle     15/08 04/08  19716     0    280K M-----
[-3]      0         -3  clock    00/08 04/08      0     0    280K M-----
[-2]      0         -2  system   00/08 04/08      0     0    280K M-----
[-1]      0         -1  kernel   00/08 04/08      0     0    280K M-----
  0       0          0  pm       06/32 32/32    193     0    128K --R--- ANY
  1       0          1  fs       12/32 32/32    334     0   4956K -SR--- at_wini
  2       0          2  rs       04/04 04/04     13     0     52K --R--- ANY
  3       0          3  mem      04/04 04/04     95     0    304K --R--- ANY
  4       0          4  log      03/04 04/04      2     0     76K --R--- ANY
  5       0          5  tty      01/04 04/04      0     0     84K M-----
  6       0          6  ds       03/04 04/04      1     0    100K --R--- ANY
  7       0          7  vmm      03/32 32/32      0     0     44K M-----
  8       0          8  init     07/08 08/08      1     0     16K --R--- pm
  9       1      35548  sh       07/08 08/08      2     0    180K --R--- pm
 11       1      35550  pci      04/04 04/04    947     0     48K --R--- tty
 13       1      35552  floppy   03/04 04/04      0     0      0K M-----
 14       1      35553  floppy   04/04 04/04      2     0     24K --R--- ANY
 16       1      35555  at_wini  03/04 04/04      0     0      0K M-----
 18       1      35557  at_wini  04/04 04/04      8     0     88K -SR--- pci
 22       1      35561  newroot  07/08 08/08      3     0    140K --R--- fs
 23       1      35562  is       03/04 04/04      0     0      0K M-----

20140101:  Se modifico do_exec (SYSTEM) para que detecte si desde la VMx se arranca un 
			PROMISCOUS driver (De igual forma se puede hacer con un PROXY_DRIVER)	
			Se modifico PCI para que actuara como PROMISCUO.
			
20140102: 	Se removieron partes de codigo insertado previamente para pruebas en at_wini y libdriver
			Aparentemente ahora funciona bien el disco rigido 
			
PROBLEMA: Se cuelga, aparentemente en TTY.


SENDREC: src=fs dst=5 source=1 type=100 m1i1=15 m1i2=35534 m1i3=5029688 m1p1=5EE8 m1p2=0 m1p3=10001 
mh_send src=fs dst=5, src_vmid=1 dst_vmid=0 dst_flags=0
mh_send3 name=fs caller_p=1 vmid=1 dst=tty flags=0 
mh_receive name=fs src_ep=5 flags=4 vmid=1
mh_receive: src=fs dst=tty misc=0 vmid=1 source=1 type=100 m1i1=15 m1i2=35534 m1i3=5029688 m1p1=5EE8 m1p2=0 m1p3=10001 
mh_receive:  caller=tty ret_vmid=1
hdebug: name=tty vmid=0 nr=5 ep=5 TTY tty_mess.m_type:100
prtmsg: proc=tty vmid=0 source=1 type=100 m1i1=15 m1i2=35534 m1i3=5029688 m1p1=5EE8 m1p2=0 m1p3=10001 
mh_receive name=mem src_ep=31438 flags=0 vmid=1
COLGADA!!!!!

20140103:	Se  modifico TTY para que soporte multiples VMs. NO FUNKA
			Se dejaron varias modificaciones solo mencionando a la VM0 hasta hacerlo andar vectorizado.

20140104:	Se VECTORIZARON las estructuras de datos de KEYBOARD, CONSOLE, RS232_LINE, PTTY
			
20140110:	En TTY Se cambiaron los sys_vircopy x sys_vcopyvm para poder copiar datos desde la TTY (VM0) al proceso de la VMx
			se deben reemplazaron los notify x notifyvm


20140111:	Se agrego el campo s_vm_bitmap a la estructura priv.
			Se cambio el mh_notify de tal modo que cuando se hace un notify no solo van los argumentos estandares
			sino tambien la VMID del emisor y el s_vm_bitmap del receptor. (por ejemplo una tarea promiscua)
			Cuando se crea un proceso promiscuo al arrancar la VMx, la SYSTASK envia un notify(VMM_PROC_NR, promiscuo)  con running_vm=VM0 
			Cuando la tarea (p ejemplo TTY) recibe un mensaje de tipo NOTIFY(scr) y src=VMM_PROC_NR, obtiene del mensaje el nuevo bitmap
			de alli obtiene la nueva VM que deberá atender, por lo tanto puede inicializar sus estructuras de datos.
		TODO:	Dificilmente se activen mas de una VM a la vez, por lo que el nuevo bitmap solo deberia diferir en 1 bit
			Por las dudas verificar que no quedan mas bits por inicializar
			
20140119:	Se modifico la forma de trabajo de la CONSOLA. Ahora todas las consolas seran de la VM Activa.
			Para cambiar de VM presionar ALT-UP o ALT-DOWN
				#define AUP	(0x03 + ALT)
				#define ADOWN	(0x04 + ALT)
			Para ello casa VM tiene su set de pseudo-consolas en memoria, en donde se realizaran
			las operaciones sobre ellas tal como si estuviesen en memoria de video.
			Solo las consolas de la VM activa que es la que esta usando memoria de video se actualizaran.

			Cuando se cambia de VM, se hace un swap desde:
				1) la VID->MEM de la VM activa saliente vid_mem_copy(): rutina en assembler agregada
				2) la MEM->VID de la VM activa entrante mem_vid_copy()

			typedef struct cons_tab_s {
				console_t 	ct[NR_CONS];
				int		cline;			/* saved current console		*/
				char  		vscreen[EGA_SIZE]; 	/* memory space to emulate video memory for non active VMs */
			} cons_tab_t;
			PRIVATE cons_tab_t cons_table[NR_VMS];

			int ccurrent;				/* # currently visible console */
			console_t *curcons;			/* pointer to currently visible */
			phys_bytes  *phys_video;	/* physical address of VIDEO memory */	

			Cuando se inicializa la CONSOLA por primera vez se debe almacenar phys_video:
			s = sys_umap(SELF, vid_index, vid_off, vid_size, &phys_video); 	

			curcons    = &cons_table[vmcurrent].ct[ccurrent];

20140125:	Se modifico console.c para que todos las escrituras a consola de otra VM != vmcurrent 
			deben realizarse sobre el swap de las consolas en memoria.


20140126:   Se modifico el comando simple "readfs"

20140127:   Se incluyo el dump de los bitmaps de INODES y ZONAS y el listado del contenido de INODES en "readfs"

20140130:	Se modifico driver.c de tal modo que cuando desde otra VM != VMO se intenta hacer un OPEN de un DEVICE PROMISCUO
			entonces se ignora el OPEN.
				
20140130:	Las correcciones a at_wini.c y driver.c provocaban errores porque el disco ram era de 1440 KB!!!!!!!
			En el archivo drivers/memory/proto esta el formato de lo q contendra el FS RAM. Se amplio a 2880 KB!!!
				boot 
				280 310 <<<< cantidad de BLOQUES/INODOS 
				d--755 0 0
				bin d--755 0 0
	
20140201:	Se modifico driver.c y at_wini.c para que usen vcopyvm y umapvm
			Bootea hasta FSCK 
			ATWINI got unexpected message 1032 (DEV_SCATTER) from 1 (FS)
			Se hicieron copias de respaldo !!
			
20140202:	Se modifico del disco c0d1p0 los arcivos /etc/rc /usr/local/etc
			de tal modo que no hagan el FSCK y no carguen los drivers ni ejecuten mas cosas
			El FSCK se hace igual!
	
20140303:	PROBLEMAS CON BOOTEO EN VM1 
			Arranca casi todo, falta que continue 
			En init.c el PARENT hace wait
			
			/* Execute the /etc/rc file. */
  /* Execute the /etc/rc file. */
  if ((pid = fork()) != 0) { /* PARENT */
107  _mhdebug(__FILE__,__LINE__);
108  _mhdebug("PARENT waits for",pid);
	/* Parent just waits. */
	while ( (r = wait(NULL)) != pid) {
	  _mhdebug(__FILE__,__LINE__);             <<<<< ESTA NUNCA SE EJECUTA
     _mhdebug("PARENT wait return",r);
		if (gotabrt) reboot(RBT_HALT);
	}
  _mhdebug(__FILE__,__LINE__);
  } else { /* CHILD */
  
			Aparentemente el CHILD termina OK.
			
			ACA el padre INIT envia el wait al PM
hdebug: name=init vmid=1 nr=8 ep=8 init.c:107
hdebug: name=init vmid=1 nr=8 ep=8 PARENT waits for:11
SENDREC: src=init dst=0 source=8 type=7 m1i1=7499622 m1i2=0 m1i3=0 m1p1=0 m1p2=0 m1p3=0  <<< WAIT
mh_receive name=init src_ep=0 flags=0 vmid=1
hdebug: name=pm vmid=1 nr=0 ep=0 PM get_work who_e:8
hdebug: name=pm vmid=1 nr=0 ep=0 PM get_work call_nr:7
hdebug: name=pm vmid=1 nr=0 ep=0 get_work vmid:1
mh_receive name=pm src_ep=31438 flags=0 vmid=1

			Despues que se ejecuta el /etc/rc y una vez finalizada la shell(p_nr=9, ep=35548) que lo ejecuta 
SENDREC: src=pm dst=-2 source=0 type=1538 m1i1=35548 m1i2=0 m1i3=0 m1p1=0 m1p2=18FB4 m1p3=11A1 
mh_receive name=pm src_ep=-2 flags=0 vmid=1
SYSTEM: source=0 type=1538 m1i1=35548 m1i2=0 m1i3=0 m1p1=0 m1p2=18FB4 m1p3=11A1 
clear_proc running_vm=1
do_exit.c:60 vmid=1 nr=9 endp=35548 name=sh flags=108 misc=1
clear_endpoint running_vm=1
system.c:609 vmid=1 nr=9 endp=35548 name=sh flags=108 misc=1
LOCKSEND src=system dst=0 source=-2 type=0 m1i1=35548 m1i2=0 m1i3=0 m1p1=0 m1p2=18FB4 m1p3=11A1 <<<< SYSTEM DA EL OK para la finalizacion de shell

			Ahora le toca seguir al PARENT (init, p_nr=8, ep=8)			
hdebug: name=pm vmid=1 nr=0 ep=0 PM setreply:11
SEND: src=pm dst=8 source=0 type=11 m1i1=0 m1i2=0 m1i3=0 m1p1=0 m1p2=0 m1p3=0 
exception proc=8 name=init vmid=1 running_vm=1
raw_notify: src_p=-2 dst_p=0

		!!!!!!!!!!!!!! PORQUE OCURRE UNA EXCEPCION DESPUES DEL SENDREC() ??????????????????????

			El estado en que queda INIT es el que muestra la figura.
[-3]      0         -3  clock    00/00 08/08      1     0    228K --R--- ANY
[-2]      0         -2  system   00/00 08/08     29     0    228K ------
[-1]      0         -1  kernel   00/00 08/08      0     0    228K M-----
  0       0          0  pm       14/32 14/32  83855     0    124K --R--- ANY
  1       0          1  fs       14/32 32/32   4233     0   4956K --R--- ANY
  2       0          2  rs       04/04 04/04     21     0     48K --R--- ANY
  3       0          3  mem      04/04 04/04    117     0    584K --R--- ANY
  4       0          4  log      04/04 04/04    159     0     76K --R--- ANY
  5       0          5  tty      01/04 04/04      0     0    444K M-----
  6       0          6  ds       03/04 04/04      0     0     96K --R--- ANY
  7       0          7  vmm      03/03 32/32      2     0     44K --R--- system
  8       0          8  init     08/08 08/08      0    34     16K ---IP-<<<<<  SIG_PENDING | SIGNALED
 11       1      35550  pci      03/03 04/04      8     0     48K ------
 13       1      35552  floppy   03/03 04/04      0     0     24K ------
 16       1      35555  at_wini  03/03 04/04     65     0     92K ------
 25       1      35564  is       03/03 04/04      0     0    440K ------
 27       1      35566  cmos     04/04 04/04     39     0     16K --R--- ANY
 43       1      35582  random   14/04 02/04  34100     0     44K ------
 49       1      35588  lance    04/04 04/04      2     0     76K --R--- ANY
 56       1      35595  inet     04/04 04/04    523     0    900K --R--- ANY
 59       1      35598  printer  04/04 04/04      0     0    140K --R--- ANY
 62       1      35601  update   08/08 08/08    108  1712     16K --R--- pm
--more--
# screendump > vm1.txt

		Quizas hay que crear algo sys_sdeviovm para solucionar esto:
					if ((s=sys_insw(wn->base_cmd + REG_DATA, proc_nr, 
				(void *) iov->iov_addr, SECTOR_SIZE)) != OK)
		
		#define sys_insw(port, proc_nr, buffer, count) \
			sys_sdevio(DIO_INPUT, port, DIO_WORD, proc_nr, buffer, count)
		#define sys_outsw(port, proc_nr, buffer, count) \
			sys_sdevio(DIO_OUTPUT, port, DIO_WORD, proc_nr, buffer, count)

			
20130309:	Se modifico AT_WINI.C y DRIVER.C para que una vez que llega una petición de un proceso de una VM dada
			hasta que no lo responde cambia src_vm=VM0. Es decir tanto interrupciones como timeouts seran recibidos desde la VM0
			PROBLEMAS A RESOLVER: El AT_WINI es MONO-CLIENTE!!!!!
				1- El RS de la VM1 tambien envia DEV_PING al AT_WINI que está en la VM0. Si AT_WINI se bloquea haciendo w_intr_wait 
					esperando interrucpiones o timeouts de la VM0, nunca recibira el DEV_PING del RS de la VM1
				2- Si el que hizo la peticion hacia el AT_WINI fue el FS1, y el AT_WINI se bloquea haciendo w_intr_wait 
					esperando interrucpiones o timeouts de la VM0, el FS0 aun puede enviar mensajes los cuales no van a ser atendidos
					correctamente en w_intr_wait():
			SOLUCION PROVISORIA:
				1-  Se cambio por un receive. Si el rqst_vmid != VM0 entonces solo se esperan interrupciones de HARDWARE
				
		/*****************************************************/
		/* TRUCHADA: Solo permito INTERRUPCIONES    	*/
		/*  si el pedido pendiente provino de vmid != VM0	*/
		/*****************************************************/
		if( rqst_vmid != VM0)
			sender = HARDWARE;
		else
			sender = ANY;
			
		r = receive(sender, &m);		
-------------------------------------------------------------------------------------------------------------------------			
20140311:	Se asumio siempre que el NOTIFY era un UP-CALL, pero resulta que el RS lo usa para monitorear a los procesos
			SOLUCION: Se modifico el mh_notify para que cuando se hace un notify() desde una VM != VM0 y el proceso
			destinatario es PROMISCUO y no esta esperando mensajes, se bloquea el sender con flag NOTIFYING y encolandose
			en la misma cola de procesos emisores del proceso destino como el send() y sendrec().
			Con esto se solucionó el problema (1) del 20130309.
			PROBLEMA PENDIENTE:
				Cuando se espera por una interrupcion (VM0) atendiendo un pedido de la VM != VM0, no se quieren recibir
				pedidos de la VM0.
			POSIBLE SOLUCION:
				Incluir un nuevo tipo de endpoint LOWER_TASKS (HARDWARE, CLOCK, SYSTASK)
				#define LOWER_TASKS		(IDLE-1)  /* used to indicate HARDWARE, CLOCK, SYSTASK , IDLE */

-------------------------------------------------------------------------------------------------------------------------			
20140319:	Se incorporo el soporte de LOWER_TASKS paro no funciono bien por eso que se dejo en at_wini.c el receive(HARDWARE, &m)
			para solo esperar por una IRQ.
			El init se sigue dando exception
			El at_wini dio una exception pero se soluciono ampliando el stack del Makefile via install -S <tamaño>
			Lo mismo se hizo para init pero sin resultados.
			
			Posible problema. Que cuando finaliza el init (hijo) remueve el codigo, y el padre tiene algun problema de volver.

ERRORES:
			isokendpt3: proc_ptr(pci,11,0,0) src_dst(cat,49,0,1). running_vm=0
			hdebug: name=tty vmid=0 nr=5 ep=5 do_init: unable to send to 355:39		
				
MODIFIQUE LOS SCRIPTS DE ARRANQUE EN EL DISCO DE LA VM1

		MENSAJE: AT_WINI got unexpected message 1027 from 1 rqst_vmid=0
		
VM1: 
El FS->AT_WINI DEV_READ
SENDREC: src=fs dst=AT_WINI source=1 type=DEV_READ m1i1=130 m1i2=1 m1i3=4096 m1p1=30000 m1p2=0 m1p3=EFD98 
mh_send src=fs dst=16, src_vmid=1 dst_vmid=0 dst_flags=8
proc.c:447 vmid=0 nr=16 endp=AT_WINI name=at_wini flags=8 misc=2
mh_receive name=fs src_ep=AT_WINI flags=0 vmid=1
hdebug: name=at_wini vmid=0 nr=16 ep=AT_WINI driver_task: rqst_vmid:1
prtmsg: proc=at_wini vmid=0 source=AT_WINI type=1027 m1i1=130 m1i2=1 m1i3=4096 m1p1=30000 m1p2=0 m1p3=EFD98 
hdebug: name=at_wini vmid=0 nr=16 ep=AT_WINI do_rdwt: sys_umapvm:1
SYSTEM:do_umapvm: m_source=AT_WINI seg_type=0 endpt=1 vmid=1 
hdebug: name=at_wini vmid=0 nr=16 ep=AT_WINI at_wini: w_prepare device:146
hdebug: name=at_wini vmid=0 nr=16 ep=AT_WINI at_wini: Check disk address:196608
hdebug: name=at_wini vmid=0 nr=16 ep=AT_WINI at_wini: w_transfer nbytes:4096
hdebug: name=at_wini vmid=0 nr=16 ep=AT_WINI at_wini: w_transfer dv_size:-861236224
hdebug: name=at_wini vmid=0 nr=16 ep=AT_WINI at_wini: reinitialization:21
hdebug: name=at_wini vmid=0 nr=16 ep=AT_WINI at_wini: w_transfer do_dma:1
SYSTEM:do_umapvm: m_source=AT_WINI seg_type=0 endpt=1 vmid=1 
hdebug: name=at_wini vmid=0 nr=16 ep=AT_WINI at_wini: do_dma:1
hdebug: name=at_wini vmid=0 nr=16 ep=AT_WINI at_wini: do_dma rcode:0
hdebug: name=at_wini vmid=0 nr=16 ep=AT_WINI at_wini: return OK:1

AT_WINI responde a FS  
SENDVM: src=at_wini dst=1 vmid=1 source=AT_WINI type=68 m1i1=1 m1i2=4096 m1i3=4096 m1p1=30000 m1p2=0 m1p3=EFD98 
mh_send1 name=at_wini caller_p=16 vmid=0 PROMISCOUS_TASK 
SE SUPONE QUE AQUI TERMINO EL CICLO AT_WINI Y DEBERIA HACER UN RECVVM()

FS->SYSTASK SYS_VIRCOPY FS->USER (rm)
SENDREC: src=fs source=1 type=SYS_VIRCOPY m1i1=65537 m1i2=1 m1i3=35579 m1p1=4CBF9C m1p2=21E34 m1p3=24 
mh_receive name=fs src_ep=-2 flags=0 vmid=1
SYSTEM: source=1 type=SYS_VIRCOPY m1i1=65537 m1i2=1 m1i3=35579 m1p1=4CBF9C m1p2=21E34 m1p3=24 
LOCKSEND src=system dst=1 source=-2 type=0 m1i1=65537 m1i2=1 m1i3=35579 m1p1=4CBF9C m1p2=21E34 m1p3=24 
mh_receive name=system src_ep=31438 flags=0 vmid=1
hdebug: name=fs vmid=1 nr=1 ep=1 FS reply:0
SEND: src=fs dst=35579 source=1 type=0 m1i1=3 m1i2=4 m1i3=0 m1p1=FAD0 m1p2=0 m1p3=0 
hdebug: name=fs vmid=1 nr=1 ep=1 FS: get_work vmid:1
mh_receive name=fs src_ep=31438 flags=0 vmid=1
SENDREC: src=rm dst=1 source=35579 type=10 m1i1=20 m1i2=0 m1i3=6188 m1p1=0 m1p2=3 m1p3=4 
mh_receive name=rm src_ep=1 flags=0 vmid=1
hdebug: name=fs vmid=1 nr=1 ep=1 FS get_work who_e:35579
hdebug: name=fs vmid=1 nr=1 ep=1 FS get_work call_nr:10
SENDREC: src=fs source=1 type=SYS_VIRCOPY m1i1=65537 m1i2=35579 m1i3=1 m1p1=182C m1p2=4C2A54 m1p3=14 
mh_receive name=fs src_ep=-2 flags=0 vmid=1
SYSTEM: source=1 type=SYS_VIRCOPY m1i1=65537 m1i2=35579 m1i3=1 m1p1=182C m1p2=4C2A54 m1p3=14 
LOCKSEND src=system dst=1 source=-2 type=0 m1i1=65537 m1i2=35579 m1i3=1 m1p1=182C m1p2=4C2A54 m1p3=14 
mh_receive name=system src_ep=31438 flags=0 vmid=1

EL FS le esnvia un mensaje DEV_READ al AT_WINI, pero aparentemente este no lo esta esperando!
SENDREC: src=fs dst=AT_WINI source=1 type=DEV_READ m1i1=130 m1i2=1 m1i3=4096 m1p1=22F3000 m1p2=0 m1p3=F0DAC 
mh_send src=fs dst=16, src_vmid=1 dst_vmid=0 dst_flags=8
mh_receive name=fs src_ep=AT_WINI flags=0 vmid=1
hdebug: name=tty vmid=0 nr=5 ep=5 AT_WINI got unexpected message:55

-------------------------------------------------------------------------------------------------------------------------
20140619:	MODIFICACIONES PARA QUE FLOPPY SEA VIRTUAL 
			Modifique kernel/table.c para incluir el vector de los procesos VIRTUALES
			Modifique system/do_exec.c para que los reconozca al cargar con exec (es decir, no en boot time)
			
			while (1) {
				_mhdebug("do_proxy: receive from", ANY);
				rcode = receive(ANY, &m);
			
			hdebug: name=VM1 vmid=0 nr=34 ep=71112 do_proxy: receive from:31438
			El receive no lo muestra, pero no deja ningun rastro mas.
			pero al presionar F1 lo muestra como ------R----- ANY 
			
			AQUI HAY INCONSISTENCIA
			462 mh_send: MHDEBUG(PROC_FORMAT, PROC_FIELDS(dst_ptr));
			
			PM->RS informandoles acerca de 35552(FLOPPY)
			SEND: src=pm dst=2 source=0 type=15 m1i1=35552 m1i2=1 m1i3=0 m1p1=0 m1p2=0 m1p3=0 
			proc.c:462 vmid=1 nr=2 endp=2 name=rs flags=8 misc=1 <<< imprime el nombre correctamente
						
			RS->PM
			SENDREC: src=rs dst=0 source=2 type=80 m1i1=15 m1i2=0 m1i3=1 m1p1=0 m1p2=0 m1p3=0 
			RS espera la respuesta de PM
			mh_receive name=rs src_ep=0 flags=4 vmid=1
			
			PM->35552 
LINE 4510:	SEND: src=pm dst=35552 source=0 type=0 m1i1=35550 m1i2=1 m1i3=0 m1p1=0 m1p2=0 m1p3=0
			proc.c:462 vmid=1 nr=13 endp=35552 name=rs flags=88 misc=1 < IMPRIME MAL EL NOMBRE y misc es 1 (REAL_PROC_TYPE)
			el 88 significa NO_PRIV | RECEIVING
			
LINE 4899: 	do_exec: VIRTUAL floppy
			do_exec.c:88 vmid=1 nr=13 endp=FLOPPY name=floppy flags=0 misc=2000
	
SOLUCION:	NOOOO BALINAZO
			EL RS HACE UN FORK PARA LUEGO EJECUTAR FLOPPY, POR ESO PRIMERO SE LLAMA "RS" !!!!!!!!!!!!!!!!!!!!!!!!111
		
			El proxy hace el receive correctamente
			hdebug: name=VM1 vmid=0 nr=18 ep=71096 do_proxy: receive from:31438
			proc.c:530 vmid=0 nr=18 endp=71096 name=VM1 flags=0 misc=1000

ATENCION!!!!!
			Verificar que las copias y los umaps se hacen sobre el PROXY y no sobre el driver virtual.
					
-------------------------------------------------------------------------------------------------------------------------
20140619:
			Se modifico copy y umap() para que soporte PROXY/VIRTUAL drivers
			Se modifico el ramdisk para que monte el floppy y asi probar PROXY de floppy.

FS1->FLOPPY1			
SENDREC: src=fs dst=FLOPPY source=1 type=1030 m1i1=0 m1i2=35560 m1i3=6 m1p1=206E6570 m1p2=5F6F6877 m1p3=65  
proc.c:412 vmid=1 nr=13 endp=FLOPPY name=floppy flags=0 misc=2000
mh_send3 VIRTUAL_TASK name=fs caller_p=1 vmid=1 dst=floppy flags=0

HARDWARE->PROXY 
notify_proxy: proxy_ep=71097 proxy_nr=19
mh_receive name=fs src_ep=FLOPPY flags=4 vmid=1

Proxy receive()
hdebug: name=VM1 vmid=0 nr=19 ep=71097 do_proxy: receive m_source:-1
hdebug: name=VM1 vmid=0 nr=19 ep=71097 do_proxy: receive NOTIFY_ARG:8192
hdebug: name=VM1 vmid=0 nr=19 ep=71097 do_proxy: driver_nr:13
hdebug: name=VM1 vmid=0 nr=19 ep=71097 tty_driver: driver_nr:13

Proxy recvas() 
rcode = recvas(ANY, mi_ptr, 13);
proc.c:530 vmid=0 nr=19 endp=71097 name=VM1 flags=0 misc=1000
isokendpt_vm2: proc_ptr(VM1,19,0) rp(floppy,13,1) endpoint(FLOPPY!=13) running_vm=0 <<<<<<<<<<<<<< NO COINCIDE !!
hdebug: name=VM1 vmid=0 nr=19 ep=71097 floppy_driver: recvas rcode:-103
hdebug: name=VM1 vmid=0 nr=19 ep=71097 do_proxy: driver_vec rcode:-103

proc.c:530 vmid=0 nr=19 endp=71097 name=VM1 flags=0 misc=1001
proc.c:530 vmid=0 nr=19 endp=71097 name=VM1 flags=0 misc=1001
proc.c:530 vmid=0 nr=19 endp=71097 name=VM1 flags=0 misc=1001
	
-------------------------------------------------------------------------------------------------------------------------
20140620:			Se modifico proc.c
					Se modifico el formato de sendas() y recvas() donde se emula un PROCESS NUMBER no un ENDPOINT !!!
		FUNCIONAMIENTO DEL PROXY DE FLOPPY
	
		_mhdebug("do_proxy: receive from", ANY);
		rcode = receive(ANY, &m);	
hdebug: name=VM1 vmid=0 nr=9 ep=PROXY do_proxy: receive from:31438
hdebug: name=VM1 vmid=0 nr=9 ep=PROXY proxy_init: px_ep:PROXY

		mount->fs MOUNT FLOPPY
hdebug: name=fs vmid=1 nr=1 ep=1 FS: do_mount dev:512 ( device 512=0x200=(2,0) floppy)
hdebug: name=fs vmid=1 nr=1 ep=1 FS: do_mount who_e:35560

		mount->fs OPEN FLOPPY
hdebug: name=fs vmid=1 nr=1 ep=1 FS: dev_open dev:512 ( device 512=0x200=(2,0) floppy)
hdebug: name=fs vmid=1 nr=1 ep=1 FS: dev_open who_e:35560

		FS1->FLOPPY1
SENDREC: src=fs dst=35552 source=1 type=1030 m1i1=0 m1i2=35560 m1i3=6 m1p1=206E6570 m1p2=5F6F6877 m1p3=65 
proc.c:414 vmid=1 nr=13 endp=35552 name=floppy flags=0 misc=2000
mh_send3 VIRTUAL_TASK name=fs caller_p=1 vmid=1 dst=floppy flags=0 
notify_proxy: proxy_ep=71141 proxy_nr=63		
		
proc.c:533 vmid=0 nr=9 endp=PROXY name=VM1 flags=0 misc=1000

		if(rcode) {
			_mhdebug("do_proxy: receive rcode", rcode);
		} else {
			_mhdebug("do_proxy: receive m_source", m_ptr->m_source);
mh_receive name=fs src_ep=35552 flags=4 vmid=1
hdebug: name=VM1 vmid=0 nr=9 ep=PROXY do_proxy: receive m_source:-1

				_mhdebug("do_proxy: receive NOTIFY_ARG",(m_ptr)->NOTIFY_ARG);
hdebug: name=VM1 vmid=0 nr=9 ep=PROXY do_proxy: receive NOTIFY_ARG:8192

				driver_nr = get_driver_nr((m_ptr)->NOTIFY_ARG);
				if(driver_nr == (-1)) 
					_mhdebug("do_proxy: error NOTIFY_ARG", (m_ptr)->NOTIFY_ARG);
				else 
					_mhdebug("do_proxy: driver_nr", driver_nr);
hdebug: name=VM1 vmid=0 nr=9 ep=PROXY do_proxy: driver_nr:13


		rcode = (*driver_vec[driver_nr])(driver_nr);
		_mhdebug("floppy_driver: driver_nr", driver_nr);				
hdebug: name=VM1 vmid=0 nr=9 ep=PROXY floppy_driver: driver_nr:13

		rcode = recvas(ANY, mi_ptr, driver_nr);
RECVAS: name=VM1 src_ep=31438, p_proxy=1
proc.c:533 vmid=0 nr=9 endp=PROXY name=VM1 flags=0 misc=1000
mh_receive: src=fs dst=VM1 misc=1000 vmid=1 source=1 type=1030 m1i1=0 m1i2=35560 m1i3=6 m1p1=206E6570 m1p2=5F6F6877 m1p3=65

		_mhdebug("floppy_driver: recvas rcode", rcode);
hdebug: name=VM1 vmid=0 nr=9 ep=PROXY floppy_driver: recvas rcode:0

		_mhdebug("floppy_driver: mi_ptr->m_type", mi_ptr->m_type);
hdebug: name=VM1 vmid=0 nr=9 ep=PROXY floppy_driver: mi_ptr->m_type:1030 

		rcode = sendas(mi_ptr->m_source, mo_ptr, driver_nr);
SENDAS: name=VM1 dst_ep=1, p_proxy=1

		_mhdebug("floppy_driver: sendas rcode", rcode);
hdebug: name=VM1 vmid=0 nr=9 ep=PROXY floppy_driver: sendas rcode:0

DESCOMPOSICION DEL PEDIDO

* |------------+---------+---------+---------+---------+---------|
 * |  DEV_READ  | device  | proc nr |  bytes  |  offset | buf ptr |
 * |------------+---------+---------+---------+---------+---------|
 * |  DEV_WRITE | device  | proc nr |  bytes  |  offset | buf ptr |
 
src=fs dst=VM1 misc=1000 vmid=1 source=1 
		type=1030 (0X403-DEV_READ)
		m1i1=0 MINOR
		m1i2=35560 (proceso mount)
		m1i3=6 COUNT
		m1p1=206E6570 offset
		m1p2=5F6F6877 
		m1p3=65 ADDRESS
		
-------------------------------------------------------------------------------------------------------------------------
20140620:			Se modifico loadvmimg.c (PROXY)
					Funciona perfectamente READ, WRITE, GATTER, SCATTER
					El floppy se monta perfectamente lee y escribe 
					
					Se probo la conversion entre direcciones locales al proxy y direcciones "remotas" de un proceso dentro de la VM.

					
floppy_driver: DEV_READ: fl_address=2874 rmt_phys=A9F874
floppy_driver: DEV_READ: &lcl_ref=693C lcl_phys=A3793C
floppy_driver: DEV_READ: proc=1 diff=67F38 ref=2874 
floppy_driver: DEV_READ: rmt_virt=6E874					
					
					
					ATENCION!!! : Cada proceso debe tener su variable de referencia y su variable de diferencia!!!
						por lo tanto hay que tener una estructura
struct {
	char *ref;
	long diff;
} rmt2lcl_s; 
typedef rmt2lcl_s rmt2lcl_t;
				
rmt2lcl_t r2l[NR_PROCS];

char *rvirt_lvirt(char *rvirt, int p_nr) 
{
	char *rmt_virt; 
	rmt_virt =  (char *) &lcl_ref;
	rmt_virt 	+= r2l[p_nr].diff;
	rmt_virt	+= ( (long) rvirt - (long) r2l[p_nr].ref);
	return(rmt_virt);
}

-------------------------------------------------------------------------------------------------------------------------
20140621:	Modifique el CMOS para hacerlo PROMISCUOUS pero no funka

			cuando hace el recvvm() deberia estar con el misc en VMID_PENDING
			pero como se puede ver esta apagado

SENDREC: src=fs dst=35571 source=1 type=1030 m1i1=0 m1i2=35572 m1i3=4 m1p1=206E6570 m1p2=5F6F6877 m1p3=65 
proc.c:446 vmid=0 nr=32 endp=35571 name=cmos flags=8 >>>misc=0<<< getf=31438 sent=27342 recv_vm=-1
proc.c:476 vmid=0 nr=32 endp=35571 name=cmos flags=8 >>>misc=0<<< getf=31438 sent=27342 recv_vm=-1
mh_receive name=fs src_ep=35571 flags=0 vmid=1

			por esa razon es que va por donde no debe ir.
			
			REVISAR QUE PASA CON p_misc_flags=0 !!!!

-------------------------------------------------------------------------------------------------------------------------
20140623:	
			OJO: Se anularon de disco de la VM1 en el /etc/rc  y el /usr/etc/rc (c0d1p0s2)
				la carga de cmos y random.
			NO HAY CASO, NO FUNCIONA.
			
			Se modifico loadvmimage (PROXY de floppy) para que DEV_READ lo haga directamente al buffer 
			del proceso de la VMID que representa
			
			JAJAJA !!! EL INSTALL DE CMOS NO INSTALA!!!
			
			ATENCION, hay que copiar el /usr/src/drivers/cmos/cmos al /sbin/cmos y al /mnt/sbin/cmos
			donde en /mnt esta montado el disco de la VMx a arrancar
			
-------------------------------------------------------------------------------------------------------------------------
20140624:
			Se modifico CMOS para que sea promiscuo en el sentido de atender peticiones de multiples VMs
			Cada VM tiene su elemento de array de procesos suspendidos.
			Esto funciona como un servidor ASINCRONICO que le solicitan requerimientos pero no los responde de inmediato,
			sino a traves de un notify
			Cuando el readclock->FS->CMOS, el CMOS le dice al FS que suspenda a readclock mientras el hace la lectura del realtime clock
			una vez finalizada, le notifica al FS que ha terminado (ESTO NO ESTA FUNCIONANDO CORRECTAMENTE !!!)
			El FS hace una solicitud de STATUS para ver el resultado.
			
			HABIA UN ERROR EN lib/other/i386/rts/ipc.s en el registro de VMID de NOTIFYVM
			LISTO !! ahora funciona

FS->CMOS 
SENDREC: src=fs dst=35571 source=1 type=1029 m1i1=0 m1i2=35572 m1i3=-2147196158 m1p1=0 m1p2=0 m1p3=4F5C 
proc.c:446 vmid=0 nr=32 endp=35571 name=cmos flags=8 misc=2 getf=31438 sent=27342 recv_vm=-1
proc.c:462 vmid=0 nr=32 endp=35571 name=cmos flags=8 misc=2 getf=31438 sent=27342 recv_vm=-1
mh_receive name=fs src_ep=35571 flags=0 vmid=1

CMOS receive
hdebug: name=cmos vmid=0 nr=32 ep=35571 CMOS:  rqst_vmid:1

CMOS IOCTL for READCLOCK 
hdebug: name=cmos vmid=0 nr=32 ep=35571 CMOS: DEV_IOCTL IO_ENDPT:35572 <<< READCLOCK

CMOS->FS SUSPEND 
SENDVM: src=cmos dst=1 vmid=1 source=35571 type=68 m1i1=35572 m1i2=-998 m1i3=1129269599 m1p1=49204C54 m1p2=4E455F4F m1p3=545044 
mh_send1 name=cmos caller_p=32 vmid=0 PROMISCOUS_TASK 

CMOS gettime
hdebug: name=cmos vmid=0 nr=32 ep=35571 CMOS: DEV_IOCTL REQUEST:-2147196158

FS receive SUSPEND
hdebug: name=fs vmid=1 nr=1 ep=1 FS: get_work vmid:1
mh_receive name=fs src_ep=31438 flags=0 vmid=1

CMOS copy data to readclock
do_vcopyvm[1] endp=35572, offse=4F5C, vmid=1

CMOS notify FS
mh_notify name=cmos caller_p=32 vmid=0 PROMISCOUS_TASK 
hdebug: name=fs vmid=1 nr=1 ep=1 FS get_work who_e:35571
hdebug: name=fs vmid=1 nr=1 ep=1 FS get_work call_nr:4132

FS request STATUS to CMOS
SENDREC: src=fs dst=35571 source=1 type=1037 m1i1=0 m1i2=-2147196158 m1i3=0 m1p1=0 m1p2=3 m1p3=11000003
proc.c:446 vmid=0 nr=32 endp=35571 name=cmos flags=0 misc=0 getf=-2 sent=27342 recv_vm=-1
mh_send3 PROMICUOUS_TASK name=fs caller_p=1 vmid=1 dst=cmos dflags=0 dmisc=0

CMOS receive STATUS request from FS
mh_receive name=fs src_ep=35571 flags=4 vmid=1
mh_receive: src=fs dst=cmos misc=0 vmid=1 source=1 type=1037 m1i1=0 m1i2=-2147196158 m1i3=0 m1p1=0 m1p2=3 m1p3=11000003 
mh_receive:  caller=cmos ret_vmid=1
hdebug: name=cmos vmid=0 nr=32 ep=35571 CMOS:  rqst_vmid:1

CMOS replies to FS
SENDVM: src=cmos dst=1 vmid=1 source=35571 type=1282 m1i1=35572 m1i2=0 m1i3=1985967219 m1p1=64696D m1p2=0 m1p3=0 
mh_send1 name=cmos caller_p=32 vmid=0 PROMISCOUS_TASK 
hdebug: name=fs vmid=1 nr=1 ep=1 FS reply:0

-------------------------------------------------------------------------------------------------------------------------
20140626:	Se soluciono el problema del IS que presentaba solo los primeros procesos del kernel
			Se modifico el kernel/table.c porque se creo el archivo drivers.h donde esta la tabla de drivers promiscuos y virtuales
			
			Por ahora la tabla en driver.c requiere compilacion si se cambia drivers.h
			Se podria hacer que sys_getinfo() copie la tabla que tiene el kernel a un proceso de usuario, incluso el IS.

			Se modifico RANDOM pero es como que no le contesta a FS

FS->RANDOM
SENDREC: src=fs dst=35587 source=1 type=1030 m1i1=0 m1i2=35588 m1i3=578 m1p1=206E6570 m1p2=5F6F6877 m1p3=65 
proc.c:446 vmid=0 nr=48 endp=35587 name=random flags=8 misc=0 getf=31438 sent=27342 recv_vm=-1  << MISC = 0 !!!!!!!!!!!!!!
proc.c:476 vmid=0 nr=48 endp=35587 name=random flags=8 misc=0 getf=31438 sent=27342 recv_vm=-1
mh_receive name=fs src_ep=35587 flags=0 vmid=1

			NO FUNCIONABA PORQUE NO COPIO EL BINARIO CORRECTAMENTE!!!!
			
IMPORTANTE:	el /etc/rc arranca demonios del /sbin/xxxx
			el /usr/etc/rc arranca demonio del /usr/sbin/xxxx

-------------------------------------------------------------------------------------------------------------------------
20140626:
			Modifique el loadvmimg (proxy) para que haga un sys_getproc() del proceso peticionante para obtener sus 
			direcciones FISICAS (se tuvo que modificar SYSTASK do_getinfo() para que pueda aceptar ello)
			
			Ahora el fread() de la imagen de diskette se puede hacer directamente hacia el buffer de la VMx 
			porque se sabe la diferencia de direcciones entre el proxy y el proceso peticionante (generalmente el FS)
			
			Con la modificacion de CMOS  a promiscuo se soluciono el problema de la hora.

-------------------------------------------------------------------------------------------------------------------------
20140702:
			Se modifico la estructura de la VM para que contenga el campo de la direccion
			fisica de inicio de la VM y la direccion final.
			La direccion final es la direccion del stack de proxy.
			
			La direccion de inicio es heap_ptr del proxy.
			vmm_desc_t->imginfo_t vmm_img->addr /* virtual address of the image 		*/		
			vmm_desc_t->imginfo_t vmm_img->stk_addr	/* top address that PM of VM can use 	*/	
			vmm_desc_t->imginfo_t vmm_img->loadep /* laader endpoint			*/
			
			Se modifico do_vmmreq() -> do_vm_load
			vm_ptr->vm_start = umap_local(vmload_ep, D, (vir_bytes)vmm_ptr->vmm_img.addr, 1);			
			vm_ptr->vm_end   = umap_local(vmload_ep, D, (vir_bytes)vmm_ptr->vmm_img.stk_addr  , 1);
			MHDEBUG("SYSTEM: vm_start=%X vm_end=%d\n",vm_ptr->vm_start, vm_ptr->vm_end);

-------------------------------------------------------------------------------------------------------------------------
20140705: 	Se modifico SYSTASK para que controle los limites de vcopy
			se agregaron campos vm_start y vm_end que tiene las direcciones fisicas de inicio y fin de la VM

-------------------------------------------------------------------------------------------------------------------------
20140706: 	Se modifico proc.c para organizarlo 
			Se controla que el PROMISCUO el bitmap de VMs de los que es promiscuo (en privilegios) coincida
			se modifico proc.c para que los procesos promiscuos puedan enviar mensajes a las VMs 

			
-------------------------------------------------------------------------------------------------------------------------
20140710:	Se modifico el DS para que pueda contener las estructuras de la configuracion de VMs y procesos promiscuos/proxy
			Esto esta en minix/vmconfig.h
			Se modifico el VMM para que en el LOAD registre los valores de VMs en el DS. 
			Tambien se modifico el IS para que presente en pantalla estos valores
			Se supone que a futuro estos valores de VMs y PROCs seran leidos de un archivo de configuracion
			Se modifico SYSTEM vcopy para que controle el bitmap de VMID para PROMISCUOS de vcopy y el p_proxy de los PROXIES
			
			Se mofidifico proc.c para que controle en los VIRTUALES que el bitmap del PROXY ya no sea el p_nr sino el priv->s_id 
			ahora cuando un SEND le envie un mensaje al VIRTUAL, el bitmap del notify del proxy sera (1 << priv->s_id ) en lugar de (1 << p_nr)
-------------------------------------------------------------------------------------------------------------------------
20140711:	Se modifico kernel/system/do_getinfo GET_PRIVTAB donde si el caller es un proxy le retorna la tabla de privilegios de su VM representada.
			Se modifico loadvmimage.c para que el proxy_init cargue esa tabla de privilegios y convierta el nro de s_id->p_nr del proceso virtual
			que recibio mensaje en la VM.

-------------------------------------------------------------------------------------------------------------------------
20140712:	Se modifico proc.c porque seguian los problemas con AT_WINI y los mensajes

ERRORES MULTIPLES EN IS

DESACTIVAR ETHERNET Y TCPIP EN LAS OTRAS VMS	
Jul 13 15:15:08 192 kernel: Panic in pci: pci_init1: _pm_findproc failed for 'pci': -1
Jul 13 15:15:08 192 kernel: eth_set_rec_conf: sendrec to 35589 failed: -108	
do_init: unable to send to 35589: -105
		
FS->AT_WINIT
SENDREC: src=fs dst=35555 source=1 type=1033 m1i1=128 m1i2=1 m1i3=2 m1p1=13A000 m1p2=0 m1p3=2C74 
proc.c:456 vmid=0 nr=16 endp=35555 name=at_wini flags=8 misc=2 getf=31438 sent=27342 recv_vm=-1
proc.c:472 vmid=0 nr=16 endp=35555 name=at_wini flags=8 misc=2 getf=31438 sent=27342 recv_vm=-1
mh_receive caller_type=0 name=fs src_ep=35555 flags=0 vmid=1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 driver_task: rqst_vmid:1

AT_WINI wait for HARDWARE receive()
hdebug: name=at_wini vmid=0 nr=16 ep=35555 w_intr_wait from HARDWARE:1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 w_intr_wait receive m.m_type:4099

AT_WINI->FS
SENDVM: src=at_wini dst=1 vmid=1 source=35555 type=68 m1i1=1 m1i2=0 m1i3=2 m1p1=13A000 m1p2=0 m1p3=2C74 

AT_WINI recvvm()
hdebug: name=at_wini vmid=0 nr=16 ep=35555 driver_task: at_wini rqst_vmid:0

FS->AT_WINI		
SENDREC: src=fs dst=35555 source=1 type=1033 m1i1=128 m1i2=1 m1i3=1 m1p1=523000 m1p2=0 m1p3=2C74 
proc.c:456 vmid=0 nr=16 endp=35555 name=at_wini flags=8 misc=0 getf=31438 sent=27342 recv_vm=0
proc.c:486 vmid=0 nr=16 endp=35555 name=at_wini flags=8 >>>>misc=0<<< getf=31438 sent=27342 >>>>>recv_vm=0<<<<<
mh_receive caller_type=0 name=fs src_ep=35555 flags=0 vmid=1
hdebug: name=tty vmid=0 nr=5 ep=5 AT_WINI got unexpected message:55


rqst_vmid = VM0
receive(ANY, &msg) solo de la VM0.
Pero viene un send de la VM1! y lo acepta, por que?

-------------------------------------------------------------------------------------------------------------------------
20140715:	Se hicieron las pruebas de rendimiento en la PC intel de 2 CPUs
			Se instalo el disco IDE hitachi de 42 Gb y se hicieron 4 particiones
			Las 3 primeras para MHYPER (VM0, VM1 y VM2) la ultima para MINIX
			ATENCION: de los 42 Gb disponibles del disco solo se crearon particiones de 2 GB segun se ve.

# fdisk /dev/c0d0
Geometry of /dev/c0d0: 1024x255x63
                          ----first----  -----last----  --------sectors-------
Num Sorted Act  Type     Cyl Head Sec   Cyl Head Sec    Base    Last    Size
 1     1        MINIX        0   0   2    255 254   62       1+4112638 4112638
 2     2        MINIX      256   0   1    511 254   63 4112640 8225279 4112640
 3     3        MINIX      512   0   1    767 254   63 8225280 12337919 4112640
 4     4    A   MINIX      768   0   1   1023 254   63 12337920 16450559 4112640

 # df
Filesystem      Size (kB)       Free       Used    % Files%   Mounted on
/dev/c0d0p3s0       16384      12220       4164  26%     5%   /
/dev/c0d0p3s2     1643644    1527044     116600   8%     3%   /usr
/dev/c0d0p3s1      396288     392628       3660   1%     1%   /home
/dev/rescue           128         52         76  60%     7%   /boot/rescue
 
			Se creo el CD de instalacion con tools/release.sh -c -p
			ATENCION: Se coloco unidad de CD ROM IDE!! no reconoce bien el SATA
			Se tuvo que setear la memoria por BIOS a 1 Gb
			La PC INTEL posee 2 placas de red. La placa incorporada es RTL8139 que es reconocida por MINIX
			para ello cambiar el archivo /etc/inet.conf 
					eth0 rtl8139 0 { default; };
			Luego se procedio a instalar (seleccionando la particion correspondiente) en CADA UNA DE LAS PARTICIONES
			NO FUNCIONA SI SE HACE CON "DD"
			Una vez instalada en cada una de las particiones el sistema correspondiente, a partir
			de la particion primaria de MHYPER se copio a cada una de las otras particiones.
				dd if=/dev/c0d0p0s0 of=/dev/c0d0p1s0
				dd if=/dev/c0d0p0s1 of=/dev/c0d0p1s1
				dd if=/dev/c0d0p0s2 of=/dev/c0d0p1s2
			Luego, por las dudas se ejecuto fsck
				fsck 	/dev/c0d0p1s0
				fsck 	/dev/c0d0p1s1
				fsck 	/dev/c0d0p1s2

			Como se puede ver los MINOR number de los dispositivos de cada particion se diferencian en 4 (Cuatro)
			# ls -l /dev/c0d0p0s0 /dev/c0d0p1s0
brw------- 1 root  operator  3, 128 May  3  2006 /dev/c0d0p0s0
brw------- 1 root  operator  3, 132 May  3  2006 /dev/c0d0p1s0

			Es por eso que se cambio drivers/libdriver/driver.c
			if(!strcmp(rp->p_name, "at_wini")) {
				_mhdebug("driver_task: request from",m_ptr->m_source);
				if (m_ptr->DEVICE < NR_MINORS) {
					m_ptr->DEVICE += (DEV_PER_DRIVE * rqst_vmid);
				}else{
					m_ptr->DEVICE += (SUB_PER_DRIVE * rqst_vmid); <<<<  SI CADA VM VA A ESTAR EN UN DISCO DIFERENTE
				}												Eje: VM0 /dev/c0d0p0s0 y VM1 /dev/c0d1p0s0
			} 
			por
			if(!strcmp(rp->p_name, "at_wini")) {
				_mhdebug("driver_task: request from",m_ptr->m_source);
				if (m_ptr->DEVICE < NR_MINORS) {
					m_ptr->DEVICE += (DEV_PER_DRIVE * rqst_vmid);
				}else{
					m_ptr->DEVICE += (NR_PARTITIONS * rqst_vmid);  <<<<  SI CADA VM VA A ESTAR EN UNA PARTICION DIFERENTE
				}											Eje: VM0 /dev/c0d0p0s0 y VM1 /dev/c0d0p1s0
			} 
			
			donde include/ibm/partitions.h
			#define NR_PARTITIONS	4	/* number of entries in partition table */
		
			Los tests realizados en VM0 y MINIX se instalaron en /home
#!/bin/sh
cd /
mount /dev/c0d0p1s0 /VM1
mount /dev/c0d0p1s1 /VM1/home
mount /dev/c0d0p1s2 /VM1/usr
rm /VM1/usr/*.tar /VM1/usr/*.Z
time tar cvf /VM1/usr/mhyper.vm0.tar /VM1/usr/ > /dev/null  2> /home/tar.time 
time compress /VM1/usr/mhyper.vm0.tar > /dev/null 2> /home/compress.time
cd /usr/src
time make clean > /dev/null 2> /home/clean.time
time make world > /dev/null 2> /home/world.time 
cd /home
umount /dev/c0d0p1s2
umount /dev/c0d0p1s1
umount /dev/c0d0p1s0
		
			Los tests realizados sobre VM1 y VM2 se instalaron en 	/usr/etc/rc
rm /usr/*.tar /usr/*.Z
time tar cvf /usr/mhyper.vm1.tar /usr/ > /dev/null  2> /home/tar.time 
time compress /usr/mhyper.vm1.tar > /dev/null 2> /home/compress.time
ls -l /usr/*.tar /usr/*.Z > /home/ls.size 
cd /usr/src
time make clean > /dev/null 2> /home/clean.time
time make world > /dev/null 2> /home/world.time 
cd /usr/etc

PENDIENTES:
			+ Dio varios errores de at_wini 
			AT_WINI got unexpected message 1027 from 1 rqst_vmid=0
			Esto se evito cuando se ejecuto el LOAD y luego el START pero esperando un rato que se 
			detenga la actividad del disco.
			
			+ INIT, sigue con problemas
			+ IS con problemas

LO BUENO:	La ejecucion simultanea de VM1 y VM2 funciono perfectamente!!!

-------------------------------------------------------------------------------------------------------------------------
20140725:	Modifique PROC.C de tal modo que cada primitiva tenga su propia rutina separada
			En VM0 tanto el send, sendrec, receive y notify funcionan OK
			Hay problemas con la VM1
			
			El error esta en MH_send() porque no considera que cuando un PROMISCUO como AT_WINI hace 
			rqst_vmid = recvvm(ANY, &mess, src_vm);
			tengo que enviarle el vmid y eso no se esta haciendo
			
FS1:  SENDREC: src=fs dst=35555 source=1 type=1030 m1i1=128 m1i2=35559 m1i3=6 m1p1=206E6570 m1p2=5F6F6877 m1p3=65 
AT_WINI0: proc.c:431 vmid=0 nr=16 endp=35555 name=at_wini flags=8 misc=2 getf=31438 sent=27342 recv_vm=-1 
AT_WINI0: proc.c:462 vmid=0 nr=16 endp=35555 name=at_wini flags=8 misc=2 getf=31438 sent=27342 recv_vm=-1
FS1:  proc.c:514 vmid=1 nr=1 endp=1 name=fs flags=0 misc=1 getf=-2 sent=27342 recv_vm=1
AT_WINI0:  hdebug: name=at_wini vmid=0 nr=16 ep=35555 driver_task: at_wini rqst_vmid:0	<<<<<<<<<<<<<<<<<<<<<<		
			
-------------------------------------------------------------------------------------------------------------------------
20140726:
			Se corrigieron errores en MH_send()
			Se toco MH_notify()
			Se creo MH_recvas()

ERROR: 		En consola de VM0 dice	
			PM: signal 17 sent to zombie process 8 // el proceso 8 es INIT 
			PM panic (signal.c):				// PM muere por error de envio de signal

-------------------------------------------------------------------------------------------------------------------------
20140726:

ERROR:		Cuando se ejecuta random en VM1 (PROMISCUOUS) encuentra a grep en su lugar
do_exec: in vmid=1 proc=44
do_exec: in grep(VM0) exec:random 
			SOLUCION, ver la forma de reservar en todas las VMs el lugar para que no se usen esos slots
			por ejemplo con un flag RESERVED.
			Cada vez que se arranca una VM, se recorren todos los NR_SYS_PROCS que estan utilizados y se setean como reservados.
			Luego, cuando se arranca en la propia VM un proceso, segun este sea driver/server
			
ERROR:		Tratando de montar el floppy desde VM1 /usr/src/rc

do_exec: in vmid=1 proc=13
do_exec: in floppy(VM0) exec:floppy
do_exec: VIRTUAL floppy
do_exec.c:102 vmid=0 nr=13 endp=35552 name=floppy flags=8 misc=0 getf=31438 sent=27342 recv_vm=0
do_exec.c:103 vmid=1 nr=13 endp=35552 name=floppy flags=0 misc=2000 getf=31438 sent=27342 recv_vm=0
do_exec.c:105 s_proc_nr=62 s_id=23 s_flags=12 s_nr_irq=0 s_vmid=0 s_vm_bitmap=1 s_dr_bitmap=4000

El proxy hace receive()
hdebug: name=VM1 vmid=0 nr=62 ep=71140 do_proxy: receive from:31438

El FS le hace el pedido de DEV_OPEN
SENDREC: src=fs dst=35552 source=1 type=1030(DEV_OPEN) m1i1=0 m1i2=35608 m1i3=6 m1p1=206E6570 m1p2=5F6F6877 m1p3=65 

MH_send()
proc.c:440 vmid=1 nr=13 endp=35552 name=floppy flags=0 misc=2000 getf=31438 sent=27342 recv_vm=0
proc.c:502 vmid=1 nr=13 endp=35552 name=floppy flags=0 misc=2000 getf=31438 sent=27342 recv_vm=0
notify_proxy: proxy_ep=71140 proxy_nr=62 driver_id=14

El FS sale de la fase de SEND del SENDREC
proc.c:533 vmid=1 nr=1 endp=1 name=fs flags=4 misc=1 getf=-2 sent=35552 recv_vm=1

-------------------------------------------------------------------------------------------------------------------------
20140730:
			Se modifico driver.h para que tenga solo una tabla con los driver de BOOT y de EXEC.
			Tambien se agrego el nivel de planificacion USER_LEVEL, TASK_LEVEL, etc para que se pueda aplicar el planificador de VMs
			esos mismos bits son estampados en p_misc_flags.

-------------------------------------------------------------------------------------------------------------------------
20140731:			
			en do_vmmreq.c cuando se hace START si da ERROR hay que hacer un rollback en los procesos
			PROMISCUOS y en los PROXIES. Esto se hace en clear_VM0_procs()
			NO PROBADO!!
			

ATENCION CON LOS NOTIFY:
	Desde procesos de la VMx a procesos PROXY y PROMISCUOS
	* Cuando un proceso de la VMx le envia un notify al VIRTUAL, se encola igual que un SEND en el descriptor de VIRTUAL
		y hace un notify_proxy
	* Cuando un proceso de la VMx le envia un notify al PROMISCUO, se encola igual que un SEND en el descriptor de VM0	

-------------------------------------------------------------------------------------------------------------------------
20140801:	
		Se terminaron de implementar las 4 IPC para las modalidades.- 
		Quedan conectar (reemplazar mh_ por MH_)las que tiene C y probar las que tienen X
		
		REAL				PROMISCUO			PROXY	
		send				sendvm	(CX)		sendas
		receive             recvvm  (CX)        recvas
		sendrec             sendrecvm (CX)      sendrecas
		notify              ntfyvm (CX)       	ntfyas (X)

-------------------------------------------------------------------------------------------------------------------------
20140809:
		Se probo MH_sendvm, MH_ntfyvm y funcionan bien.
		PROBLEMAS CON MH_recvvm
		
MH_recvvm: src=fs dst=tty misc=0 vmid=1 source=1 type=1030 m1i1=15 m1i2=8 m1i3=258 m1p1=4CBF60 m1p2=A1BB m1p3=4CBF37 
proc.c:1157 vmid=1 nr=1 endp=1 name=fs flags=C misc=201 getf=5 sent=5 recv_vm=1

MH_recvvm: src=tty dst=31438 vmid=1 source=1 type=1030 m1i1=15 m1i2=8 m1i3=258 m1p1=4CBF60 m1p2=A1BB m1p3=4CBF37 

hdebug: name=tty vmid=0 nr=5 ep=5 TTY rqst_vmid:1
hdebug: name=tty vmid=0 nr=5 ep=5 TTY tty_mess.m_type:4099
prtmsg: proc=tty vmid=0 source=5 type=4099 m1i1=0 m1i2=0 m1i3=3 m1p1=10 m1p2=710 m1p3=0 
MH_recvvm: src=log dst=tty misc=0 vmid=1 source=4 type=101 m1i1=0 m1i2=0 m1i3=0 m1p1=10E54 m1p2=0 m1p3=0 
proc.c:1157 vmid=1 nr=4 endp=4 name=log flags=C misc=201 getf=5 sent=5 recv_vm=1

MH_recvvm: src=tty dst=31438 vmid=1 source=4 type=101 m1i1=0 m1i2=0 m1i3=0 m1p1=10E54 m1p2=0 m1p3=0 
hdebug: name=tty vmid=0 nr=5 ep=5 TTY rqst_vmid:1
hdebug: name=tty vmid=0 nr=5 ep=5 TTY tty_mess.m_type:4099
prtmsg: proc=tty vmid=0 source=5 type=4099 m1i1=15 m1i2=0 m1i3=3 m1p1=10 m1p2=711 m1p3=4CBF37 
hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: sys_umap:0
hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: dr_transfer:0		

-------------------------------------------------------------------------------------------------------------------------
20140810:
		Se modifico y probo MH_recvvm ahora funka OK!!

SEND: src=pm dst=8 source=0 type=11 m1i1=0 m1i2=0 m1i3=0 m1p1=0 m1p2=0 m1p3=0 
proc.c:504 vmid=1 nr=8 endp=8 name=init flags=8 misc=401 getf=0 sent=0 recv_vm=1
exception proc=8 name=init vmid=1 running_vm=1 vec_nr=13 | <<<< PROTECTION_VECTOR ejecuta general_protection()
raw_notify: src_p=-2 dst_p=0
hdebug: name=pm vmid=1 nr=0 ep=0 get_work vmid:1
proc.c:557 vmid=1 nr=0 endp=0 name=pm flags=0 misc=200 getf=4 sent=27342 recv_vm=1

SENDREC: src=pm dst=-2 source=0 type=1538 m1i1=8 m1i2=0 m1i3=0 m1p1=0 m1p2=19F14 m1p3=1131 
proc.c:504 vmid=1 nr=-2 endp=-2 name=system flags=8 misc=0 getf=31438 sent=0 recv_vm=0
proc.c:557 vmid=1 nr=0 endp=0 name=pm flags=0 misc=201 getf=1 sent=27342 recv_vm=1
SYSTEM: source=0 type=1538 m1i1=8 m1i2=0 m1i3=0 m1p1=0 m1p2=19F14 m1p3=1131 
clear_proc running_vm=1
do_exit.c:60 vmid=1 nr=8 endp=8 name=init flags=120 misc=401 getf=0 sent=0 recv_vm=1
clear_endpoint running_vm=1
system.c:739 vmid=1 nr=8 endp=8 name=init flags=120 misc=401 getf=0 sent=0 recv_vm=1
LOCKSEND src=system dst=0 source=-2 type=0 m1i1=8 m1i2=0 m1i3=0 m1p1=0 m1p2=19F14 m1p3=1131 
proc.c:1335 vmid=1 nr=0 endp=0 name=pm flags=8 misc=201 getf=-2 sent=27342 recv_vm=1
proc.c:557 vmid=1 nr=-2 endp=-2 name=system flags=0 misc=0 getf=31438 sent=0 recv_vm=0
		
hdebug: name=tty vmid=0 nr=5 ep=5 PM panic (signal.c): couldn't :61
	
PM panic (signal.c): couldn't get new stack pointer (for sig): 1

-------------------------------------------------------------------------------------------------------------------------
20140902:
	Se incorporo el parametro <tokens> a vmmcmd START <vmid> <tokens>
	Se modifico VMM y SYSTASK do_vmmcmd.c
	para marcar en p_misc_flags el tipo de proceso de cada VM
	KERNEL_LEVEL	
	TASK_LEVEL		
	SERVER_LEVEL	
	USER_LEVEL		
	Segun la tabla kernel/drivers.h
		
-------------------------------------------------------------------------------------------------------------------------
20140906:	
		hdebug ahora imprime en HEXADECIMAL 
		La excepcion imprime el valor del SP del proceso finalizado con error
		Se modifico init para tener un valor aproximado del stack

		
hdebug: name=init vmid=1 nr=8 ep=8 PARENT canary_ptr:0x4F90
exception proc=8 name=init vmid=1 running_vm=1 vec_nr=13 sp=4F00 General protection


-------------------------------------------------------------------------------------------------------------------------
20140919:	
		
ERROR:
	Todavia sigue el problema del mensaje mal enviado!

AT_WINI got unexpected message 1033 from 1 rqst_vmid=0

SENDREC: src=fs dst=35555 source=1 type=1033 m1i1=130 m1i2=1 m1i3=4 m1p1=1DDD000 m1p2=0 m1p3=2C74 
proc.c:456 vmid=0 nr=16 endp=35555 name=at_wini flags=8 misc=0 getf=31438 sent=27342 recv_vm=0
proc.c:504 vmid=0 nr=16 endp=35555 name=at_wini flags=8 misc=0 getf=31438 sent=27342 recv_vm=0
proc.c:557 vmid=1 nr=1 endp=1 name=fs flags=0 misc=201 getf=-2 sent=27342 recv_vm=1

hdebug: name=tty vmid=0 nr=5 ep=5 AT_WINI got unexpected message:0x37

Secuencia correcta
	FS(1)->AT_WINI(0)  recvvm()  		rqst_vmid=1
 	HARDWARE(0)->AT_WINI(0) receive()	rqst_vmid=1
	FS(0)->AT_WINI(0)  recvvm()			rqst_vmid=0
	
Secuencia erronea
	FS(1)->AT_WINI(0)  recvvm()			rqst_vmid=1
	FS(0)->AT_WINI(0)  receive()		rqst_vmid=1 
	
SOLUCION ??: Se modifico proc.c MH_receive()- Cuando el proceso hace un receive() es considerado como NO PROMISCUO y no se
controlaba el p_vmid de emisor y receptor. 

El error reportado "AT_WINI got unexpected message " esta en at_wini.c despues en receive!!
Se supone que estaba bloqueado y que otro proceso hace un SENDREC y lo despierta. 
Como no imprime los mensajes => rqst_vmid=0 => source=ANY
Como es entiende?? 
	1) se supone que estaba atendiendo una peticion del FS de la VM0 
	2) le llega otra peticion del FS de la VM0??
	
-------------------------------------------------------------------------------------------------------------------------
20140920:	
	INTENTE POR TODAS LAS FORMAS DE IMPRIMIR EL STACK DE INIT (kernel/exception.c)
	
PROBLEMA DE INIT: Estrategia de SOLUCION
	1) do_vmmcmd => instala todo para que init se ejecute pero no lo pone en cola de listos y marca como SENDING
	2) El PM hace patch_init donde solicita memoria como si fuese un proceso nuevo y habilita alli el nuevo mapa
	3) cuando hace sys_newmap se limpian los flags y se pone en cola de listos.

FUNCIONO EL INIT!!! 
	El problema era que el proceso VMM al estar como DISABLED no ejecutaba alloc_segments() 
	pero tambien hacie *rp = *rp0 con lo que el PM luego asignaba mal la memoria.
	

PROXIMA PRUEBA!!
	Eliminar patch_init y los cambios en newmap

TODO OK!!!

AHORA DE ERROR DE FS DESPUES DEL LOGIN:
FS, warning illegal call 1282 system call by 5
	
Tambien en las otras consolaas da error
getty: /dev/ttyc1: read error
	
-------------------------------------------------------------------------------------------------------------------------
20141004: TEST DE PLANIFICACION PARA CONAIISI

RECORDAR QUE HAY QUE CAMBIAR drivers/libdriver/driver.c
				if (m_ptr->DEVICE < NR_MINORS) {
					m_ptr->DEVICE += (DEV_PER_DRIVE * rqst_vmid);
				}else{
					m_ptr->DEVICE += (SUB_PER_DRIVE * rqst_vmid); <<<<< SUB_PER_DRIVE cambiar por NR_PARTITIONS
				}


En la maquina fisica funciona la placa de red RTLxxxx que es la de abajo (placa agregada)

Bootear con el CD de MINIX original
con fdisk /dev/c0d0 
cambiar la particion activa a la 4 (MINIX original)
Bootear con MINIX original
Este ya se conecta por ETHERNET

Montar todas las particiones en VM0, VM1 y VM2 y transferirle el TAR con los nuevos fuentes
# ls
VM0   VM2   bin    dev   home   mnt    sbin   usr
VM1   VM3   boot   etc   lib    root   tmp    var
# mount /dev/c0d0p0s2 /VM0
/dev/c0d0p0s0 is read-write mounted on /VM0
# mount /dev/c0d0p1s2 /VM1
/dev/c0d0p1s0 is read-write mounted on /VM1
# mount /dev/c0d0p2s2 /VM2
/dev/c0d0p2s0 is read-write mounted on /VM2

HACER LA COPIA DESDE FTP

# umount /dev/c0d0p0s2
/dev/c0d0p0s2 unmounted from /VM0
# umount /dev/c0d0p1s2
/dev/c0d0p1s2 unmounted from /VM1
# umount /dev/c0d0p2s2
/dev/c0d0p2s2 unmounted from /VM2

Se recompilo el kernel en VM0

C:\PAP\CONGRESOS\2014\CONAIISI - TOKEN BUCKET
Se copiaron los archivos rc que ejecuta el test "test" que van en los /usr/etc/rc de las VMs
se copiaron los archivos paraLeer.txt  

El se compilo /usr/src/test/metric.c que da las metricas que captura el clock.c
para saber la direccion fijarse en F10 al final

NO FUNCIONO, SE CUELGA AL EJECUTAR LOS TESTS

Se volvio al un kernel mas viejo, previo al cambio del planificador mhyper20140928.tar
NO FUNCIONO, SE CUELGA AL EJECUTAR LOS TESTS

Hacer una prueba con el kernel MAS VIEJO, el que funciono cuando se hicieron las pruebas 
de MHYPER. Ver en esta vitacora.

-------------------------------------------------------------------------------------------------------------------------
20141009: 
		Hice los test en la VM VMWARE con y sin MHDBG y funciona OK

		para hacer los test en maquina real modificar
		RECORDAR QUE HAY QUE CAMBIAR drivers/libdriver/driver.c
				if (m_ptr->DEVICE < NR_MINORS) {
					m_ptr->DEVICE += (DEV_PER_DRIVE * rqst_vmid);
				}else{
					m_ptr->DEVICE += (SUB_PER_DRIVE * rqst_vmid); <<<<< SUB_PER_DRIVE cambiar por NR_PARTITIONS
				}	

-------------------------------------------------------------------------------------------------------------------------
20141212:
	Ejecute MHVED como servicio y aparentemente arranca bien y queda esperando mensaje


-------------------------------------------------------------------------------------------------------------------------
20141229:
	Se esta tratando de resolver el problema del AT_WINI
	Para ello hay que modificar la primitiva recvvm()
	Se le incorpora la posibilidad de rechazar mensajes provenientes de un p_nr y aceptar el resto	
		vv = recvvm( (NOT_PROC | FS_PROC_NR) , &m, ANY_VM);  
	Esta primitiva retornara mensajes en &m provenientes de cualquier VM y de cualquier proceso con (p_nr != FS_PROC_NR)

	Aparentemente en proc.c no se necesita el campo de proc->p_send_vm y mucho menos setear en el emisor
	el flag VMID_PENDING
	
-------------------------------------------------------------------------------------------------------------------------
20141230:
	Se protegio el raw_notify() o se reemplazo el lock_notify() 

ERROR:
		El AT_WINI 
con			vv=receive(ANY, &m);  
o con 		vv = recvvm( ANY , &m, ANY_VM); 
		Funciona OK! 

Pero no funciona con:
			vv = recvvm( (NOT_PROC | VMM_PROC_NR) , &m, ANY_VM);   

function=10 source=5
function=1 source=4
function=10 source=5
function=1 source=4
RECVVM: src_dst_e=1031 
RECVVM: src_ep=1031 
RECVVM: SEARCHING NOT src_ep=7 
RECVVM: src_ep=7 p_misc_flags==6
MH_notify caller_nr=-3 dst=35555
function=10 source=5
function=1 source=4
function=10 source=5
function=1 source=4
function=10 source=5
function=1 source=4
function=3 source=1
function=3 source=1

-------------------------------------------------------------------------------------------------------------------------
20141231:
	Se modifico proc.c
	Se removio la posibilidad de especificar LOWER_TASKS
	
EL PROBLEMA ES QUE LOS endpoints < 0 prenden tienen seteado el bit NOT_PROC
Cuando el AT_WINI hace un SENDRECVM a la SYSTASK(-2) el bit NOT_PROC esta prendido.

AT_WINI-> sendrec(SYSTASK)
AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=77B m1p2=7 m1p3=11E3C 

SYSTASK-> send(AT_WINI)
LOCKSEND src=system dst=35555 source=-2 type=0 m1i1=98 m1i2=0 m1i3=1 m1p1=77B m1p2=7 m1p3=11E3C 

HARDWARE-> notify 
lock_notify source=-1

AT_WINI->receivevm(NOT_PROC) 
AT_WINI function=11 src_dst_e=1031 source=35555 type=73524 m1i1=9 m1i2=0 m1i3=0 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1031 
RECVVM: src_ep=1031 
MH_recvvm: proc.c:1183 vmid=0 nr=16 endp=35555 name=at_wini flags=0 misc=0 getf=-2<<<<<<<<< sent=27342 recv_vm=0
RECVVM: SEARCHING NOT src_ep=7 
RECVVM: src_ep=7 p_misc_flags==6
 
El  AT_WINI envia un SENDREC a SYSTASK-
SYSTASK responde a AT_WINI
AT_WINI recibe el mensaje de SYSTASK
Entre medio el HARDWARE avisa de una IRQ con un NOTIFY, la que se supone almacena el BIT correspondiente
AT_WINI ejecuta SENDREC VM. !!! AQUI DEBERIA DETECTAR EL BIT QUE LE DEJO HARDWARE 

-------------------------------------------------------------------------------------------------------------------------
20150101:
		Se logro hacer andar el (el problema estaba en MH_notify)
			vv = recvvm( (NOT_PROC | VMM_PROC_NR) , &m, ANY_VM);
			
		pero cuando se cambio por 
			vv = recvvm( (NOT_PROC | FS_PROC_NR) , &m, ANY_VM);	
		se cuelga
		
FS->AT_WINI sendrec(AT_WINI, &m)
	FS->AT_WINI function=3

vv = recvvm( ANY, &m, ANY_VM);   
	RECVVM: AT_WINI  src_ep=31438 src_vmid=-1
	MH_recvvm2: src=at_wini dst=31438 vmid=0 source=21103 type=6383478 m1i1=6383461 m1i2=1701079414 m1i3=111 m1p1=61636D m1p2=7461 m1p3=737562 

vv = recvvm( (NOT_PROC | FS_PROC_NR), &m, ANY_VM);   
	RECVVM: src_dst_e=1025 
	RECVVM: AT_WINI  src_ep=1025 src_vmid=-1
	RECVVM: src_ep=1025 
	proc.c:1310 vmid=0 nr=16 endp=35555 name=at_wini flags=8 misc=6 getf=1 sent=27342 recv_vm=-1
HARDWARE->AT_WINI
	MH_notify caller_nr=-1 dst=35555 flags=8

vv = recvvm( ANY, &m, ANY_VM);   
	RECVVM: AT_WINI  src_ep=31438 src_vmid=-1
FS->AT_WINI sendrec(AT_WINI, &m)
	FS->AT_WINI function=3

vv = recvvm( (NOT_PROC | FS_PROC_NR), &m, ANY_VM);   
	RECVVM: src_dst_e=1025 
	RECVVM: AT_WINI  src_ep=1025 src_vmid=-1
	RECVVM: src_ep=1025 
	proc.c:1310 vmid=0 nr=16 endp=35555 name=at_wini flags=8 misc=6 getf=1 sent=27342 recv_vm=-1
	
-------------------------------------------------------------------------------------------------------------------------
20150102:
	Se depuro proc.c y ahora funcionan bien todos los receives de AT_WINI excepto 
			vv = recvvm( (NOT_PROC | FS_PROC_NR), &m, ANY_VM); 	
	Algunos funcionan bien


CASO 1: FUNCIONA BIEN
=====================
AT_WINI->SYSTASK sendrec()
	AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=77A m1p2=7 m1p3=11E50 
HARDWARE->AT_WINI lock_notify()	
	lock_notify source=-1 <============== queda el bit seteado para NOTIFY
SYSTASK->AT_WINI lock_send()
	LOCKSEND src=system dst=35555 source=-2 type=0 m1i1=98 m1i2=0 m1i3=1 m1p1=77A m1p2=7 m1p3=11E50 
AT_WINI  recvvm( (NOT_PROC | FS_PROC_NR), &m, ANY_VM); 	
	AT_WINI function=11 src_dst_e=1025 source=35555 type=73564 m1i1=9 m1i2=0 m1i3=0 m1p1=0 m1p2=3B1 m1p3=0 
	RECVVM: src_dst_e=1025 
	RECVVM: src_ep=1025 
	NO SE BLOQUEA PORQUE SALE POR RECEIVE NOTIFY
	
CASO 2: Funciona bien
=====================	
AT_WINI->SYSTASK sendrec()
	AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=779 m1p2=7 m1p3=11E54 
SYSTASK->AT_WINI lock_send()
	LOCKSEND src=system dst=35555 source=-2 type=0 m1i1=98 m1i2=0 m1i3=1 m1p1=779 m1p2=7 m1p3=11E54
AT_WINI  recvvm( (NOT_PROC | FS_PROC_NR), &m, ANY_VM); 	
	AT_WINI function=11 src_dst_e=1025 source=35555 type=54632 m1i1=9 m1i2=0 m1i3=-2 m1p1=0 m1p2=3B1 m1p3=0 
	RECVVM: src_dst_e=1025 
	RECVVM: src_ep=1025 
	RECVVM: SEARCHING NOT src_ep=1 
	RECVVM: src_ep=1 p_misc_flags==6
	SE BLOQUEA
	
HARDWARE->AT_WINI lock_notify()	
	lock_notify source=-1
	MH_notify caller_nr=-1 dst=35555 flags=8
	DESBLOQUEA A AT_WINI
	
CASO 3: Identico a caso 2 SE CUELGA PERO SIEMPRE EN EL MISMO LUGAR
=========================
AT_WINI->SYSTASK sendrec()
	AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=778 m1p2=7 m1p3=11E54 
SYSTASK->AT_WINI lock_send()
	LOCKSEND src=system dst=35555 source=-2 type=0 m1i1=98 m1i2=0 m1i3=1 m1p1=778 m1p2=7 m1p3=11E54 
AT_WINI  recvvm( (NOT_PROC | FS_PROC_NR), &m, ANY_VM); 	
	AT_WINI function=11 src_dst_e=1025 source=35555 type=54632 m1i1=9 m1i2=0 m1i3=0 m1p1=0 m1p2=3B1 m1p3=0 
	RECVVM: src_dst_e=1025 
	RECVVM: src_ep=1025 
	RECVVM: SEARCHING NOT src_ep=1 
	RECVVM: src_ep=1 p_misc_flags==6	

COSA E MANDINGA!!!! AHORA PARECE QUE ANDA - PERO HACIENDO EQUILIBRIO

Luego probe arrancar una VM y finaliza con PANIC por el siguiente error.
	isokendpt3: proc_ptr(at_wini,18,1,0) src_dst(pm,0,1,1). running_vm=1 <<<<<<<<<<

-------------------------------------------------------------------------------------------------------------------------
20150103:
		Hice algo de orden en el codigo
	
		El error se sigue produciendo, este ocurrio despues de arrancar y hacer SYNC
		
AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=AD m1p2=7 m1p3=11E54 
LOCKSEND src=system dst=35555 source=-2 type=0 m1i1=98 m1i2=0 m1i3=1 m1p1=AD m1p2=7 m1p3=11E54 
AT_WINI function=11 src_dst_e=1025 source=35555 type=54632 m1i1=9 m1i2=0 m1i3=0 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 
RECVVM: SEARCHING NOT src_ep=1 
RECVVM: src_ep=1 p_misc_flags==6
****************** NO APARECE LA INTERRUPCION ******************

1) VOLVER A PROBAR CON RECEIVE SOLO Y CON NOT_PROC VMM_PROC_NR
2) PROBAR ARRANCAR UNA VM

Al arrancar un VM da el siguiente error
AT_WINI->FS1 sendvm 
AT_WINI function=10 src_dst_e=1 source=35555 type=68 m1i1=4096 m1i2=-22 m1i3=4096 m1p1=2FE3B000 m1p2=0 m1p3=32A9F8 
Da error de permisos porque el p_vmid de AT_WINI es 1 !!!!!!!!!!!!!!!!
SENDVM/RECVVM/NOTIFYVM: call_nr=10 function=10 result=-1  >>>>>>>vmid=0<<< priv=3 >>>>>>> caller_vmid=1 <<< running_vm=1

AT_WINI function=3 src_dst_e=-2 source=35555 type=1557 m1i1=98 m1i2=4194 m1i3=0 m1p1=1062 m1p2=11F5C m1p3=28D1 
LOCKSEND src=system dst=35555 source=-2 type=0 m1i1=98 m1i2=4194 m1i3=0 m1p1=1062 m1p2=4 m1p3=28D1 
AT_WINI function=5 src_dst_e=0 source=35555 type=2002744417 m1i1=979988073 m1i2=1601135648 m1i3=543255908 m1p1=646F6372 m1p2=65 m1p3=0 
AT_WINI function=5 src_dst_e=1 source=35555 type=2002744417 m1i1=979988073 m1i2=1952805408 m1i3=544109173 m1p1=4B4F m1p2=0 m1p3=0 
AT_WINI function=10 src_dst_e=1 source=35555 type=68 m1i1=1 m1i2=4096 m1i3=4096 m1p1=3000 m1p2=0 m1p3=8453C 
SENDVM: src=at_wini dst=1 >>> vmid=1 <<<< source=35555 type=68 m1i1=1 m1i2=4096 m1i3=4096 m1p1=3000 m1p2=0 m1p3=8453C

-------------------------------------------------------------------------------------------------------------------------
20150105:
		El orden que hice antes de ayer provoco mas CAOS!!!

Ahora saltan errores
AT_WINI->SYSTASK sendrec()		
AT_WINI function=3 src_dst_e=-2 source=35555 type=1555 SYS_IRQCTL  m1i1=3 m1i2=0 m1i3=6644 m1p1=11F08 m1p2=1406 m1p3=5 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 SYS_VDEVIO  m1i1=98 m1i2=0 m1i3=1 m1p1=77C m1p2=7 m1p3=11E3C 

SYSTASK->AT_WINI lock_send()
get_proc_addr: ERROR proc_nr=35555  proc_ptr->p_name=system running_vm=0
LOCKSEND src=system dst=35555 

-------------------------------------------------------------------------------------------------------------------------
20150107:
		Como se puede ver, ante 2 pedidos, 1 falla (SYS_IRQCTL) y el otro no (SYS_UMAP).
		Los valores de who_e y who_p son correctos.
	
AT_WINI function=3 src_dst_e=-2 source=35555 type=1555 SYS_IRQCTL  m1i1=3 m1i2=0 m1i3=6644 m1p1=11F08 m1p2=1406 m1p3=5 
SYSTEM: who_e=35555 who_p=16
LOCKSEND src=system dst=35555 
get_proc_addr: ERROR proc_nr=35555  proc_ptr->p_name=at_wini running_vm=0

AT_WINI function=3 src_dst_e=-2 source=35555 type=1550 m1i1=1 m1i2=35534 m1i3=0 m1p1=C968 m1p2=1F7 m1p3=800 
SYSTEM: who_e=35555 who_p=16
LOCKSEND src=system dst=35555

Modificado entonces para ver en donde falla.
 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1555 m1i1=3 m1i2=0 m1i3=6644 m1p1=11F08 m1p2=1406 m1p3=5 
SYSTEM: who_e=35555 who_p=16
DO_IRQCTL IRQ_REQUEST=3 <<< IRQ_ENABLE
source=35555 type=1555 m5c1= m5c2=  m5i1=0 m5i2=6644 m5l1=73480 m5l2=5126 m5l3=5
get_proc_addr: ERROR proc_nr=35555  proc_ptr->p_name=system running_vm=0
LOCKSEND src=system dst=35555 
 
EL PROBLEMA ESTA EN GENERIC_HANDLER!!!

AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=776 m1p2=7 m1p3=11E3C 
SYSTEM: who_e=35555 who_p=16
GH
GH16
PRIV
get_proc_addr: ERROR proc_nr=35555  proc_ptr->p_name=system running_vm=0
RAW

raw_notify(HARDWARE, proc); <<< es proc, NO ES hook->proc_nr_e!!!!!!

-------------------------------------------------------------------------------------------------------------------------
20150109:
		
	1)	vv=receive(ANY, &m);  								====> OK
	2)	vv = recvvm( ANY , &m, ANY_VM);   					====> OK
	3)	vv = recvvm( (NOT_PROC | VMM_PROC_NR), &m, ANY_VM); ====> OK 
	4)	vv = recvvm( (NOT_PROC | FS_PROC_NR), &m, ANY_VM);  ====> MAL!!
	
AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=77C m1p2=7 m1p3=11E3C 
raw_notify: src_p=-1 dst_p=16 running_vm=0
LOCKSEND src=system dst=35555 
AT_WINI function=11 src_dst_e=1025 source=35555 type=73524 m1i1=9 m1i2=0 m1i3=0 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 

AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=163 m1p2=7 m1p3=11DB0 
raw_notify: src_p=-1 dst_p=16 running_vm=0
LOCKSEND src=system dst=35555 
AT_WINI function=11 src_dst_e=1025 source=35555 type=73388 m1i1=9 m1i2=0 m1i3=73228 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 

AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=77C m1p2=7 m1p3=11D24 
raw_notify: src_p=-1 dst_p=16 running_vm=0
LOCKSEND src=system dst=35555 
AT_WINI function=11 src_dst_e=1025 source=35555 type=73248 m1i1=9 m1i2=0 m1i3=73088 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 

AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=778 m1p2=7 m1p3=11E50 
raw_notify: src_p=-1 dst_p=16 running_vm=0
LOCKSEND src=system dst=35555
AT_WINI function=11 src_dst_e=1025 source=35555 type=73564 m1i1=9 m1i2=0 m1i3=1769239137 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 

AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=77B m1p2=7 m1p3=11E50 
raw_notify: src_p=-1 dst_p=16 running_vm=0
LOCKSEND src=system dst=35555 
AT_WINI function=11 src_dst_e=1025 source=35555 type=73564 m1i1=9 m1i2=0 m1i3=0 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 

AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=77B m1p2=7 m1p3=11E50 
raw_notify: src_p=-1 dst_p=16 running_vm=0
LOCKSEND src=system dst=35555 
AT_WINI function=11 src_dst_e=1025 source=35555 type=73564 m1i1=9 m1i2=0 m1i3=0 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 

AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=77C m1p2=7 m1p3=11E50 
LOCKSENraw_notify: src_p=-1 dst_p=16 running_vm=0
D src=system dst=35555 
AT_WINI function=11 src_dst_e=1025 source=35555 type=73564 m1i1=9 m1i2=0 m1i3=0 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 


AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=77A m1p2=7 m1p3=11E54 
LOCKSENDraw_notify: src_p=-1 dst_p=16 running_vm=0
 src=system dst=35555 
AT_WINI function=11 src_dst_e=1025 source=35555 type=54632 m1i1=9 m1i2=0 m1i3=-2 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 

AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=77A m1p2=7 m1p3=11E50 
LOCKSENraw_notify: src_p=-1 dst_p=16 running_vm=0
D src=system dst=35555 
AT_WINI function=11 src_dst_e=1025 source=35555 type=73564 m1i1=9 m1i2=0 m1i3=73372 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 

AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=77C m1p2=7 m1p3=11E50 
raw_notify: src_p=-1 dst_p=16 running_vm=0
LOCKSEND src=system dst=35555 
AT_WINI function=11 src_dst_e=1025 source=35555 type=73564 m1i1=9 m1i2=0 m1i3=0 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 

AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=77B m1p2=7 m1p3=11E50 
raw_notify: src_p=-1 dst_p=16 running_vm=0
LOCKSEND src=system dst=35555 
AT_WINI function=11 src_dst_e=1025 source=35555 type=73564 m1i1=9 m1i2=0 m1i3=0 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 

AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=77B m1p2=7 m1p3=11E50 
LOCKSENraw_notify: src_p=-1 dst_p=16 running_vm=0
D src=system dst=35555 
AT_WINI function=11 src_dst_e=1025 source=35555 type=73564 m1i1=9 m1i2=0 m1i3=0 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 

AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=77C m1p2=7 m1p3=11E54 
LOCKSENraw_notify: src_p=-1 dst_p=16 running_vm=0
D src=system dst=35555 
AT_WINI function=11 src_dst_e=1025 source=35555 type=54632 m1i1=9 m1i2=0 m1i3=-2 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 

AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=77C m1p2=7 m1p3=11E54 
LOCKSEND raw_notify: src_p=-1 dst_p=16 running_vm=0
src=system dst=35555 
AT_WINI function=11 src_dst_e=1025 source=35555 type=54632 m1i1=9 m1i2=0 m1i3=0 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 

AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=774 m1p2=7 m1p3=11E54 
LOCKSEND src=system dst=35555 
AT_WINI function=11 src_dst_e=1025 source=35555 type=54632 m1i1=9 m1i2=0 m1i3=0 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 
RECVVM: SEARCHING NOT src_ep=1 
RECVVM: src_ep=1 p_misc_flags==6
raw_notify: src_p=-1 dst_p=16 running_vm=0
MH_notify caller_nr=-1 dst=35555 flags=8

AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=77C m1p2=7 m1p3=11E54 
LOCKSENraw_notify: src_p=-1 dst_p=16 running_vm=0
D src=system dst=35555 
AT_WINI function=11 src_dst_e=1025 source=35555 type=54632 m1i1=9 m1i2=0 m1i3=0 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 

AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=77B m1p2=7 m1p3=11E50 
raw_notify: src_p=-1 dst_p=16 running_vm=0
LOCKSEND src=system dst=35555 
AT_WINI function=11 src_dst_e=1025 source=35555 type=73564 m1i1=9 m1i2=0 m1i3=73372 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 

AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=77B m1p2=7 m1p3=11E50 
LOCKSEND src=system dst=35555 
AT_WINI function=11 src_dst_e=1025 source=35555 type=73564 m1i1=9 m1i2=0 m1i3=0 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 
RECVVM: SEARCHING NOT src_ep=1 
RECVVM: src_ep=1 p_misc_flags==6

El problema se esta dando con el raw_notify.
Cuando el HARDWARE quiere notificar una INTERRUPCION de DISCO y el bit ya se encuentra seteado!!

HARDWARE->AT_WINI raw_notify()
raw_notify: src_p=-1 dst_p=16 running_vm=0

AT_WINI is RUNNING 
WARNING proc.c:881 vmid=0 nr=16 endp=35555 name=at_wini flags=0 misc=0 getf=27342 sent=27342 recv_vm=0

El MAP=0x0010 => BINARIO 0001 0000 es decir esta prendido el bit 4 (arranca de bit cero a la derecha) 
WARNING src_id=4 map=10 proc.c:885 s_proc_nr=16 s_id=15 s_flags=12 s_nr_irq=0 s_vmid=0 s_vm_bitmap=1 s_dr_bitmap=0
AT_WINI function=11 src_dst_e=1025 source=35555 type=73524 m1i1=9 m1i2=0 m1i3=0 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 

!!!!!!!!!!!!!!!!!!!!!!POR LO TANTO ESA 2DA IRQ SE PIERDE !!!!!!!!!!!!!!!!!!111

-------------------------------------------------------------------------------------------------------------------------
20150110:
		Se cambio generic_handler donde decia 
		  raw_notify(HARDWARE, proc); 
		se cambio x
		  lock_notify(HARDWARE, hook->proc_nr_e);
	  
		  
Aqui el AT_WINI le pide a SYSTASK un sys_setpolicy()
AT_WINI function=3 src_dst_e=-2 source=35555 type=1555 m1i1=917505 m1i2=1 m1i3=6644 m1p1=11F08 m1p2=1406 m1p3=E 
do_irqctl: IRQ proc 35555, IRQ 14
do_irqctl.c:70 vmid=0 nr=16 endp=35555 name=at_wini flags=8 misc=1 getf=-2 sent=27342 recv_vm=0
source=35555 type=1555 m5c1= m5c2= m5i1=1 m5i2=6644 m5l1=73480 m5l2=5126 m5l3=14
irq=14 id=1 proc_nr_e=35555 notify_id=14 policy_t=1(IRQ_REENABLE) vmid=0
LOCKSEND src=system dst=35555 

La secuencia de una IRQ es:
	hwintXX -> intr_handle() -> generic_handler()
	
En intr_handle() si despues de ejecutar intr_handle(), 
	(irq_actids[hook->irq] != 0) => se deshabilita la IRQ

Con el policy_t en 0x0001 implica que cuando termina el generic handler hace
  return(hook->policy & IRQ_REENABLE);
por lo tanto 
	generic_handler() retorna != 0;
esto provoca que 
	irq_actids[hook->irq] == 0
!!!! Por lo tanto hwintXX deja habilitada la IRQ!!!! 
Esto provoca que se puedan perder interrupciones.

AQUI se muestra que un lock_notify()->raw_notify va a setear un bit que el mismo ya esta seteado		  
AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=77C m1p2=7 m1p3=11E3C 
raw_notify: src_p=-1 dst_p=16 running_vm=0
WARNING proc.c:881 vmid=0 nr=16 endp=35555 name=at_wini flags=8 misc=1 getf=-2 sent=27342 recv_vm=0
WARNING src_id=4 nr=-1 map=10 int=4000  <<< ya esta seteado un mensaje desde HARDWARE  (src_id 4)
	porque el map esta en hexadecimal muestra el 4to bit prendido (arranca en bit0)
	y el bitmap de interrupciones tiene prendido el bit 14.
	proc.c:887 s_proc_nr=16 s_id=15 s_flags=12 s_nr_irq=0 s_vmid=0 s_vm_bitmap=1 s_dr_bitmap=0
LOCKSEND src=system dst=35555 

LA PREGUNTA ES:
	PORQUE SE PIERDEN INTERRUPCIONES ??
	NO SERA PORQUE ALGUNA PRIMITIVA DE RECEPCION NO ANALIZA CORRECTAMENTE PARA VER SI HAY NOTIFY ??
	
Al arrancar la VM1
AT_WINI function=10 src_dst_e=1 source=35555 type=68 m1i1=4096 m1i2=-22 m1i3=4096 m1p1=2FE3B000 m1p2=0 m1p3=316868 
SENDVM/RECVVM/NOTIFYVM: call_nr=10 function=10 result=-1 vmid=0 priv=3 caller_vmid=1 running_vm=1

Es como si AT_WINI estuviese ejecutando en VM1 !!!

-------------------------------------------------------------------------------------------------------------------------
20150111:

PRUEBA 1: AT_WINI con  2)	vv = recvvm( ANY , &m, ANY_VM);   

SENDREC: src=fs dst=35555 source=1 type=1027 (DEV_READ) m1i1=128 m1i2=1 m1i3=4096 m1p1=3000 m1p2=0 m1p3=8453C 
proc.c:507 vmid=0 nr=16 endp=35555 name=at_wini flags=0 misc=0 getf=27342 sent=27342 recv_vm=0
WARNING proc.c:603 vmid=0 nr=16 endp=35555 name=at_wini flags=0 misc=0 getf=27342 sent=27342 recv_vm=0
proc.c:655 vmid=1 nr=1 endp=1 name=fs flags=4 misc=201 getf=27342 sent=35555 recv_vm=1

AT_WINI function=11 src_dst_e=31438 source=35555 type=68 m1i1=1 m1i2=4096 m1i3=4096 m1p1=A000 m1p2=0 m1p3=83528 
AT_WINI function=11 src_dst_e=31438 source=35555 type=4099 m1i1=128 m1i2=0 m1i3=3 m1p1=4000 m1p2=1E86 m1p3=83528 
MH_recvvm: src=fs dst=at_wini misc=0 vmid=1 source=1 type=1027 m1i1=128 m1i2=1 m1i3=4096 m1p1=3000 m1p2=0 m1p3=8453C 
proc.c:1375 vmid=1 nr=1 endp=1 name=fs flags=8 misc=201 getf=35555 sent=35555 recv_vm=1
MH_recvvm: src=at_wini dst=31438 vmid=1 source=1 type=1027 m1i1=128 m1i2=1 m1i3=4096 m1p1=3000 m1p2=0 m1p3=8453C 



AT_WINI function=3 src_dst_e=-2 source=35555 type=1570 m1i1=65537 m1i2=1 m1i3=1685217135 m1p1=8453C m1p2=5F737973 m1p3=1000 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1570 m1i1=65537 m1i2=1 m1i3=73312 m1p1=8453C m1p2=FFFFFFFE m1p3=1000 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1557 m1i1=98 m1i2=11953468 m1i3=1 m1p1=1060 m1p2=0 m1p3=20E9 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1557 m1i1=98 m1i2=11953468 m1i3=0 m1p1=1062 m1p2=0 m1p3=20E9 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1557 m1i1=108 m1i2=11953468 m1i3=1 m1p1=1064 m1p2=765758 m1p3=20E9 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1557 m1i1=98 m1i2=11953468 m1i3=1 m1p1=1062 m1p2=6 m1p3=20E9 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1557 m1i1=98 m1i2=11953468 m1i3=1 m1p1=1060 m1p2=9 m1p3=20E9 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1561 m1i1=27342 m1i2=21808 m1i3=542012 m1p1=11E20 m1p2=4C07 m1p3=11F04 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1557 m1i1=98 m1i2=0 m1i3=0 m1p1=1F7 m1p2=8453C m1p3=11E20 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1557 m1i1=98 m1i2=503 m1i3=1 m1p1=1F6 m1p2=F0 m1p3=1000 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1561 m1i1=27342 m1i2=-2 m1i3=1557 m1p1=11E0C m1p2=FFFFFFFE m1p3=0 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1557 m1i1=98 m1i2=0 m1i3=0 m1p1=1F7 m1p2=615 m1p3=11E0C 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1560 m1i1=503 m1i2=0 m1i3=98 m1p1=780 m1p2=1000 m1p3=1E8B 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=777 m1p2=7 m1p3=11E50 
LOCKSEND src=system dst=35555 
raw_notify: src_p=-1 dst_p=16 running_vm=0 <<<<<<<<<<<<<<<<<<<<<<
raw_notify: src_p=-1 dst_p=16 running_vm=0 <<<<<<<<<<<<<<<<<<<<<<
WARNING proc.c:881 vmid=0 nr=16 endp=35555 name=at_wini flags=0 misc=0 getf=27342 sent=27342 recv_vm=0
WARNING src_id=4 nr=-1 map=10 int=4000 proc.c:887 s_proc_nr=16 s_id=15 s_flags=12 s_nr_irq=0 s_vmid=0 s_vm_bitmap=3 s_dr_bitmap=0
AT_WINI function=11 src_dst_e=31438 source=35555 type=22475 m1i1=73367 m1i2=1 m1i3=0 m1p1=61000000 m1p2=69775F74 m1p3=203A696E 
	
PRUEBA 2: AT_WINI con  1)	vv = receive( ANY , &m);   
function=3 source=1 source=1 type=1027 m1i1=128 m1i2=1 m1i3=4096 m1p1=3000 m1p2=0 m1p3=8453C 
SENDREC: src=fs dst=35555 source=1 type=1027 m1i1=128 m1i2=1 m1i3=4096 m1p1=3000 m1p2=0 m1p3=8453C 
proc.c:507 vmid=0 nr=16 endp=35555 name=at_wini flags=0 misc=0 getf=27342 sent=27342 recv_vm=0
WARNING proc.c:603 vmid=0 nr=16 endp=35555 name=at_wini flags=0 misc=0 getf=27342 sent=27342 recv_vm=0
proc.c:655 vmid=1 nr=1 endp=1 name=fs flags=4 misc=201 getf=27342 sent=35555 recv_vm=1
AT_WINI function=11 src_dst_e=31438 source=35555 type=68 m1i1=1 m1i2=4096 m1i3=4096 m1p1=A000 m1p2=0 m1p3=83528 
MH_recvvm: src=fs dst=at_wini misc=0 vmid=1 source=1 type=1027 m1i1=128 m1i2=1 m1i3=4096 m1p1=3000 m1p2=0 m1p3=8453C 
proc.c:1375 vmid=1 nr=1 endp=1 name=fs flags=8 misc=201 getf=35555 sent=35555 recv_vm=1
MH_recvvm: src=at_wini dst=31438 vmid=1 source=1 type=1027 m1i1=128 m1i2=1 m1i3=4096 m1p1=3000 m1p2=0 m1p3=8453C 
AT_WINI function=5 src_dst_e=1 source=35555 type=1986622052 m1i1=1952412261 m1i2=980120417 m1i3=1601462560 m1p1=696E6977 m1p2=73717220 m1p3=6D765F74 
AT_WINI function=6 src_dst_e=1 source=35555 type=1027 m1i1=128 m1i2=1 m1i3=4096 m1p1=3000 m1p2=0 m1p3=8453C 
AT_WINI function=5 src_dst_e=1 source=35555 type=1986622052 m1i1=1952412261 m1i2=980120417 m1i3=1902473760 m1p1=74736575 m1p2=6F726620 m1p3=6D 
AT_WINI function=5 src_dst_e=1 source=35555 type=1918857060 m1i1=980711268 m1i2=1937339168 m1i3=1634563423 m1p1=6D7670 m1p2=0 m1p3=0 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1570 m1i1=65537 m1i2=1 m1i3=1685217135 m1p1=8453C m1p2=5F737973 m1p3=1000 
LOCKSEND src=system dst=35555 
AT_WINI function=5 src_dst_e=144 source=35555 type=2002744417 m1i1=979988073 m1i2=1885304608 m1i3=1634755954 m1p1=64206572 m1p2=63697665 m1p3=65 
AT_WINI function=5 src_dst_e=12288 source=35555 type=2002744417 m1i1=979988073 m1i2=1701331744 m1i3=1679846243 m1p1=206B7369 m1p2=72646461 m1p3=737365 
AT_WINI function=5 src_dst_e=4096 source=35555 type=2002744417 m1i1=979988073 m1i2=1952413472 m1i3=1936613746 m1p1=20726566 m1p2=7479626E m1p3=7365 
AT_WINI function=5 src_dst_e=16777216 source=35555 type=2002744417 m1i1=979988073 m1i2=1952413472 m1i3=1936613746 m1p1=20726566 m1p2=735F7664 m1p3=657A69 
AT_WINI function=5 src_dst_e=21 source=35555 type=2002744417 m1i1=979988073 m1i2=1768256032 m1i3=1769236846 m1p1=7A696C61 m1p2=6F697461 m1p3=6E 
AT_WINI function=5 src_dst_e=1 source=35555 type=2002744417 m1i1=979988073 m1i2=1952413472 m1i3=1936613746 m1p1=20726566 m1p2=645F6F64 m1p3=616D 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1570 m1i1=65537 m1i2=1 m1i3=73312 m1p1=8453C m1p2=FFFFFFFE m1p3=1000 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1557 m1i1=98 m1i2=11961660 m1i3=1 m1p1=1060 m1p2=0 m1p3=20E9 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1557 m1i1=98 m1i2=11961660 m1i3=0 m1p1=1062 m1p2=0 m1p3=20E9 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1557 m1i1=108 m1i2=11961660 m1i3=1 m1p1=1064 m1p2=765758 m1p3=20E9 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1557 m1i1=98 m1i2=11961660 m1i3=1 m1p1=1062 m1p2=6 m1p3=20E9 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1557 m1i1=98 m1i2=11961660 m1i3=1 m1p1=1060 m1p2=9 m1p3=20E9 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1561 m1i1=27342 m1i2=21808 m1i3=542012 m1p1=11E20 m1p2=4C07 m1p3=11F04 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1557 m1i1=98 m1i2=0 m1i3=0 m1p1=1F7 m1p2=8453C m1p3=11E20 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1557 m1i1=98 m1i2=503 m1i3=1 m1p1=1F6 m1p2=F0 m1p3=1000 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1561 m1i1=27342 m1i2=-2 m1i3=1557 m1p1=11E0C m1p2=FFFFFFFE m1p3=0 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1557 m1i1=98 m1i2=0 m1i3=0 m1p1=1F7 m1p2=615 m1p3=11E0C 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1560 m1i1=503 m1i2=0 m1i3=98 m1p1=780 m1p2=1000 m1p3=1439 
LOCKSEND src=system dst=35555 
AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=777 m1p2=7 m1p3=11E50 
LOCKSEND src=system dst=35555 
raw_notify: src_p=-1 dst_p=16 running_vm=0 <<<<<<<<<<<<<<<<<<<<<<
raw_notify: src_p=-1 dst_p=16 running_vm=0 <<<<<<<<<<<<<<<<<<<<<<
WARNING proc.c:881 vmid=0 nr=16 endp=35555 name=at_wini flags=0 misc=0 getf=27342 sent=27342 recv_vm=0
WARNING src_id=4 nr=-1 map=10 int=4000 proc.c:887 s_proc_nr=16 s_id=15 s_flags=12 s_nr_irq=0 s_vmid=0 s_vm_bitmap=3 s_dr_bitmap=0
AT_WINI function=5 src_dst_e=1 source=35555 type=2002744417 m1i1=979988073 m1i2=1601135648 m1i3=6384996 m1p1=0 m1p2=0 m1p3=0 
AT_WINI function=2 src_dst_e=31438 source=35555 type=22475 m1i1=73367 m1i2=1 m1i3=0 m1p1=61000000 m1p2=69775F74 m1p3=203A696E 	

!!!!!!!!!!! ATENCION: AT_WINI con  vv = receive( ANY , &m) y proc.c sin DEBUG ==============>> JOYA !!! excepto los problemas de disco conocidos
!!!!!!!!!!! ATENCION: AT_WINI con  vv = recvvm( ANY , &m, ANY_VM) y proc.c sin DEBUG ==============>> JOYA !!! excepto los problemas de disco conocidos

 
-------------------------------------------------------------------------------------------------------------------------
20140113:
	Se modifico proc.c
	Se elimino SENDRECAS
	sE modifico loadvmimg.c
	Se modifico main.c de VMM
	sE MODIFICO proc.c

-------------------------------------------------------------------------------------------------------------------------
20150115:
		PROBLEMAS EN PICK_PROC NUEVO!!!!
		
-------------------------------------------------------------------------------------------------------------------------
20150117:
		Modifique el planificador

		PROC.C: reemplace varios CopyMess() por CopyMess_ep()
		
		CLOCK.C se hace lock_notify
		#ifdef MHYPERxxxxx
		raw_notify(HARDWARE, CLOCK);		/* send notification */
#else /*  MHYPER */
		lock_notify(HARDWARE, CLOCK);		/* send notification */
#endif /*  MHYPER */
		
		ATENTI: Proteger switch_VM	
			En teoria no necesita proteccion. Ademas no produce daño.
					

		Se camobio do_vmmcmd.c y do_exec.c 
			Segun lo que dice kernel/drivers.h hay que enviar o NO un NOTIFY a los promiscuos
			por si necesitan hacer alguna inicializacion para la nueva VM que tienen q antender 
			como es el caso de TTY

		Modifique AT_WINI  como prueba de la notificacion en EXEC_NTFY 
	
-------------------------------------------------------------------------------------------------------------------------
20150118:
			
		Se implemento RELAY 
			
			
ERROR:

SYSTASK1->FS1 lock_send()
LOCKSEND src=system dst=1 
proc.c:640 vmid=1 nr=1 endp=1 name=fs flags=0 misc=200 getf=27342 sent=0 recv_vm=-1
proc.c:699 vmid=1 nr=-2 endp=-2 name=system flags=0 misc=0 getf=27342 sent=0 recv_vm=-1

HARDWARE->CLOCK 
raw_notify: src_p=-1 dst_p=-3 running_vm=1
get_uptime realtime=10451 vm_uptime=9159 uptime=1292

AT_WINI hdebug 
AT_WINI function=5 src_dst_e=4107 source=35555 type=1447645764 m1i1=1847611973 m1i2=1718187119 m1i3=543450473 m1p1=56207962 m1p2=4D4D m1p3=0 
hdebug: name=at_wini vmid=1 !!!!!!! nr=16 ep=35555 DRIVER notified by VMM:0x100B

HARDWARE->CLOCK 
raw_notify: src_p=-1 dst_p=-3 running_vm=1
get_uptime realtime=10452 vm_uptime=9159 uptime=1293

AT_WINI recvvm() pero en VM1 !!!!!!! por queeee ?
AT_WINI function=11 src_dst_e=31438 source=35555 type=4107 m1i1=0 m1i2=0 m1i3=3 m1p1=A m1p2=2878 m1p3=7FFFFFFF 
proc.c:271 vmid=1 nr=16 endp=35555 name=at_wini flags=0 misc=140 getf=31438 sent=27342 recv_vm=-1
SENDVM/RECVVM/NOTIFYVM: call_nr=11 function=11 result=-1 vmid=-1 priv=3 caller_vmid=1 running_vm=1
	
OTRO EJEMPLO:
FS->SH send()
SEND: src=fs dst=35548 source=1 type=0 m1i1=3 m1i2=4 m1i3=0 m1p1=0 m1p2=0 m1p3=0
proc.c:640 vmid=1 nr=9 endp=35548 name=sh flags=0 misc=400 getf=27342 sent=27342 recv_vm=-1

HARDWARE->CLOCK 
raw_notify: src_p=-1 dst_p=-3 running_vm=1
get_uptime realtime=48858 vm_uptime=47495 uptime=1363

AT_WINI function=5 src_dst_e=4107 source=35555 type=1447645764 m1i1=1847611973 m1i2=1718187119 m1i3=543450473 m1p1=56207962 m1p2=4D4D m1p3=0 
hdebug: name=at_wini >>>>>>>>>>>>>vmid=1<<<<<<<<<<<< nr=16 ep=35555 DRIVER notified by VMM:0x100B
AT_WINI function=11 src_dst_e=31438 source=35555 type=4107 m1i1=0 m1i2=0 m1i3=3 m1p1=A m1p2=BE6A m1p3=7FFFFFFF 
proc.c:271 >>>>>>>>>>>>> vmid=1 <<<<<<<<<<<< nr=16 endp=35555 name=at_wini flags=0 misc=140 getf=31438 sent=27342 recv_vm=-1
SENDVM/RECVVM/NOTIFYVM: call_nr=11 function=11 result=-1 vmid=-1 priv=3 caller_vmid=1 running_vm=1 <<<<<<<<<<<<

-------------------------------------------------------------------------------------------------------------------------
20140119:

RECVVM ANY
AT_WINI function=11 src_dst_e=31438 source=35555 type=68 m1i1=1 m1i2=0 m1i3=1 m1p1=33994000 m1p2=0 m1p3=2C74 
	
HDEBUG	
AT_WINI function=5  src_dst_e=4107 source=35555 type=1447645764 m1i1=1847611973 m1i2=1718187119 m1i3=543450473 m1p1=56207962 m1p2=4D4D m1p3=0 
hdebug: name=at_wini >>vmid=0<< nr=16 ep=35555 DRIVER notified by VMM:0x100B

RECVVM ANY
AT_WINI function=11 src_dst_e=31438 source=35555 type=4107 m1i1=0 m1i2=0 m1i3=3 m1p1=A m1p2=2460 m1p3=7FFFFFFF

HDEBUG
AT_WINI function=5 src_dst_e=4107 source=35555 type=1447645764 m1i1=1847611973 m1i2=1718187119 m1i3=543450473 m1p1=56207962 m1p2=4D4D m1p3=0 
hdebug: name=at_wini >>>vmid=1<<< nr=16 ep=35555 DRIVER notified by VMM:0x100B

AT_WINI function=11 src_dst_e=31438 source=35555 type=4107 m1i1=0 m1i2=0 m1i3=3 m1p1=A m1p2=2460 m1p3=7FFFFFFF 
proc.c:271 vmid=1 nr=16 endp=35555 name=at_wini flags=0 misc=140 getf=31438 sent=27342 recv_vm=-1
SENDVM/RECVVM/NOTIFYVM: call_nr=11 function=11 result=-1 vmid=-1 priv=3 caller_vmid=1 running_vm=1

.....................................................................................
SYSTEM: source=0 type=1537 m1i1=35555 m1i2=26990 m1i3=0 m1p1=11FE0 m1p2=1889 m1p3=0 
do_exec: in vmid=1 proc=16
do_exec: driver found at_wini
do_exec: in at_wini(VM0) exec:at_wini
do_exec: PROMISCUOUS at_wini

AT_WINI function=5 src_dst_e=1 source=35555 type=1986622052 m1i1=1952412261 m1i2=980120417 m1i3=1717920800 m1p1=746C7561 m1p2=63727320 m1p3=0 
hdebug: name=at_wini vmid=1 nr=16 ep=35555 driver_task: default src:0x1

AT_WINI function=5 src_dst_e=68 source=35555 type=1986622052 m1i1=1952412261 m1i2=980120417 m1i3=1717920800 m1p1=746C7561 m1p2=70797420 m1p3=65 
hdebug: name=at_wini vmid=1 nr=16 ep=35555 driver_task: default type:0x44

AT_WINI function=10 src_dst_e=1 source=35555 type=68 m1i1=0 m1i2=-22 m1i3=1 m1p1=33869000 m1p2=0 m1p3=2C74 
proc.c:271 vmid=1 nr=16 endp=35555 name=at_wini flags=0 misc=140 getf=31438 sent=27342 recv_vm=-1
SENDVM/RECVVM/NOTIFYVM: call_nr=10 function=10 result=-1 vmid=0 priv=3 caller_vmid=1 running_vm=1


ATENCION:
		El RS hace el fork y luego el exec /bin/at_wini
		pero lo hace con vmid=1
		Cuando se sobreescribe el descriptor en la VM1 se pone en VM0
		rp->p_rts_flags = 0;

SE modifico para los promiscuos do_exec y do_vmmcmd
		rp->p_rts_flags = NO_MAP;		
	
	
TODO:		Se deben separar loadvmimage del proxy como fuentes, pero deben integrarse todos con un nombre
			distinto segun el proxy que contenga.
			
Que pasa si  se establece para los procesos EXEC un SLOT determinado?
	De esa forma se pueden ejecutar servidores sin necesidad de booteo.
	esto permite establecer los privilegios
	por ejemplo
			SM (Security monitor) pordria tener asignado un P_NR al igual que TTY_PROC_NR

-------------------------------------------------------------------------------------------------------------------------
20150118:
		Implemente en el DS PUBLISH y RETRIEVE con info de una VM
		Hice test_ds_publish y test_ds_retrieve los cuales deben arrancarse con "service up"
		Se cambio el IS para presentar la info del DS
		
TODO:	Probar PUBLISH y RETRIEVE con info de una VM
		Ver como se puede ejecutar con privilegios de root.

		Usar al VMM para publicar y obtener configuracion.
		
Modificar VMMCMD con opcion CONFIG 
		vmmcmd CONFIG <config_file>  -> VMM -> DS
		vmmcmd LOAD 1
		vmmcmd LOAD->DS
		
		USAR other/configfile para obtener los parametros

-------------------------------------------------------------------------------------------------------------------------
20150119/20/21/22/23:
		Hice test_config para testear el archivo de configuracion
		modifique vmmcmd para que tome los datos de la VM del archivo de configuracion
		
		Ahora el comando es:
			vmmcmd LOAD <VM_name>
			vmmcmd START <VM_name>
		Donde el VM_name debe coincidir con el del archivo /etc/vmm.cfg 
		OJO: Ahora es incomodo setear la imagen a bootear

-------------------------------------------------------------------------------------------------------------------------
20150124:	
			Se establecio una configuracion de drivers por default que se setea en main para todas las VMs
			Cada vez que se hace un LOAD se vuelven a colocar los valores default
			Cada vez que se hace un START se pisan y agregan los drivers segun el archivo de configuracion.
			Para ello se agrego el nuevo comando al VMM y a SYSTASK : VMM_PROC
			En donde la SYSTASK copia desde el vmmcmd los datos del proc para pisar en la VM.
			
-------------------------------------------------------------------------------------------------------------------------
20150124:		
			VMMCMD: Se controla cuando se lee el archivo de configuracion que todos los parametros MANDATORY se hayan configurado


-------------------------------------------------------------------------------------------------------------------------
20150125:			
			Se cambio VMMCMD para qeu los tokens se especifiquen al arrancar la VM y no en el vmm.cfg.
			Se cambio el pick_proc para que se haga un unico loop donde se van detectando los diferentes tipos de procesos
				cada tick de reloj se rota la VM y despues de verificar si hay procesos de la VM0 busca para ver si hay
				procesos de la next_vm. Se elimino switch_VM como mecanismo de control de cambio de VM.		
			Se cambio clock.c para que el refresh de los tokens lo haga la TASK y no en tiempo de interrupcion.
	
 setup_bproc: proc_name=init p_misc_flags=400
 SYSTEM: 12 8 8 7 8 init
 SYSTEM: do_vm_start: vmid=1 is running. uptime=5746 tokens=34
 
Kernel panic: stack overrun by task  -2 
 MINIX will now be shut down ...
	
				SE MODIFICO Table.c para AUMENTAR EL TAMAÑO DE STACK DEL KERNEL A CLICK_SIZE
				
			FUNKA!!!!!
			
-------------------------------------------------------------------------------------------------------------------------
20150125
		Se cambio clock.c y proc.c 
		Se cambio pick_proc() para que tome el siguiente orden de procesos
			1- SYSTASK y CLOCK
			2- Procesos y tareas de VM0
			3- Tareas de VMx con tokens
			4- Procesos y tareas de next_vm != VM0
			5- Procesos de VMx con tokens
			6- Tareas de VMx sin tokens
			7- Procesos de VMx sin tokens
			8- IDLE
			
		Cada vez que se termina el periodo de refresco de tokens se produce un notify a CLOCK para que haga el refresco
		Esto se hace entonces FUERA de interrupcion
		Se cambio clock_handler para que por cada intrupcion de reloj se analice quien es next_vm 
			Si next_vm es igual al proceso interrumpido, entonces es hora de cambiar a otra VM
			si next_vm != VM0  y no es igual a la VM del proceso interrumpido pero ya no esta mas activa es hora de cambiar a otra VM 

-------------------------------------------------------------------------------------------------------------------------
20150201:
		Se modifico IS dmp_kernel.c sched_dmp() para que imprima la info de READY QUEUES.
		Para ello se necesita recorrer todos los proc[] de todas las VMs activas.
		
			
-------------------------------------------------------------------------------------------------------------------------
20150202:
		Se modifico IS dmp_kernel.c sched_dmp() para que imprima la info de READY QUEUES.
		Se vuelca toda la info de la VMs al IS y a partir de alli, por diferencia se rearman las READY QUEUES.
		FUNCIONA OK! pero es SOSPECHOZO que las tareas estan usando las colas de BAJA PRIORIDAD 13,14

-------------------------------------------------------------------------------------------------------------------------
20150203:
		Se modifico TTY de la forma en que se manejan los eventos.
		En lugar de hacer un rastreo de las ttys que tienen eventos pendientes, se arma una cola con las ttys que tienen
		eventos pendientes y se le da tratamiento a ellas.

		FALTA PROBAR!!

-------------------------------------------------------------------------------------------------------------------------
20150205:
	Para no perder notificaciones se cambio priv.h agregando un vector de caracteres 
	unsigned char s_ntfy_cnt[NR_SYS_PROCS]; /* pending notifications count  */ 
	Se inicializa en main() y cada vez que se crea un  proceso privilegiado o se cambian privilegios
	Se modifican entonces los notify() notifyvm() notifyas() y los receive() recvvm()
	para que en el if de las notificaciones pueda haber mas de una notificacion pendiente.

-------------------------------------------------------------------------------------------------------------------------
20150207:
		Modifique PROC.C recvvm() porque comparaba mal la VMID antes de entrar en el if de la verificacion de NOTIFICACIONES
	
		ANDUVO EL AT_WINI!!!!!
		
Despues del login: da el siguiente error y se cuelga.
	FS, warning illegal 1282 system call by 5 (TTY) /* 1282 = 0x0502 = DEV_REVIVE */
	
En una 2da corrida me da error 
  	getty: /dev/console: read error
	

TTY->FS1 notify	solicitando un DEV_STATUS
NOTIFYVM: src=tty dst=1 vmid=1 
MH_ntfyvm src=tty dst=1 flags=0 dst_vmid=1
hdebug: name=fs vmid=1 nr=1 ep=1 FS get_work who_e:0x5
hdebug: name=fs vmid=1 nr=1 ep=1 FS get_work call_nr:0x1009 (NOTIFY_FROM + TTY_PROC_NR + NR_TASKS) = 0x1000 + 5 + 4

FS1->TTY SENDREC DEV_STATUS
SENDREC: src=fs dst=5 source=1 type=1037 (0x40D DEV_STATUS)  m1i1=11517 m1i2=5029844 m1i3=1308 m1p1=8B03 m1p2=A800 m1p3=0 
	SEND
proc.c:555 vmid=0 nr=5 endp=5 name=tty flags=8 misc=2 getf=31438 sent=0 recv_vm=-1
proc.c:625 vmid=0 nr=5 endp=5 name=tty flags=0 misc=0 getf=27342 sent=0 recv_vm=-1
	RECEIVE
proc.c:709 vmid=1 nr=1 endp=1 name=fs flags=0 misc=201 getf=27342 sent=0 recv_vm=1


TTY->FS1
hdebug: name=tty vmid=0 nr=5 ep=5 TTY rqst_vmid:0x1
hdebug: name=tty vmid=0 nr=5 ep=5 TTY tty_mess.m_type:0x40D (DEV_STATUS)
prtmsg: proc=tty vmid=0 source=5 type=1037 m1i1=896 m1i2=5029844 m1i3=1229 m1p1=8B03 m1p2=A830 m1p3=0
 
hdebug: name=tty vmid=0 nr=5 ep=5 FS0, warning illegal 1282 syst:0x2B <<<<<<<<<<< LE ESTA RESPONDIENDO AL FS0 !!!!!!
hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: sys_umap:0x0
hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: dr_transfer:0x0


EL ERROR ESTA EN TTY.C 

  /* Almost done. Send back the reply message to the caller. */
  if ((status = sendvm(m_ptr->m_source, m_ptr, VM0)) != OK) <<<<< 

DEBE DECIR
  if ((status = sendvm(m_ptr->m_source, m_ptr, rqst_vmid)) != OK) <<<<< 

	
SENDREC: src=fs dst=5 source=1 type=1030 m1i1=16(TTY_LINE) m1i2=35613 m1i3=6 m1p1=4CBF60 m1p2=A127 m1p3=4CBF37 
proc.c:555 vmid=0 nr=5 endp=5 name=tty flags=8 misc=2 getf=31438 sent=0 recv_vm=-1
proc.c:625 vmid=0 nr=5 endp=5 name=tty flags=0 misc=0 getf=27342 sent=0 recv_vm=-1
proc.c:709 vmid=1 nr=1 endp=1 name=fs flags=0 misc=201 getf=27342 sent=0 recv_vm=1
hdebug: name=tty vmid=0 nr=5 ep=5 TTY rqst_vmid:0x1
hdebug: name=tty vmid=0 nr=5 ep=5 TTY tty_mess.m_type:0x406 (DEV_OPEN)
prtmsg: proc=tty vmid=0 source=5 type=1030 m1i1=16(TTY_LINE)  m1i2=35613 m1i3=6 m1p1=4CBF60 m1p2=A127 m1p3=4CBF37 

ESTA HACIENDO UN OPEN DEL TTY_LINE = RS232_MINOR 

NOTIFYVM: src=tty dst=4 vmid=1 
MH_ntfyvm src=tty dst=4 flags=0 dst_vmid=1
hdebug: name=tty vmid=0 nr=5 ep=5  from:0x1
hdebug: name=tty vmid=0 nr=5 ep=5 tty_reply to :0x1
prtmsg: proc=tty vmid=0 source=5 type=68 m1i1=35613 m1i2=-6 m1i3=1734700140 m1p1=72206C61 m1p2=65757165 m1p3=66207473 
SENDVM: src=tty dst=1 vmid=1 source=5 type=68 m1i1=35613 m1i2=-6 m1i3=1734700140 m1p1=72206C61 m1p2=65757165 m1p3=66207473

-------------------------------------------------------------------------------------------------------------------------
20150208:
		Se modifico TTY para que contemple a las RS232
		Modifique PROC.C reemplazando en las funciones de promiscuos el sender de los mensajes que era caller->p_endpoint
		por el verdadero sender src_ptr->p_endpoint siendo 	src_ptr = proc_addr_vm(dst_vmid, caller_ptr->p_nr);

		VM0 ARRANCA BIEN
		VM1 SE CUELGA

AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=3DA m1p2=7 m1p3=11E50 
SYSTEM: who_e=35555 who_p=16
LOCKSEND src=system dst=35555 

AT_WINI function=11 src_dst_e=1025 source=35555 type=73564 m1i1=9 m1i2=0 m1i3=73372 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 
AT_WINI MH_recvvm: proc.c:1403 vmid=0 nr=16 endp=35555 name=at_wini flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1
AT_WINI MH_recvvm: proc.c:1404 s_proc_nr=16 s_id=15 s_flags=12 s_nr_irq=0 s_vmid=0 s_vm_bitmap=1 s_dr_bitmap=0
RECVVM: SEARCHING NOT src_ep=1 
RECVVM: src_ep=1 p_misc_flags=6

		TAMBIEN SE CUELGA EN VM0
AT_WINI function=3 src_dst_e=-2 source=35555 type=1559 m1i1=98 m1i2=0 m1i3=1 m1p1=779 m1p2=7 m1p3=11E54 
SYSTEM: who_e=35555 who_p=16
LOCKSEND src=system dst=35555
 
AT_WINI function=11 src_dst_e=1025 source=35555 type=54704 m1i1=9 m1i2=0 m1i3=0 m1p1=0 m1p2=3B1 m1p3=0 
RECVVM: src_dst_e=1025 
RECVVM: src_ep=1025 
AT_WINI MH_recvvm: proc.c:1403 vmid=0 nr=16 endp=35555 name=at_wini flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1
AT_WINI MH_recvvm: proc.c:1404 s_proc_nr=16 s_id=15 s_flags=12 s_nr_irq=0 s_vmid=0 s_vm_bitmap=1 s_dr_bitmap=0
RECVVM: SEARCHING NOT src_ep=1 
RECVVM: src_ep=1 p_misc_flags=6


-------------------------------------------------------------------------------------------------------------------------
20150211:
	Se modifico proc.c
	Se modifico IS para que contemple rqst_vmid
	Se modifico tools/mkboot para que copie de la imagen al /boot/MYMINIX.img
	Se modifico tools/Make file para copiar el at_wini a la particion del disco de arranque de la VM1 



ANALIZAR:
	Cuando AT_WINI hace 
		vv = recvvm( ANY , &m, ANY_VM);  
o
		vv = recvvm( (NOT_PROC | FS_PROC_NR), &m, ANY_VM);   
	En realidad deberia esperar mensajes desde rqst_vmid

	El problema se da con HARDWARE que tiene que notificarlo.

o sea, si se hace
		vv = recvvm( ANY , &m, rqst_vmid); 
	si rqst_vmid = VM0 no deberia haber problemas
	si rqst_vmid != VM0 , HARDWARE deberería enviarle igualmente el NOTIFY e informar.

strange device reply from 35565 type = 4157 proc = 0 (2) ignored

-------------------------------------------------------------------------------------------------------------------------
20150214:
		Se modificaron kernel y system para quitar el DEBUG
		Se reemplazo HARDWARE por su puntero hard_ptr;
		

hdebug: name=fs vmid=1 nr=1 ep=1 FS: get_work vmid:0x1
hdebug: name=fs vmid=1 nr=1 ep=1 FS2 get_work who_e:0x115D0 ( 71120 - nSupongo que es #ls )
hdebug: name=fs vmid=1 nr=1 ep=1 FS2 get_work call_nr:0x3 (READ)

hdebug: name=tty vmid=0 nr=5 ep=5 TTY rqst_vmid:0x1
hdebug: name=tty vmid=0 nr=5 ep=5 TTY tty_mess.m_type:0x403 (DEV_READ)
prtmsg: proc=tty vmid=0 source=5 type=1027 (DEV_READ) m1i1=0 m1i2=71120 m1i3=1 m1p1=5A m1p2=2 m1p3=4E1F

TTY seguramente le pide algo a SYSTASK, pero como TTY y SYSTASK ambos estan en VM0, la resolucion del enpoint 
da error porque lo verifica en VM1. 71120:42:VM1  319893:??:VM0
isokendpt2b: proc_ptr(system,-2,0) rp(ls,42,0) endpoint(319893!=71120) running_vm=0

hdebug: name=tty vmid=0 nr=5 ep=5 tty_reply to :0x1
prtmsg: proc=tty vmid=0 source=5 type=68 m1i1=71120 m1i2=-14 m1i3=19999 m1p1=6A4A m1p2=1 m1p3=76E7 
hdebug: name=fs vmid=1 nr=1 ep=1 FS reply:0xFFFFFFF2

-------------------------------------------------------------------------------------------------------------------------
20150215:
		Se corrigio un error de proc.c
		
		
ERROR: en consola 		
		PM panic(exec.c): sys_exec failed: -405

-------------------------------------------------------------------------------------------------------------------------
20150216 :
hdebug: name=pm vmid=1 nr=0 ep=0 random:0x1
do_exec: driver found random
do_exec: in grep(VM0) exec:random  <<<<<<<<  LO QUE TANTO ME TEMIA- en VM0:grep en VM1:random !!
do_exec: PROMICUOUS_TASK random (VM0) is dead on VM0 
ERROR do_exec.c:156: do_exec: error -405
hdebug: name=tty vmid=0 nr=5 ep=5 TTY rqst_vmid:0x1
hdebug: name=tty vmid=0 nr=5 ep=5 TTY tty_mess.m_type:0x1004
prtmsg: proc=tty vmid=0 source=5 type=4100 m1i1=0 m1i2=1 m1i3=3 m1p1=7ACE m1p2=386 m1p3=5E2C 
hdebug: name=tty vmid=0 nr=5 ep=5 select_console: cons_line:0x0
hdebug: name=tty vmid=0 nr=5 ep=5 select_console:  vmid:0x1
hdebug: name=tty vmid=0 nr=5 ep=5 select_console: ccurrent:0x0
hdebug: name=tty vmid=0 nr=5 ep=5 select_console: cons_line:0x0
hdebug: name=tty vmid=0 nr=5 ep=5 select_console:  vmid:0x0
hdebug: name=tty vmid=0 nr=5 ep=5 select_console: NEW vmid:0x0
hdebug: name=tty vmid=0 nr=5 ep=5 select_console: ccurrent:0x0
hdebug: name=tty vmid=0 nr=5 ep=5 do_get_kmess rqst_vmid:0x0
hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: sys_umap:0x0
hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: dr_transfer:0x0
hdebug: name=tty vmid=0 nr=5 ep=5 TTY rqst_vmid:0x1
hdebug: name=tty vmid=0 nr=5 ep=5 TTY tty_mess.m_type:0x64
prtmsg: proc=tty vmid=0 source=5 type=100 m1i1=34 m1i2=35534 m1i3=19463 m1p1=C928 m1p2=19E70 m1p3=1216C 
hdebug: name=tty vmid=0 nr=5 ep=5 PM panic (exec.c): sys_exec fa:0x22

SOLUCION TEMPORARIA:	Que los procesos DISABLED en do_exec y en boot ocupen una ranura de la misma forma que cuando arranca VM0.

SOLUCION DEFINITIVA: 	Que los procesos promiscuos apunten a los correspondientes de la VM0 si necesidad de que p_nr0 = p_nrX.
	
ATENCION 

LOG->SYSTASK  	SYS_UMAP
hdebug: name=log vmid=1 nr=4 ep=4 do_rdwt: sys_umap:0x0
SYSTEM: running_vm=1 source=4 type=1550 SYS_UMAP m1i1=1679818753 m1i2=35593 m1i3=540701815 m1p1=15D4 m1p2=70616D75 m1p3=13FE 

LOG->SYSTASK	SYS_VIRCOPY
hdebug: name=log vmid=1 nr=4 ep=4 do_rdwt: dr_transfer:0x0
SYSTEM: running_vm=1 source=4 type=1551 SYS_VIRCOPY m1i1=65537 m1i2=35534 m1i3=35593 m1p1=5136 m1p2=15D4 m1p3=52 

hdebug: name=fs vmid=1 nr=1 ep=1 FS reply:0x52
hdebug: name=fs vmid=1 nr=1 ep=1 FS: get_work vmid:0x1
hdebug: name=fs vmid=1 nr=1 ep=1 FS2 get_work who_e:0x8B1B
hdebug: name=fs vmid=1 nr=1 ep=1 FS2 get_work call_nr:0x36
hdebug: name=tty vmid=0 nr=5 ep=5 TTY rqst_vmid:0x1
hdebug: name=tty vmid=0 nr=5 ep=5 TTY tty_mess.m_type:0x405
prtmsg: proc=tty vmid=0 source=5 type=1029 (0x405 DEV_IOCTL) m1i1=0 m1i2=35611 m1i3=1074287633 m1p1=0 m1p2=2 m1p3=159C 

isokendpt3: proc_ptr(system,-2,0,0) src_dst(rm,66,0,1). running_vm=0  
RETURN proc.c:569: rcode=-109

SYSTEM, reply to call_nr=6 running_vm=0 ep=5 failed: -109
SYSTEM: running_vm=0 source=4 type=1551 SYS_VIRCOPY m1i1=65537 m1i2=35534 m1i3=35593 m1p1=5136 m1p2=15D4 m1p3=52 



-------------------------------------------------------------------------------------------------------------------------
20150216:

COSA RARA: PARECE QUE SE CUELGA PERO EL FTP FUNCIONA Y EL TELNET RESPONDE
I am sorry, but there is no free PTY left!

ACA SYSTASK NO ENCUENTR "rm" que busca en la VM0 pero que realmente estaba en la VM1
isokendpt3: proc_ptr(system,-2,0,0) src_dst(rm,66,0,1). running_vm=0


SE TRANSFORMO LOG DE REAL A PROMISCUO.

LLEGA HASTA EL LOGIN SIN NINGUN PROBLEMA
DESPUES PROVOCA VARIOS ERRORES isokendp

!!!!! AQUI HAY UN PROBLEMA EN LOG !!!!!!!!
MH_ntfyvm src=tty dst=4 flags=0 dst_vmid=1
RETURN proc.c:1650: rcode=-103
isokendpt3: proc_ptr(system,-2,0,0) src_dst(rm,66,0,1). running_vm=0
MH_ntfyvm src=tty dst=4 flags=0 dst_vmid=1
RETURN proc.c:1650: rcode=-103

MH_send: caller=system dst_ep=5 running_vm=0 
RETURN proc.c:571: rcode=-109
SYSTEM, reply to call_nr=6 running_vm=0 ep=5 failed: -109

-------------------------------------------------------------------------------------------------------------------------
20150216:

hdebug: name=fs vmid=1 nr=1 ep=1 FS reply:0x1
hdebug: name=fs vmid=1 nr=1 ep=1 FS: get_work vmid:0x1
hdebug: name=fs vmid=1 nr=1 ep=1 FS2 get_work who_e:0x8B1B
hdebug: name=fs vmid=1 nr=1 ep=1 FS2 get_work call_nr:0x36
hdebug: name=tty vmid=0 nr=5 ep=5 TTY rqst_vmid:0x1
hdebug: name=tty vmid=0 nr=5 ep=5 TTY tty_mess.m_type:0x405
prtmsg: proc=tty vmid=0 source=1 type=1029 m1i1=0 m1i2=35611 m1i3=1074287633 m1p1=0 m1p2=2 m1p3=159C 
hdebug: name=tty vmid=0 nr=5 ep=5 octl: TTY_REQUEST:0x40085411
hdebug: name=tty vmid=0 nr=5 ep=5 octl: TIOCSWINSZ vmid:0x1
do_vcopyvm[0] endp=35611, offse=159C, vmid=1
virtual_copy_vm1: i=0 vmid=1 endp=35611, proc_nr=72 type=0 vmid=1 nr=72 endp=35611 name=sh ??????????????????????
virtual_copy_vm1: i=1 vmid=0 endp=5, proc_nr=5 type=0

isokendpt3: proc_ptr(system,-2,0,0) src_dst(rm,66,0,1). running_vm=0 !!! vmid=1 nr=66 endp=35605 name=sh ??????????????????????

MH_send: caller=system dst_ep=5 dst_ptr->p_vmid=0 running_vm=0 

proc.c:572 vmid=0 nr=5 endp=5 name=tty >>>flags=230<<< misc=1 getf=-2 sent=0 recv_vm=-1

RETURN proc.c:573: rcode=-109
SYSTEM, reply to call_nr=6 running_vm=0 ep=5 failed: -109
SYSTEM: result=0 running_vm=0 rcode=-109 source=5 type=0 m1i1=35534 m1i2=9 m1i3=1 m1p1=32 m1p2=FFFFFFFE m1p3=67F44 

TTY:
>>>flags=230<<< 
NO_ENDPOINT    	0x200
SIGNALED	0x010
SIG_PENDING	0x020

-------------------------------------------------------------------------------------------------------------------------
20150219:
		Se incluyo en virtual_copy codigo para detectar falla
		MHDEBUG("virtual_copy_vm: before\n");
        phys_copy(phys_addr[_SRC_], phys_addr[_DST_], (phys_bytes) bytes);
		MHDEBUG("virtual_copy_vm: after\n");

	
hdebug: name=fs vmid=1 nr=1 ep=1 FS: get_work vmid:0x1
hdebug: name=fs vmid=1 nr=1 ep=1 FS2 get_work who_e:0x8B1F
hdebug: name=fs vmid=1 nr=1 ep=1 FS2 get_work call_nr:0x36
hdebug: name=tty vmid=0 nr=5 ep=5 TTY rqst_vmid:0x1
hdebug: name=tty vmid=0 nr=5 ep=5 TTY tty_mess.m_type:0x405
prtmsg: proc=tty vmid=0 source=1 type=1029 m1i1=0 m1i2=35615 m1i3=1074287633 m1p1=0 m1p2=2 m1p3=159C 
hdebug: name=tty vmid=0 nr=5 ep=5 octl: TTY_REQUEST:0x40085411
hdebug: name=tty vmid=0 nr=5 ep=5 octl: TIOCSWINSZ vmid:0x1

do_vcopyvm: src=5 running_vm=0
do_vcopyvm[0] endp=35615, offse=159C, vmid=1
do_vcopyvm[1] endp=35534, offse=624AC, vmid=0
virtual_copy_vm1: i=0 vmid=1 endp=35615, proc_nr=76 type=0
virtual_copy_vm1: i=1 vmid=0 endp=5, proc_nr=5 type=0
virtual_copy_vm: before
virtual_copy_vm: after

CAMBIAR MENSAJES A TIPO 5
SYSTEM: SYS_VCOPYVM running_vm=0 source=5 type=0 m1i1=1 m1i2=35615 m1i3=35534 m1p1=159C m1p2=624AC m1p3=8
 

COLOCAR UN MHDEBUG CUANDO SYSTASK HACE SEND A TTY
isokendpt3: e=35609 *p=70 proc_ptr(system,-2,-2,0,0) src_dst(grep,35609,70,0,1). running_vm=0 <<<<<<<<< 35609 es sh 

MH_send: caller=system dst_ep=5 dst_p=5 dst_ptr->p_vmid=0 running_vm=0 
proc.c:576 vmid=0 nr=5 endp=5 name=tty flags=230 misc=1 getf=-2 sent=0 recv_vm=-1
TTY:
>>>flags=230<<< 
NO_ENDPOINT    	0x200
SIGNALED	0x010
SIG_PENDING	0x020


RETURN proc.c:577: rcode=-109
SYSTEM, reply to call_nr=6 running_vm=0 ep=5 failed: -109
SYSTEM: result=0 running_vm=0 rcode=-109 source=5 type=0 m1i1=35534 m1i2=9 m1i3=1 m1p1=32 m1p2=FFFFFFFE m1p3=67F44 

-------------------------------------------------------------------------------------------------------------------------
20150226:
		Se cambio mensajes tipo 5 para ver correctamente los parametros

system.c:644 vmid=1 nr=70 endp=35609 name=sh flags=8 misc=401 getf=1 sent=27342 recv_vm=1

prtmsg: proc=tty vmid=0 source=1 type=1029 m1i1=0 m1i2=35615 m1i3=1074287633 m1p1=0 m1p2=2 m1p3=159C 
hdebug: name=tty vmid=0 nr=5 ep=5 octl: TTY_REQUEST:0x40085411
hdebug: name=tty vmid=0 nr=5 ep=5 octl: TIOCSWINSZ vmid:0x1
do_vcopyvm: src=5 running_vm=0
do_vcopyvm[0] endp=35615, offse=159C, vmid=1
do_vcopyvm[1] endp=35534, offse=624AC, vmid=0
virtual_copy_vm1: i=0 vmid=1 endp=35615, proc_nr=76 type=0
virtual_copy_vm1: i=1 vmid=0 endp=5, proc_nr=5 type=0
virtual_copy_vm: before
virtual_copy_vm: after
SYSTEM: SYS_VCOPYVM running_vm=0 source=5 type=0 m5c1= m5c2=  m5i1=35615 m5i2=35534 m5l1=5532 m5l2=402604 m5l3=8

Puede ser CLOCK que hace que venza el timeout de la shell.
Luego SYSTASK le intenta enviar el mensaje a la SHELL pero se encuentra en VM0 en lugar de VM1
QUE NO CIERRA: Que se supone que system le envia mensaje al PM, no a la SH
QUE NO CIERRA: Que hace SYSTASK preguntando por SH ?? 
isokendpt3: e=35609 *p=70 proc_ptr(system,-2,-2,0,0) src_dst(grep,35609,70,0,1). running_vm=0  <<< ES SH EN VM1

MH_send: caller=system dst_ep=5 dst_p=5 dst_ptr->p_vmid=0 running_vm=0 
proc.c:576 vmid=0 nr=5 endp=5 name=tty flags=230 misc=1 getf=-2 sent=0 recv_vm=-1
RETURN proc.c:577: rcode=-109
SYSTEM, reply to call_nr=6 running_vm=0 ep=5 failed: -109

.......................................................................................


prtmsg: proc=tty vmid=0 source=1 type=1029 m1i1=0 m1i2=35611 m1i3=1074287633 m1p1=0 m1p2=2 m1p3=159C 
hdebug: name=tty vmid=0 nr=5 ep=5 octl: TTY_REQUEST:0x40085411
hdebug: name=tty vmid=0 nr=5 ep=5 octl: TIOCSWINSZ vmid:0x1

03548 463758
03548 497533
03548 156 491875

system.c:128 vmid=0 nr=5 endp=5 name=tty >>>>>>>flags=8<<<<<<<< misc=1 getf=-2 sent=0 recv_vm=0

do_vcopyvm: src=5 running_vm=0
do_vcopyvm[0] endp=35611, offse=159C, vmid=1
do_vcopyvm[1] endp=35534, offse=624AC, vmid=0
virtual_copy_vm1: i=0 vmid=1 endp=35611, proc_nr=72 type=0
virtual_copy_vm1: i=1 vmid=0 endp=5, proc_nr=5 type=0
virtual_copy_vm: before
virtual_copy_vm: after
SYSTEM: SYS_VCOPYVM running_vm=0 source=5 type=0 m5c1= m5c2=  m5i1=35611 m5i2=35534 m5l1=5532 m5l2=402604 m5l3=8

>>>>>>>>>system.c:142 vmid=0 nr=5 endp=5 name=tty >>>>>>>flags=8<<<<<<<<<< misc=1 getf=-2 sent=0 recv_vm=0

isokendpt3: e=35605 *p=66 proc_ptr(system,-2,-2,0,0) src_dst(rm,35605,66,0,1). running_vm=0
MH_send: caller=system dst_ep=5 dst_p=5 dst_ptr->p_vmid=0 running_vm=0 

proc.c:584 vmid=0 nr=5 endp=5 name=tty >>>>>>>flags=230<<<<<<<<< misc=1 getf=-2 sent=0 recv_vm=-1 TTY ESTA MUERTO!!!!!!!!!!!!!!!!!!

RETURN proc.c:585: rcode=-109
LOCKSEND src=system dst=5 
SYSTEM, reply to call_nr=6 running_vm=0 ep=5 failed: -109
SYSTEM: result=0 running_vm=0 rcode=-109 source=5 type=0 m5c1=Î m5c2=  m5i1=9 m5i2=1 m5l1=50 m5l2=-2 m5l3=425796
	

-------------------------------------------------------------------------------------------------------------------------
20150307:

hdebug: name=login vmid=1 nr=70 ep=35609 login:0x0
hdebug: name=login vmid=1 nr=70 ep=35609 VM1:0x1
hdebug: name=pm vmid=1 nr=0 ep=0 get_work vmid:0x1
	
BIEN!
En system 
cause_sig(proc_nr, sig_nr)
se hace
	rp->p_rts_flags |= SIGNALED | SIG_PENDING;	/* update flags */	
justo las banderas que tiene prendida TTY 

hdebug: name=tty vmid=0 nr=5 ep=5 TTY rqst_vmid:0x1
hdebug: name=tty vmid=0 nr=5 ep=5 TTY tty_mess.m_type:0x405
prtmsg: proc=tty vmid=0 source=1 type=1029 m1i1=1 m1i2=35620 m1i3=1074287633 m1p1=0 m1p2=2 m1p3=159C 
hdebug: name=tty vmid=0 nr=5 ep=5 octl: TTY_REQUEST:0x40085411
hdebug: name=tty vmid=0 nr=5 ep=5 octl: TIOCSWINSZ vmid:0x1
isokendpt3: e=35610 *p=71 proc_ptr(system,-2,-2,0,0) src_dst(sysenv,35610,71,0,1). running_vm=0
cause_sig: proc_nr=5, sig_nr=9 running_vm=0 <<<<<<<<<<<<<<<< SIG_KILL !!!!!! A TTY
MH_send: caller=system dst_ep=5 dst_p=5 dst_ptr->p_vmid=0 running_vm=0 

!!!!! ANDUVO UNA VEZ AL MENOS LA SHELL!!!!
No anduvo cuando cambie de TTY a otra consola de la VM1 y me loguee

TTY ->SYSTASK KILL 35608 PERO DE LA VM1!!!!!!!
hdebug: name=tty vmid=0 nr=5 ep=5 tty sigchar sys_kill:0x8B18 (35608)
SOLUCION: Crear sys_killvm() la cual solo puede usar un proceso PROMISCUO o PROXY de la VM correspondiente

Por lo tanto este isokendpt le da ERROR
if (!isokendpt(proc_nr_e, &proc_nr)) return(EINVAL);
isokendpt3: e=35608 *p=69 proc_ptr(system,-2,-2,0,0) src_dst(grep,35608,69,0,1). running_vm=0

source=5 type=1542 m2i1=35534 m2i2=9 m2i3=1 m2l1=50 m2l2=-2 m2p1=67F44
cause_sig: proc_nr=5, sig_nr=9 running_vm=0
source=5 type=1542 m2i1=35534 m2i2=9 m2i3=1 m2l1=50 m2l2=-2 m2p1=67F44

-------------------------------------------------------------------------------------------------------------------------
20150308:
	Se creo sys_killvm() y se reemplazo en tty
	Se creo IPC _nodebug que reemplaza a _hdebug cuando en CONFIG.H se coloca MHDGB en 0
	
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!111
HITO PRINCIPAL: FUNCIONO PERFECTAMENTE!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!111

-------------------------------------------------------------------------------------------------------------------------
20150310:
		OJO !!!! AL ANULAR _hdebug se anula la posibilidad de conocer el vmid y NO FUNCIONA!!!!!!!!!!!!!!!!!!!!!!!!!!!!111
		Para ello se cambion CONFIG.H y se puso ENABLE_HDBG
		Con este flag  _nodebug que reemplaza a _hdebug cuando en CONFIG.H se coloca ENABLE_HDBG en 0
		Cuando MHDBG = 0 se hace el IPC pero retorna vmid.
	
-------------------------------------------------------------------------------------------------------------------------
20150313:	
		Se cambio CONFIG.H limitando la cantidad de VMs a 3 (VM0+3) y la cantidad de puertos serie por VM
		Se cambio TTY y RS232
		Hay que mejorar el cambio
		la idea es que VM0 => COM1
						VM1 => COM2

-------------------------------------------------------------------------------------------------------------------------
20150314:						
		Se modifico RS232 para que 
				VM0 => COM1
				VM1 => COM2
		Pero solo imprime algunos caracteres em COM2

-------------------------------------------------------------------------------------------------------------------------
20150317:
		Se cambio la forma en que se genera el archivo de image loadvmimg
		se creo el directorio /usr/src/proxy
		alli conviven el loadvmimg como cargador y proxy disparador de drivers
		en el archivo libproxy.h se configuran cuales son los drivers que se habilitaran 
		cada driver debe suministrar 2 funciones:
			- init_XX()
			- proxy_XX(driver_nr)
		Siendo XX entre 0 y 31 correspondientes a los 32 procesos que pueden ser controlados por los proxies
		
		Como ejemplo se hizo el driver de floppy que a los efectos de una mejor lectura del codigo se pone
			#define  floppy_init 	init_13
			#define  floppy_driver 	proxy_13
		
		Debiendose habilitar en libproxy.h
			#define PROXY_13 1
		
		En el /usr/src/test se genera el archivo proxy_VMx.log 

-------------------------------------------------------------------------------------------------------------------------
20150324:
		Se creo el sitio
		https://sourceforge.net/projects/mhyper/
		
usr: ppessolani
passwd: <8digitos_renault9><2digito_año_nacimiento> total 10 caracteres

-------------------------------------------------------------------------------------------------------------------------
20150325:		
		proc.c Se cambio MH_send eliminando el envio de mensajes de un promiscuo a otro proceso en VM0
		dado que esto se resuelve antes mediante MH_send.

-------------------------------------------------------------------------------------------------------------------------
20150328:		
		En dias previos se cambio la forma en como trabajan los promiscuos en VMx
		Se incorporo un nuevo campo en los privilegios
			privilegios int s_nr[NR_VMS]
		que indica que numero de proseso en VMx representa al proceso promiscuo p_nr de la VM0 en VMx
		por otro lado se agrego puso un alias a los descriptores de procesos promiscuos en VMx que apuntan al proceso en VM0
				p_promiscuous usa p_nextready que no es utilizado en las VMx
		Se cambiaron las primitivas sendvm, recvvm, notifyvm y send, receive y notify
		Se cambio main para inicializar estos campos
		

FUNCIONA OK pero hay que probar cuando con procesos promiscuos que p_nr0 != p_nrX


-------------------------------------------------------------------------------------------------------------------------
20150330:
	Se eliminaron de proc.c
		- DEBUG DE AT_WINI
		- Eliminar todo el codigo de sendvm notifyvm cuando se envia de VM0 -> VM0.
		
	VERSION INESTABLE !!!!!!

	
-------------------------------------------------------------------------------------------------------------------------
20150403:			
	
	Se modifico proc.c y funciona OK
	
	SENDVM RESOLVER ESTE TEMA MH_sendvm
	* Destination is not waiting . 
	* TWO POSIBLE BEHAVIOURS
	* 1) Block and Enqueu the caller (a promiscuous process on VM0 is critical)
	* 2) copy the message to descriptor on VMx and enqueue it. The promiscuous process on VM0 remains running
	*    But any other IPC must be executed for VMx until the descriptor on VMx must be PSEUDO-READY.
		
	RESUELTO!!!
		Un proceso promiscuo (VM0) no deberia esperar tratando de enviar un mensaje a un proceso en VMx  
			return(EPROCSTATUS);

			
ERROR:
	Presione F9 (colas de planificacion) las presento en pantalla pero se colgo
	
	porque AT_WINI  35555 esta atendiendo IRQ 14 y 15 ???
	irq=14 id=2 proc_nr_e=35555 notify_id=14 policy_t=1 vmid=0 <<<< 
	irq=15 id=1 proc_nr_e=35555 notify_id=15 policy_t=1 vmid=0 <<<<
	
ERROR:
	Ejecute en paralelo en VM0 y VM1 make world y se colgo
	presiono F1 y se ve a AT_WINI colgado
	
	PORQUE 2 HOOKS ??????
# IRQ policies dump shows use of kernel's IRQ hooks. (VM0)
vmid -h.id- -proc.nr- -IRQ vector (nr.)- -policy- -notify id-
   0  0         5          rs232 (04)   reenable   4
   0  1         5       keyboard (01)   reenable   1
   0  2         5                (12)   reenable   12
   0  3     35552         floppy (06)       -      6
   0  4     35555      at_wini_0 (14)   reenable   14 <<<<<<<<<<<<<<<<<<<<<<<<
   0  5     35589                (09)       -      9
   0  6     35555      at_wini_0 (14)   reenable   14 <<<<<<<<<<<<<<<<<<<<<<<<
   0  7    <unused>
   0  8    <unused>
   0  9    <unused>
   0 10    <unused>
   0 11    <unused>
   0 12    <unused>
   0 13    <unused>
   0 14    <unused>
   0 15    <unused>
	
	Esta insertando 2 hooks (una por VM0 y otra por VM1)	
	irq=14 id=1 proc_nr_e=35555 notify_id=14 policy_t=1 vmid=0
	irq=14 id=2 proc_nr_e=35555 notify_id=14 policy_t=1 vmid=0
	
	Esto es en el caso que este en 2 controladores diferentes
	#define AT_WINI_0_IRQ     14	/* at winchester controller 0 */
	#define AT_WINI_1_IRQ     15	/* at winchester controller 1 */


	#define sys_irqenable(hook_id) \
    sys_irqctl(IRQ_ENABLE, 0, 0, hook_id) 
	
	Habria que setear tambien la vmid del hook

ATENCION:
	Se cambio la organizacion de discos
		IDE 0.0: /dev/c0d0 minor 0
		IDE 1.0: /dev/c0d2 minor 10
		
hdebug: name=fs vmid=1 nr=1 ep=1 FS2 get_work who_e:106657
hdebug: name=fs vmid=1 nr=1 ep=1 FS2 get_work call_nr:3
hdebug: name=pm vmid=1 nr=0 ep=0 PM get_work who_e:-3
hdebug: name=pm vmid=1 nr=0 ep=0 PM get_work call_nr:4097
hdebug: name=pm vmid=1 nr=0 ep=0 get_work vmid:1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 driver_task: ERROR:-407 EPROMISCUOUS
hdebug: name=at_wini vmid=0 nr=16 ep=35555 driver_task: ERROR:-407

-------------------------------------------------------------------------------------------------------------------------
20150404:
		VERSION ESTABLE -  habia un error en MH_recvvm()
		
		Se volvio todo a
			IDE 0.0: /dev/c0d0 minor 0
			IDE 0.1: /dev/c0d1 minor 5
			
-------------------------------------------------------------------------------------------------------------------------
20150405:
		Se intenta en vmmcmd configurar un device DISK MINOR.
		Se publica perfectamente en el DS
		El problema es que la VM todavia se desconoce, por lo que como parte de la info que se debe
		publicar es el NOMBRE de la VM.
		
TODO:	No se sabe a la altura del LOAD que VMID tendra la VM
		Por lo tanto se necesita construir una KEY unica para el driver.
		
		!!!! PERSISTE INESTABILIDAD !!!!!!
	
-------------------------------------------------------------------------------------------------------------------------
20150407:
		Se modifico DS, sus librerias y archivos de include/minix para soportar
		DS_DELETE y asi poder borrar la clave.
		USO PRINCIPAL:
			ds_publish(procesos y drivers)	
			do_execvm()..... pero falla
			ds_delete(procesos y drivers)
		De igual forma:
			Cuando se termina una VM se deben suprimir todas sus entradas en el DS.

TODO:
		Hay que construir la clave KEY para publicar los drivers de la siguiente manera.
		ds_ptr->ds_key  =  ((vmid << VDEV_SHIFT_VMID) | (vdev_id << VDEV_SHIFT_INDEX)  | (d_ptr->d_type));
		El tema es obtener la VM a la que refiere.

En main de VMMCMD se pide info de todas las VMs
   	m.VMM_cmd   = VMM_TABDUMP;
	m.VMM_p1    =  &vmm_desc;
	MHDEBUG("VMMCMD: %s cmd=%d \n",
			cmdstring[cmd-VMM_RQ_BASE],
			m.VMM_cmd);
	rcode = vmmcmd(	m.VMM_cmd,
				m.VMM_i2,
				m.VMM_i3,
				m.VMM_p1,
				m.VMM_p2,
				m.VMM_p3);
	MHDEBUG("VMMCMD: rcode=%d\n",rcode);
	for (vmid = 0; vmid < NR_VMS; vmid++){
		vmm_ptr = &vmm_desc[vmid];		
		MHDEBUG(VMM_FORMAT, VMM_FIELDS(vmm_ptr));
	}
Dado que el VMM SERVER busca un descriptor libre de la siguiente manera:
PRIVATE int alloc_vmdesc(void)
{
	int i;
  	struct vmm_desc_s *vmm_ptr;

	for (i = 1;  i < NR_VMS; i++) {
		vmm_ptr	=&vmm_desc[i];
		if( vmm_ptr->vmm_flags == VM_FREE) 
			return(i);
	}
	return(i);
}

Se puede deducir en VMMCMD cual es el valor de la VMID que el VMM irá a asignar.
		!!!! PERSISTE INESTABILIDAD !!!!!!

		
-------------------------------------------------------------------------------------------------------------------------
20150407:
		Cambie VMMCMD para que si falla algo durante la carga de la VM suprima todo lo referente a Virtual Devices que se 
		publico en el DS.
		!!!! PERSISTE INESTABILIDAD !!!!!!
		
		TODO: Hay que hacer lo mismo con los procesos y con la propia VM
			Toda salida fallida debe ir suprimir lo cargado

-------------------------------------------------------------------------------------------------------------------------
20150411:
		Cambie AT_WINI y LIBDRIVER para que AT_WINI sea notificado al arrancar una VM
		y para que AT_WINI obtenga la configuracion desde el DS
		
		ATENCION dev_idx como parte de la key no deberia usarse al publicar el DS. Debe ser algo que el AT_WINI SEPA
 		
		!!!! PERSISTE INESTABILIDAD !!!!!!			
	
-------------------------------------------------------------------------------------------------------------------------
20150410:	

do_exec: driver found at_wini type=154
do_exec: process at_wini MATCH on VM0 p_nr0=16 p_nrX=16
do_exec: in at_wini(VM0) exec:at_wini p_nrX=16
do_exec: notifying at_wini type=154
do_exec: notifying 16
do_exec.c:139 s_proc_nr=16 s_id=15 s_flags=12 s_nr_irq=0 s_vmid=0 s_vm_bitmap=3 s_dr_bitmap=0

/var/log/messages
Apr 12 21:13:33 192 kernel: PM:do_exec: vmsize 16384, text_bytes 14672, data_bytes 5124, bss_bytes 53080, stk_bytes 76, tot_bytes 67108864 
Apr 12 21:13:34 192 kernel:  name=VM1 vmid=1 size=16128 tokens=0 boot_bm=55555555
Apr 12 21:13:34 192 kernel: 	bootprog=bootprog_path
Apr 12 21:13:34 192 kernel: 	bootimage=/boot/MYMINIX.img
Apr 12 21:13:47 192 kernel: d_vmname=MYMINIX d_name=at_wini d_type=101
Apr 12 21:13:47 192 kernel: DRIVER notified by VMM 100B
Apr 12 21:13:47 192 kernel: DRIVER returned from notify 4096
Apr 12 21:13:47 192 kernel: ERROR notifying driver at_wini by VMM r=4096

		Hay problemas SE CUELGA DESPUES
					_mhdebug("DRIVER notified by VMM",m_ptr->m_type);
					printf("DRIVER notified by VMM %X\n",m_ptr->m_type);
					r = (*dp->dr_notify)(dp, m_ptr); 
					printf("DRIVER returned from notify %d\n",r);
		>>>>>>>>>>  AQUI SE CUELGA
					if(r) {
						printf("ERROR notifying driver %s by VMM r=%d\n",rp->p_name,r);
					} else {
						printf("DRIVER continue\n");
					}
					continue;
		
		Segun F1
			FS esta esperando a AT_WINI
			AT_WINI tiene el flag "P" SIG_PENDING !!!!!!!!!!!!!!!!!!!!!!11

-------------------------------------------------------------------------------------------------------------------------
20150413:			
		FUNCIONO BIEN la publicacion de DISK AT_WINI MINOR 
		
		
		Se reemplazo 
			(vd_index << VDEV_SHIFT_INDEX)
		por el indice de at_wini dentro de kernel/drivers.h
			(driver_index << VDEV_SHIFT_INDEX)

		!!!! PERSISTE INESTABILIDAD !!!!!!		
		
TODO:	Hacer una tabla de discos rigidos que maneja AT_WINI


# ls -l /dev/c0d0p0s0
brw------- 1 root  operator  3, 128 Apr 13 20:20 /dev/c0d0p0s0
# ls -l /dev/c0d1p0s0
brw------- 1 root  operator  3, 144 Mar  8  2014 /dev/c0d1p0s0
# ls -l /dev/c0d2p0s0
brw------- 1 root  operator  3, 160 May  3  2006 /dev/c0d2p0s0
# ls -l /dev/c0d3p0s0
brw------- 1 root  operator  3, 176 May  3  2006 /dev/c0d3p0s0
#
# ls -l /dev/c0d0
brw------- 1 root  operator  3,   0 Apr  9 06:37 /dev/c0d0
# ls -l /dev/c0d1
brw------- 1 root  operator  3,   5 Jul 12  2014 /dev/c0d1
# ls -l /dev/c0d2
brw------- 1 root  operator  3,  10 May  3  2006 /dev/c0d2
# ls -l /dev/c0d3
brw------- 1 root  operator  3,  15 Apr  9 06:35 /dev/c0d3

# ls -l /dev/c0d0p0
brw------- 1 root  operator  3,   1 Apr 14  2012 /dev/c0d0p0
# ls -l /dev/c0d1p0
brw------- 1 root  operator  3,   6 Oct  4  2014 /dev/c0d1p0
# ls -l /dev/c0d2p0
brw------- 1 root  operator  3,  11 May  3  2006 /dev/c0d2p0
# ls -l /dev/c0d3p0
brw------- 1 root  operator  3,  16 Apr  9 06:38 /dev/c0d3p0

	if( minor%DEV_PER_DRIVE(5) == 1) 	/* 1,6,11,16 */
		real_minor =  (((minor-1)/DEV_PER_DRIVE(5)) * SUB_PER_DRIVE(16)) + ((virt_minor-128)%SUB_PER_DRIVE(16)) + 128;	

		real_minor =  ( (6-1)/5 * 16) + (130-128)%16 + 128 = 16 + 2 + 128 = 146

/dev/c0d0 		0
/dev/c0d0p0 		1 
/dev/c0d0p1 		2
/dev/c0d0p2 		3 
/dev/c0d0p3 		4

/dev/c0d1 		5
/dev/c0d1p0 		6 ----- minor
/dev/c0d1p1 		7
/dev/c0d1p2 		8
/dev/c0d1p3 		9

/dev/c0d2 		10
/dev/c0d2p0 		11
/dev/c0d2p1 		12
/dev/c0d2p2 		13
/dev/c0d2p3 		14

/dev/c0d3 		15
/dev/c0d3p0 		16
/dev/c0d3p1 		17
/dev/c0d3p2 		18
/dev/c0d3p3 		19

/dev/c0d0p0s0		128
/dev/c0d0p0s1		129
/dev/c0d0p0s2		130 ------- virt_minor
/dev/c0d0p0s3		131

/dev/c0d0p1s0		132
/dev/c0d0p1s1		133
/dev/c0d0p1s2		134
/dev/c0d0p1s3		135

/dev/c0d0p2s0		136
/dev/c0d0p2s1		137
/dev/c0d0p2s2		138
/dev/c0d0p2s3		139

/dev/c0d0p3s0		140
/dev/c0d0p3s1		141
/dev/c0d0p3s2		142
/dev/c0d0p3s3		143

/dev/c0d1p0s0		144
/dev/c0d1p0s1		145
/dev/c0d1p0s2		146 ------- real_minor
/dev/c0d1p0s3		146



brw------- 1 root  operator  3, 144 Mar  8  2014 /dev/c0d1p0s0


if (minor < 128)
	real_minor = virt_minor + virt_minor; /* 5 = 0 + 5 */
else
	real_minor =  minor + ((virt_minor/DEV_PER_DRIVE) * SUB_PER_DRIVE(16))	
		

supongamos que el parametro de la VM1 es 
virt_minor=5 (/dev/c0d1)
y el dispositivo referido por VM1 es /dev/c0d0 => minor=0 
entonces  
real_minor =  0 + 5 = 5

supongamos que el parametro de la VM1 es 
virt_minor=5 (/dev/c0d1)
y el dispositivo referido por VM1 es /dev/c0d0p0s0 => minor=128 
real_minor = 128 + ((5/5) * 16) = 144  (/dev/c0d1p0s0)

-------------------------------------------------------------------------------------------------------------------------
20150416:
		Se modifico la asignacion de bits en la conformacion de la KEY para que no haya colisiones entre:
			-VM
			-PROC
			-VDEV
			
	<KEY_TYPE(4)> 	<VMID>(28)
	<KEY_TYPE(4)> 	<VMID>(4)  <PROC_INDEX(8)>  <PROC_FLAGS(16)>
	<KEY_TYPE(4)> 	<VMID>(4)  <VDEV_INDEX(8)>  <VDEV_DEV(8)>  <VDEV_VIRT(8)>		

# Data Store (DS) contents dump. (VM0)
slot -key- flags -val_l1- -val_l2- endpoint
 0  900 U-----   131072  7864320        0
 1 210D0102 UP-T--        1       13    35638 p_vmname=MYMINIX nr=0 ep=0 flags=102 name=floppy
 path=
 2 310F0101 UP--D-        1       15    35638 d_vmname=MYMINIX d_name=at_wini d_type=101
 3 10000001 U-V---        1    71087    7  name=VM1 vmid=1 size=16128 tokens=0 boot_bm=55555555
        bootprog=bootprog_path
        bootimage=/boot/MYMINIX.img
		
		
		
		
		
			
 -------------------------------------------------------------------------------------------------------------------------
			
minor= parametro de configuracion del vmm.cfg. Base para el calculo de peticiones.
virt_minor = valor solicitado por la peticion al at_wini
real_minor = valor resultante del calculo entre minor y virt_minor

minor:  valores válidos
	0,5,10,15		Discos diferentes
	1,6,11,16		Particiones diferentes

EN VMMCMD.C
===========
minor debe cumplir en el VMM.CFG con:
	/* 0 <= minor <= 40 */
	if ( minor < 0 ||  minor > NR_MINORS(40))
		ERROR
	/* multiplo de 5 o (multiplo de 5)+1 */
	if( minor%DEV_PER_DRIVE(5) != 0 && minor%DEV_PER_DRIVE(5) != 1 )
		ERROR

EN DRIVER.C
===========

if ( virt_minor < 128)
	if ( virt_minor < 0 ||  virt_minor > NR_MINORS(40))
		ERROR

	if ( minor%DEV_PER_DRIVE(5) == 0)
		if ( virt_minor%DEV_PER_DRIVE(5) == 0) 
			real_minor = minor;
		else
			real_minor = virt_minor;
	else /* multiplo de 1 */
		if ( virt_minor%DEV_PER_DRIVE(5) == 0) 
			real_minor = virt_minor;
		else
			real_minor = (virt_minor%DEV_PER_DRIVE(5)) + minor - 1;
else /* virt_minor > 128 */
	if( minor%DEV_PER_DRIVE(5) == 1) 	/* 1,6,11,16 */
		real_minor =  (((minor-1)/DEV_PER_DRIVE(5)) * SUB_PER_DRIVE(16)) + ((virt_minor-128)%SUB_PER_DRIVE(16)) + 128;	
	else 
		real_minor = virt_minor;

-------------------------------------------------------------------------------------------------------------------------
20150424:	
		Se mofidifico MH_ntfyvm para ver si se solucionaba el problema de inestabilidad
		SIGUE INESTABLE

machine MINIX1 {
	size		64;
#	tokens	32;
	boot_prog	"/usr/src/proxy/loadvmimg";
	boot_image  "/boot/MYMINIX.img";
	boot_bitmap 0xFFFFFFFF;
	process at_wini  PROMISCUOUS_PROC_TYPE   EXEC_LOADED   TASK_LEVEL  EXEC_NTFY;
	device  at_wini VDEV_DISK_MINOR 5;
#	process pm  REAL_PROC_TYPE  BOOT_LOADED  SERVER_LEVEL  DONOT_NTFY;
#	process fs REAL_PROC_TYPE   BOOT_LOADED  SERVER_LEVEL  DONOT_NTFY;
#	process tty	PROMISCUOUS_PROC_TYPE  BOOT_LOADED  TASK_LEVEL  BOOT_NTFY;
#	process floppy  VIRTUAL_PROC_TYPE   BOOT_LOADED  TASK_LEVEL  DONOT_NTFY;
};
	
-------------------------------------------------------------------------------------------------------------------------
20150425:	
		Se mofidificaron los archivos referentes a LOAD de la VM
			- VMM
			- VMMCMD
			- LOADVMIMG
		Ahora funciona bien F8  y SF8
		
F8: Info sobre VMs		
	vm_id vm_flags vm_endpoint vm_pid vm_size tokens/bucket vm_name
    0        3       	0      	0       0    	256/    0 	VM0
    1       11   	35638    	101   16128      0/     0 	MINIX1
	
	
Data Store (DS) contents dump. (VM0)
slot -key- flags -val_l1- -val_l2- endpoint
 0  900 U-----   131072  9986048        0
 1 210F0154 UP-T--        1       15    35638 p_vmname=MINIX1 p_nr=0 p_endpoint=0 p_flags=154 p_name=at_wini
        p_chararg=
 2 310F0101 UP--D-        1       15    35638 d_vmname=MINIX1 d_name=at_wini d_type=101
 3 10000001 UPV---        1       64    35638  v_name=MINIX1 v_vmid=1 size=64 v_endpoint=35638 v_tokens=-1
        v_bootprog=/usr/src/proxy/loadvmimg
        v_bootimage=/boot/MYMINIX.img
	
	
	!!!!!		SIGUE INESTABLE IPC !!!!!!!

-------------------------------------------------------------------------------------------------------------------------
20150427:
		AL ARRANCAR LA VM1 y tratar de cargar el /dev/c0d1p0s2 da error.
	
hdebug: name=fs vmid=1 nr=1 ep=1 FS: read_super vmid:1
SENDREC: src=fs dst=35555 source=1 type=1027 (READ) m1i1=130 ( /dev/c0d0p0s2)  m1i2=1 m1i3=1024 m1p1=400 m1p2=0 m1p3=28A4 
proc.c:582 vmid=0 nr=16 endp=35555 name=at_wini flags=8 misc=2 getf=31438 sent=27342 recv_vm=-1
proc.c:657 vmid=0 nr=16 endp=35555 name=at_wini flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1
proc.c:747 vmid=1 nr=1 endp=1 name=fs flags=0 misc=201 getf=27342 sent=0 recv_vm=1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_request rqst_vmid:1
prtmsg: proc=at_wini vmid=0 source=1 type=1027 m1i1=130 m1i2=1 m1i3=1024 m1p1=400 m1p2=0 m1p3=28A4 
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini_minor:5 <<<< LO QUE LEYO DE vmm.cfg
hdebug: name=at_wini vmid=0 nr=16 ep=35555 virt_minor:130 <<<<< A quien le pide el FS1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 real_minor:146 <<<<< Se transforma en  /dev/c0d1p0s2
hdebug: name=at_wini vmid=0 nr=16 ep=35555 do_rdwt: sys_umapvm:1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:146
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: Check disk address:1024
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer nbytes:1024
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer dv_size:0
SENDVM: src=at_wini dst=1 vmid=1 source=35555 type=68 m1i1=1 m1i2=0 m1i3=1024 m1p1=400 m1p2=0 m1p3=28A4 
proc.c:1276 vmid=1 nr=16 endp=35555 name=at_wini flags=2 misc=40 getf=0 sent=27342 recv_vm=1
proc.c:1298 vmid=0 nr=16 endp=35555 name=at_wini flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1
proc.c:1299 vmid=1 nr=1 endp=1 name=fs flags=8 misc=201 getf=35555 sent=0 recv_vm=1

SENDREC: src=fs dst=35555 source=1 type=1031 m1i1=130 m1i2=0 m1i3=0 m1p1=28A4 m1p2=400 m1p3=400 
proc.c:582 vmid=0 nr=16 endp=35555 name=at_wini flags=8 misc=2 getf=31438 sent=27342 recv_vm=-1
proc.c:657 vmid=0 nr=16 endp=35555 name=at_wini flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1
proc.c:747 vmid=1 nr=1 endp=1 name=fs flags=0 misc=201 getf=27342 sent=0 recv_vm=1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_request rqst_vmid:1
prtmsg: proc=at_wini vmid=0 source=1 type=1031 m1i1=130 m1i2=0 m1i3=0 m1p1=28A4 m1p2=400 m1p3=400 
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini_minor:5
hdebug: name=at_wini vmid=0 nr=16 ep=35555 virt_minor:130
hdebug: name=at_wini vmid=0 nr=16 ep=35555 real_minor:146
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:146
SENDVM: src=at_wini dst=1 vmid=1 source=35555 type=68 m1i1=0 m1i2=0 m1i3=0 m1p1=28A4 m1p2=400 m1p3=400 
proc.c:1276 vmid=1 nr=16 endp=35555 name=at_wini flags=2 misc=40 getf=0 sent=27342 recv_vm=1
proc.c:1298 vmid=0 nr=16 endp=35555 name=at_wini flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1
proc.c:1299 vmid=1 nr=1 endp=1 name=fs flags=8 misc=201 getf=35555 sent=0 recv_vm=1
hdebug: name=fs vmid=1 nr=1 ep=1 FS reply:-22	
	
	ERROR:
			si hago 
			# mount /dev/c0d1p0s2 /VM1
			ANTES de arrancar la VM, NO DA ERROR
			Si lo hago despues SI DA ERROR!!!
			
			En cambio 
			si hago 
			# mount /dev/c0d1p0s0 /VM1
			No da error ni antes ni despues de arrancar la VM.
-------------------------------------------------------------------------------------------------------------------------
20150429:			
		TEMA INESTABILIDAD 
			Modifique proc.c creando BuildMess_ptr y cambiando los usos que correspondan.
			de lo contrario habia una doble conversion que podia inducir a errores

		PERSISTE INESTABILIDAD VER SCREENSHOT
		PERSISTE ERROR DE minor en /dev/c0d1p0s2 de VM1

................................... ERROR DE AT_WINI .....................................................
		
SENDREC: src=fs dst=35555 source=1 type=1030(DEV_OPEN) m1i1=130 m1i2=35571 m1i3=6 m1p1=206E6570 m1p2=5F6F6877 m1p3=65 
proc.c:598 vmid=0 nr=16 endp=35555 name=at_wini flags=8 misc=2 getf=31438 sent=27342 recv_vm=-1
proc.c:673 vmid=0 nr=16 endp=35555 name=at_wini flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1
proc.c:763 vmid=1 nr=1 endp=1 name=fs flags=0 misc=201 getf=27342 sent=0 recv_vm=-1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_request rqst_vmid:1
prtmsg: proc=at_wini vmid=0 source=1 type=1030 m1i1=130 m1i2=35571 m1i3=6 m1p1=206E6570 m1p2=5F6F6877 m1p3=65 
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini_minor:5
hdebug: name=at_wini vmid=0 nr=16 ep=35555 virt_minor:130
hdebug: name=at_wini vmid=0 nr=16 ep=35555 real_minor:146
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: DEV_OPEN:146
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:146
SENDVM: src=at_wini dst=1 vmid=1 source=35555 type=68 m1i1=35571 m1i2=0 m1i3=6 m1p1=206E6570 m1p2=5F6F6877 m1p3=65

Esta es una LECTURA A MINOR=130 que funciona MAL
==================================================
SENDREC: src=fs dst=35555 source=1 type=1027(DEV_READ) m1i1=130 m1i2=1 m1i3=1024 m1p1=400 m1p2=0 m1p3=28A4 
proc.c:598 vmid=0 nr=16 endp=35555 name=at_wini flags=8 misc=2 getf=31438 sent=27342 recv_vm=-1
proc.c:673 vmid=0 nr=16 endp=35555 name=at_wini flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1
proc.c:763 vmid=1 nr=1 endp=1 name=fs flags=0 misc=201 getf=27342 sent=0 recv_vm=1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_request rqst_vmid:1
prtmsg: proc=at_wini vmid=0 source=1 type=1027 m1i1=130 m1i2=1 m1i3=1024 m1p1=400 m1p2=0 m1p3=28A4 
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini_minor:5
hdebug: name=at_wini vmid=0 nr=16 ep=35555 virt_minor:130
hdebug: name=at_wini vmid=0 nr=16 ep=35555 real_minor:146
hdebug: name=at_wini vmid=0 nr=16 ep=35555 do_rdwt: sys_umapvm:1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:146
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: Check disk address:1024
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer nbytes:1024
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer dv_size:0<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  ERROR
SENDVM: src=at_wini dst=1 vmid=1 source=35555 type=68 m1i1=1 m1i2=0 <<<< BYTES LEIDOS m1i3=1024 m1p1=400 m1p2=0 m1p3=28A4 

SENDREC: src=fs dst=35555 source=1 type=1031(DEV_CLOSE) m1i1=130 m1i2=0 m1i3=0 m1p1=28A4 m1p2=400 m1p3=400 
proc.c:598 vmid=0 nr=16 endp=35555 name=at_wini flags=8 misc=2 getf=31438 sent=27342 recv_vm=-1
proc.c:673 vmid=0 nr=16 endp=35555 name=at_wini flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1
proc.c:763 vmid=1 nr=1 endp=1 name=fs flags=0 misc=201 getf=27342 sent=0 recv_vm=1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_request rqst_vmid:1
prtmsg: proc=at_wini vmid=0 source=1 type=1031 m1i1=130 m1i2=0 m1i3=0 m1p1=28A4 m1p2=400 m1p3=400 
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini_minor:5
hdebug: name=at_wini vmid=0 nr=16 ep=35555 virt_minor:130
hdebug: name=at_wini vmid=0 nr=16 ep=35555 real_minor:146
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:146
SENDVM: src=at_wini dst=1 vmid=1 source=35555 type=68 m1i1=0 m1i2=0 m1i3=0 m1p1=28A4 m1p2=400 m1p3=400

Esta es una LECTURA A MINOR=128 que funciona BIEN
==================================================
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_request rqst_vmid:1
 prtmsg: proc=at_wini vmid=0 source=1 type=1027 m1i1=128 m1i2=1 m1i3=1024 m1p1=400 m1p2=0 m1p3=28A4 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini_minor:5
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 virt_minor:128
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 real_minor:144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 do_rdwt: sys_umapvm:1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: Check disk address:1024
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer nbytes:1024
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer dv_size:16777216
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: reinitialization:21
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer do_dma:1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: do_dma:1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: do_dma rcode:0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: return OK:1
 SENDVM: src=at_wini dst=1 vmid=1 source=35555 type=68 m1i1=1 m1i2=1024<<< BYTES LEIDOS  m1i3=1024 m1p1=400 m1p2=0 m1p3=28A4 


Cuando se hae el OPEN del MINOR=128 que funciona BIEN
=====================================================

SENDREC: src=fs dst=35555 source=1 type=1030 m1i1=128 m1i2=35559 m1i3=6 m1p1=206E6570 m1p2=5F6F6877 m1p3=65 
 proc.c:598 vmid=0 nr=16 endp=35555 name=at_wini flags=8 misc=2 getf=31438 sent=27342 recv_vm=-1
 proc.c:673 vmid=0 nr=16 endp=35555 name=at_wini flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1
 proc.c:763 vmid=1 nr=1 endp=1 name=fs flags=0 misc=201 getf=27342 sent=0 recv_vm=-1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_request rqst_vmid:1 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< VMID=1
 prtmsg: proc=at_wini vmid=0 source=1 type=1030 m1i1=128 m1i2=35559 m1i3=6 m1p1=206E6570 m1p2=5F6F6877 m1p3=65 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini_minor:5 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 virt_minor:128
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 real_minor:144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: DEV_OPEN:144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:144 -----------/dev/c0d1p0s0
 hdebug: name=tty vmid=0 nr=5 ep=5 AT-D1: multiword DMA modes sup:44
 hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: sys_umap:0
 hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: dr_transfer:0
 hdebug: name=tty vmid=0 nr=5 ep=5 AT-D1: Ultra DMA modes support:40
 hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: sys_umap:0
 hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: dr_transfer:0
 hdebug: name=tty vmid=0 nr=5 ep=5 AT-D1: Ultra DMA mode selected:34
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_identify size:16777216 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< SIZE
 do_irqctl: IRQ proc 35555, IRQ 14
 do_irqctl.c:73 vmid=0 nr=16 endp=35555 name=at_wini flags=8 misc=1 getf=-2 sent=27342 recv_vm=0
 source=35555 type=1555 m5c1= m5c2= m5i1=1 m5i2=7588 m5l1=73476 m5l2=6065 m5l3=14
 irq=14 id=2 proc_nr_e=35555 notify_id=14 policy_t=1 vmid=0

 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:5 --------------------- /dev/c0d1 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: Check disk address:0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer nbytes:2048
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer dv_size:-1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: reinitialization:21
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer do_dma:35534
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: do_dma:1
 hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: sys_umap:0
 hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: dr_transfer:0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: do_dma rcode:0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: return OK:35534

 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:144  -----------/dev/c0d1p0s0
 hdebug: name=tty vmid=0 nr=5 ep=5 AT-D1: AT driver detected :26
 hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: sys_umap:0
 hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: dr_transfer:0
 hdebug: name=tty vmid=0 nr=5 ep=5 VMware Virtual IDE Hard Drive :41
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:5 -------------- /dev/c0d1 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:5
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: Check disk address:0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer nbytes:2048
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer dv_size:-1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: reinitialization:21
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer do_dma:35534
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: do_dma:1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: do_dma rcode:0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: return OK:35534

 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:6 ----------------- /dev/c0d1p0 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::6
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::16777216
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:6
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:6
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: Check disk address:0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer nbytes:2048
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer dv_size:16777216
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: reinitialization:21
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer do_dma:35534
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: do_dma:1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: do_dma rcode:0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: return OK:35534

 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:144  -----------/dev/c0d1p0s0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::16777216
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::2
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::3
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::6
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::843055104

 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:7 ----------------- /dev/c0d1p1 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:7
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: Check disk address:0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer nbytes:2048
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer dv_size:843055104
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: reinitialization:21
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer do_dma:35534
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: do_dma:1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: do_dma rcode:0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: return OK:35534

 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:148 ------------------ /dev/c0d1p1s1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::148
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::148
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::843055104
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::148
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::2
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::148
 hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: sys_umap:0
 hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: dr_transfer:0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::3
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::6
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::2
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::-861236224

 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:8 ------------------ /dev/c0d1p2
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:8
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: Check disk address:0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer nbytes:2048
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer dv_size:-861236224
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: reinitialization:21
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer do_dma:35534
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: do_dma:1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: do_dma rcode:0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: return OK:35534

 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:152 ---------------- /dev/c0d1p2s1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::152
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::152
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::152
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::2
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::-861236224
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::152
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::3
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::6
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::3
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0

 SENDVM: src=at_wini dst=1 vmid=1 source=35555 type=68 m1i1=35559 m1i2=0 m1i3=6 m1p1=206E6570 m1p2=5F6F6877 m1p3=65 

Aparentemente la cosa es asi
En lugar de buscar en 

/dev/c0d1p0s0		144
/dev/c0d1p0s1		145
/dev/c0d1p0s2		146 
/dev/c0d1p0s3		146

Esta buscando en 
/dev/c0d1p0s0		144  +5 = DEV_PER_DRIVE
/dev/c0d1p1s1		149  +5
/dev/c0d1p2s2		154  +5 
/dev/c0d1p3s3		159  +5
   
Osea
	128 -> 144 	at_wini_minor/DEV_PER_DRIVE * SUB_PER_DRIVE 
	129 -> 149
	130 -> 154
	131 -> 159

AT_WINI.C DEBE CAMBIAR ESTO:	
		}else{ /* virt_minor > 128  SUBPATITION */
			m_ptr->DEVICE += ((at_wini_minor[rqst_vmid]/DEV_PER_DRIVE) * SUB_PER_DRIVE);
		}
POR ESTO
		}else{ /* virt_minor > 128  SUBPATITION */
			m_ptr->DEVICE +=  ((at_wini_minor[rqst_vmid]/DEV_PER_DRIVE) * SUB_PER_DRIVE) +  
						(virt_minor%NR_PARTITIONS * NR_PARTITIONS);
		}


NR_PARTITIONS	DEV_PER_DRIVE	SUB_PER_DRIVE	AT_MINOR
	4	5		16		5

VIRTUAL DEV		REAL DEV	
128	16	0	144	
129	16	4	149	
130	16	8	154	
131	16	12	159	


PROBAR PRIMERO MONTAR LOS DISCOS ANTES DE SER USADOS POR VM1
PROBAR DESMONTANDO Y SIN DESMONTAR.


.............................. INESTABILIDAD DEL KERNEL .............................................
		
INET SERVER:
	eth_write_port, eth_check_drivers, eth_restart estan todas en inet/mnx_eth.c

Quiere decir que hay algun problema entre INET y LANCE

Error al hacer INET->LANCE SENDREC
#define EDSTDIED     (_SIGN 109)  /* destination just died */ 

Se supone que en VM1 se rigen por kernel/drivers.h donde ambos estan DISABLED
   { "lance"   , DISABLED_PROC_TYPE  | EXEC_LOADED | TASK_LEVEL | DONOT_NTFY },
 { "inet"   ,	DISABLED_PROC_TYPE  | EXEC_LOADED | SERVER_LEVEL | DONOT_NTFY },


El problema a resolver es:
	1) lance realmente está muerto?
	2) inet falla al tratar de hacer un sendrec a lance?

APARENTEMENTE la respuesta es que lance muere, de lo contrario no haria un NOTIFY a INET con un nuevo nro de endpoint.
	35589
	71110
	71111

PORQUE MUERE LANCE ???

-------------------------------------------------------------------------------------------------------------------------
20150430:
	- Problema inestabilidad: Modifique proc.c pero sigue MAL
	- Problema de /dev/c0d1p0s2 en VM1: Cuando en VM0 monto las particiones del disco /dev/c0d1 entonces lo monta bien

hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_request rqst_vmid:0
hdebug: name=tty vmid=0 nr=5 ep=5 AT-D1: multiword DMA modes sup:44
hdebug: name=tty vmid=0 nr=5 ep=5 AT-D1: Ultra DMA modes support:40
hdebug: name=tty vmid=0 nr=5 ep=5 AT-D1: Ultra DMA mode selected:34
do_irqctl: IRQ proc 35555, IRQ 14
do_irqctl.c:73 vmid=0 nr=16 endp=35555 name=at_wini flags=8 misc=1 getf=-2 sent=27342 recv_vm=0
 source=35555 type=1555 m5c1= m5c2= m5i1=1 m5i2=7700 m5l1=73476 m5l2=6065 m5l3=14
 irq=14 id=2 proc_nr_e=35555 notify_id=14 policy_t=1 vmid=0
 hdebug: name=tty vmid=0 nr=5 ep=5 AT-D1: AT driver detected :26
 hdebug: name=tty vmid=0 nr=5 ep=5 VMware Virtual IDE Hard Drive :41
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device to part::5
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: style::1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: atapi::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::6
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::-1403392
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device to part::6
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: style::2
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: atapi::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 P_SUB: disk::1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 P_SUB: par::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 P_SUB: device::144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::16777216
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::843055104
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::2
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::-861236224
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::3
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::6
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::6
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::2
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::6
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::3
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0


Respecto al Ethernet
 hdebug: name=tty vmid=0 nr=5 ep=5 eth_write_port: sendrec to 355:46
 hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: sys_umap:0
 hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: dr_transfer:0
 hdebug: name=tty vmid=0 nr=5 ep=5 eth_check_drivers: got a notif:49
 hdebug: name=tty vmid=0 nr=5 ep=5 eth_check_drivers: got name: l:35
 hdebug: name=tty vmid=0 nr=5 ep=5 eth_restart: restarting eth0, :49
 do_getinfo GET_MONPARAMS lance p_vmid=0

 hdebug: name=tty vmid=0 nr=5 ep=5 eth_write_port: sendrec to 711:46
 do_getinfo GET_MONPARAMS lance p_vmid=0
 hdebug: name=tty vmid=0 nr=5 ep=5 eth_check_drivers: got a notif:49
 hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: sys_umap:0
 hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: dr_transfer:0
 hdebug: name=tty vmid=0 nr=5 ep=5 eth_check_drivers: got name: l:35
 hdebug: name=tty vmid=0 nr=5 ep=5 eth_restart: restarting eth0, :49
 do_getinfo GET_MONPARAMS lance p_vmid=0


 hdebug: name=tty vmid=0 nr=5 ep=5 eth_write_port: sendrec to 711:46
 hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: sys_umap:0
 hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: dr_transfer:0
 do_getinfo GET_MONPARAMS lance p_vmid=0
 hdebug: name=tty vmid=0 nr=5 ep=5 eth_check_drivers: got a notif:49
 hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: sys_umap:0
 hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: dr_transfer:0
 hdebug: name=tty vmid=0 nr=5 ep=5 eth_check_drivers: got name: l:35
 hdebug: name=tty vmid=0 nr=5 ep=5 eth_restart: restarting eth0, :49
 do_getinfo GET_MONPARAMS lance p_vmid=0


 -------------------------------------------------------------------------------------------------------------------------
20150501:
			AT WINI FUNCIONO para at_wini_minor=5 , pero considerar que en realidad esta es la conversion que esta haciendo
				/dev/c0d0p0s0 128 => /dev/c0d1p0s0	144
				/dev/c0d0p0s1 129 => /dev/c0d1p1s1	149
				/dev/c0d0p0s2 130 => /dev/c0d1p2s2  154
				/dev/c0d0p0s3 131 => /dev/c0d1p3s3  159
				
 		if ( at_wini_minor[rqst_vmid]%DEV_PER_DRIVE== 0) {	/* FULL DISK */
			if( virt_minor >= 128 ) {
				m_ptr->DEVICE += ( ((at_wini_minor[rqst_vmid]/DEV_PER_DRIVE) * SUB_PER_DRIVE) +
									((virt_minor-128) * NR_PARTITIONS));

-------------------------------------------------------------------------------------------------------------------------
20150502:
ATENCION:
		TANTO EL DS, IS COMO LANCE deben compilarse con make install en sus propios directorios
		
	EL problema es que cuando HARDWARE hace un 
		priv(proc_addr(proc))->s_int_pending |= (1 << hook->notify_id);
        raw_notify(HARDWARE, proc);
		
	que es equivalente a
		rcode = MH_notify(src_ptr, dst_p);
		
	pero BuildMess
	case HARDWARE:							\
		(m_ptr)->NOTIFY_ARG = priv(dst_ptr)->s_int_pending;	\
		priv(dst_ptr)->s_int_pending = 0; <<<<<<<<<<< BORRA LAS INTERRUPCIONES PENDIENTES AUN CUANDO QUEDAN 		
		
		
	POR LO TANTO LUEGO SE CAMBIO BuildMess 
	case HARDWARE:							\
		(m_ptr)->NOTIFY_ARG = priv(dst_ptr)->s_int_pending;	\
		if( priv(dst_ptr)->s_ntfy_cnt[priv(hard_ptr)->s_id] == 0) \
			priv(dst_ptr)->s_int_pending = 0;			\
		break;	
		
		
ERROR:
	SIGUE INESTABILIDAD
		
-------------------------------------------------------------------------------------------------------------------------
20150505:	
			Se encontro error en SYSTEM.C void clear_endpoint(rc)

                /* Unset pending notification bits. */
                unset_sys_bit(priv(rp)->s_notify_pending, priv(rc)->s_id);
                priv(rp)->s_ntfy_cnt[priv(rc)->s_id] = 0; /* itinialize notify pending count */	<<<<<<<< 
				
ERROR:
	SIGUE INESTABILIDAD	
			SIN TCP ES ESTABLE
			PERO LA VM1 SE QUEDA COLGADA EN CMOS
			VM0 SIGUE FUNCIONANDO
			EL F12 DEL IS FUNCIONA MAL - NO PRESENTA INFO DE LA VM1 O PRESENTA INFO ERRONEA
			
-------------------------------------------------------------------------------------------------------------------------
20150614:	

LANCE recibio un mensaje de INET
hdebug: name=lance vmid=0 nr=50 ep=35589 lance receive(ANY, &m):0
lance src_dst_e=31438 function=2 RECEIVE source=35589 type=2057 m1i1=0 m1i2=35596 m1i3=72 m1p1=0 m1p2=0 m1p3=4BC70
lance src_dst_e=35596 function=6 PRTMSG source=35589 type=2055 m1i1=0 m1i2=35596 m1i3=337124 m1p1=C m1p2=0 m1p3=56AD8
prtmsg: proc=lance vmid=0 source=35596 type=2055 m1i1=0 m1i2=35596 m1i3=337124 m1p1=C m1p2=0 m1p3=56AD8 


lance src_dst_e=35596 function=5 HDEBUG source=35589 type=1851878432 m1i1=1952408931 m1i2=543912801 m1i3=1600990829 m1p1=72756F73 m1p2=6563 m1p3=0 
hdebug: name=lance vmid=0 nr=50 ep=35589  lance_task m.m_source:35596
lance src_dst_e=2055 function=5 HDEBUG source=35589 type=1851878432 m1i1=1952408931 m1i2=543912801 m1i3=1600990829 m1p1=65707974 m1p2=0 m1p3=0 
hdebug: name=lance vmid=0 nr=50 ep=35589  lance_task m.m_type:2055

LANCE-sys_memset->SYSTASK
lance src_dst_e=-2 function=3 SENDREC source=35589 type=1555 SYS_MEMSET m1i1=4 m1i2=0 m1i3=1830841203 m1p1=745F6D2E m1p2=657079 m1p3=6 

LANCE-get_procnr->PM
lance src_dst_e=0 function=3 SENDREC source=35589 type=80  GETPROCNR m1i1=-1 m1i2=4 m1i3=-2 m1p1=B90 m1p2=1068 m1p3=1068 

hdebug: name=tty vmid=0 nr=5 ep=5 RS:status request to 35589:27
rs src_dst_e=35589 function=4source=2 type=4 m1i1=40700 m1i2=0 m1i3=5 m1p1=4 m1p2=6ACE m1p3=4 
proc.c:915 vmid=0 nr=50 endp=35589 name=lance flags=C misc=1 getf=0 sent=0 recv_vm=0   < SENDING | RECEIVING FROM PM
proc.c:1093 vmid=0 nr=50 endp=35589 name=lance flags=C misc=1 getf=0 sent=0 recv_vm=0
hdebug: name=tty vmid=0 nr=5 ep=5 RS:status request to 35565:27
hdebug: name=tty vmid=0 nr=5 ep=5 RS:status request to 35567:27
hdebug: name=tty vmid=0 nr=5 ep=5 RS: service 35589 reported lat:32
		
-------------------------------------------------------------------------------------------------------------------------
20150618:			
		En el script /usr/etc/rc se discrimina el arranque de networking segun sea MHYPER o MINIX
	
El /etc/rc hace 	
    up cmos -dev /dev/cmos -period 5HZ
    echo .

    # Try to read the hardware real-time clock, otherwise do it manually.
    readclock || intr date -q
Se esta clavando en readclock porque el FS no le responde
Jun 18 20:54:09 192 kernel:  readclo  14/08 -41/08      1    66     36K --R--- fs 
Jun 18 20:54:37 192 kernel:  fs       14/32 05/32    747     0   4956K --R---  ANY	

READCLOCK-OPEN->FS	
SENDREC: src=readclo dst=1 source=35568 type=5 m1i1=10 m1i2=0 m1i3=244 m1p1=7665642F m1p2=6F6D632F m1p3=73 
proc.c:737 vmid=1 nr=1 endp=1 name=fs flags=0 misc=200 getf=27342 sent=0 recv_vm=-1
proc.c:801 vmid=1 nr=29 endp=35568 name=readclo flags=0 misc=401 getf=0 sent=27342 recv_vm=1
hdebug: name=fs vmid=1 nr=1 ep=1 FS2 get_work who_e:35568
hdebug: name=fs vmid=1 nr=1 ep=1 FS2 get_work call_nr:5
hdebug: name=fs vmid=1 nr=1 ep=1 FS: dev_open dev:4352
hdebug: name=fs vmid=1 nr=1 ep=1 FS: dev_open who_e:35568

FS-DEV_OPEN->CMOS
SENDREC: src=fs dst=35567 source=1 type=1030(0x406) m1i1=0 m1i2=35568 m1i3=4 m1p1=206E6570 m1p2=5F6F6877 m1p3=65 
proc.c:632 vmid=0 nr=28 endp=35567 name=cmos flags=8 misc=2 getf=31438 sent=27342 recv_vm=-1
proc.c:710 vmid=0 nr=28 endp=35567 name=cmos flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1
proc.c:801 vmid=1 nr=1 endp=1 name=fs flags=0 misc=201 getf=27342 sent=0 recv_vm=-1

CMOS->TASK_REPLY->FS
SENDVM: src=cmos dst=1 vmid=1 source=35567 type=68 m1i1=35568 m1i2=0 m1i3=5 m1p1=73 m1p2=4E455F4F m1p3=545044 
proc.c:1358 vmid=1 nr=28 endp=35567 name=cmos flags=2 misc=40 getf=0 sent=27342 recv_vm=1
proc.c:1380 vmid=0 nr=28 endp=35567 name=cmos flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1
proc.c:1381 vmid=1 nr=1 endp=1 name=fs flags=8 misc=201 getf=35567 sent=0 recv_vm=1
hdebug: name=fs vmid=1 nr=1 ep=1 FS reply:3 <<<< FILE_HANDLE

FS->FILE_HANDLE->READCLOCK
SEND: src=fs dst=35568 source=1 type=3 m1i1=3 m1i2=4 m1i3=0 m1p1=0 m1p2=0 m1p3=0 
proc.c:737 vmid=1 nr=29 endp=35568 name=readclo flags=0 misc=400 getf=27342 sent=27342 recv_vm=-1
 ...........................................................
		
READCLOCK-IOCTL->FS		
SENDREC: src=readclo dst=1 source=35568 type=54 m1i1=3 m1i2=4 m1i3=-2147196158 m1p1=0 m1p2=0 m1p3=4F5C 
proc.c:801 vmid=1 nr=29 endp=35568 name=readclo flags=4 misc=401 getf=27342 sent=1 recv_vm=-1
hdebug: name=fs vmid=1 nr=1 ep=1 FS: get_work vmid:1
proc.c:801 vmid=1 nr=1 endp=1 name=fs flags=0 misc=200 getf=27342 sent=27342 recv_vm=1
hdebug: name=fs vmid=1 nr=1 ep=1 FS2 get_work who_e:35568
hdebug: name=fs vmid=1 nr=1 ep=1 FS2 get_work call_nr:54

FS-DEV_IOCTL->CMOS
SENDREC: src=fs dst=35567 source=1 type=1029 m1i1=0 m1i2=35568 m1i3=-2147196158 m1p1=0 m1p2=0 m1p3=4F5C 
proc.c:632 vmid=0 nr=28 endp=35567 name=cmos flags=8 misc=2 getf=31438 sent=27342 recv_vm=-1
proc.c:710 vmid=0 nr=28 endp=35567 name=cmos flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1
proc.c:801 vmid=1 nr=1 endp=1 name=fs flags=0 misc=201 getf=27342 sent=27342 recv_vm=1
hdebug: name=cmos vmid=0 nr=28 ep=35567 CMOS: DEV_IOCTL IO_ENDPT:35568

CMOS->TASK_REPLY->FS
SENDVM: src=cmos dst=1 vmid=1 source=35567 type=68 m1i1=35568 m1i2=-998 m1i3=1129269599 m1p1=49204C54 m1p2=4E455F4F m1p3=545044 
proc.c:1368 vmid=1 nr=28 endp=35567 name=cmos flags=2 misc=40 getf=0 sent=27342 recv_vm=1
proc.c:1390 vmid=0 nr=28 endp=35567 name=cmos flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1
proc.c:1391 vmid=1 nr=1 endp=1 name=fs flags=8 misc=201 getf=35567 sent=0 recv_vm=1

CMOS->NOTIFY->FS
NOTIFYVM: src=cmos dst=1 vmid=1 
MH_ntfyvm src=cmos dst=1 flags=0 dst_vmid=1
proc.c:1715 vmid=1 nr=28 endp=35567 name=cmos flags=2 misc=40 getf=0 sent=27342 recv_vm=1
proc.c:1716 vmid=1 nr=1 endp=1 name=fs flags=0 misc=200 getf=27342 sent=0 recv_vm=-1
MH_ntfyvm dst=fs src=cmos >>>>>>>>>>>> src_id=26486<<<<<< ntfy_cnt=1

hdebug: name=fs vmid=1 nr=1 ep=1 FS: get_work vmid:1
proc.c:801 vmid=1 nr=1 endp=1 name=fs flags=0 misc=200 getf=27342 sent=0 recv_vm=-1
proc.c:832 vmid=1 nr=1 endp=1 name=fs flags=0 misc=200 getf=27342 sent=0 recv_vm=-1
proc.c:833 s_proc_nr=1 s_id=6 s_flags=12 s_nr_irq=0 s_vmid=1 s_vm_bitmap=2 s_dr_bitmap=0
proc.c:898 vmid=1 nr=1 endp=1 name=fs flags=0 misc=200 getf=27342 sent=0 recv_vm=-1
		
-------------------------------------------------------------------------------------------------------------------------
20150619:


RS->NOTIFY->LANCE
 prtmsg: proc=lance vmid=0 source=2 type=4102 m1i1=0 m1i2=0 m1i3=1 m1p1=0 m1p2=800 m1p3=0 

LANCE RECEIVE
 hdebug: name=lance vmid=0 nr=53 ep=35592  lance_task m.m_source:2
 hdebug: name=lance vmid=0 nr=53 ep=35592  lance_task m.m_type:4102

LANCE-NOTIFY->RS
 dst=rs src=lance src_id=19 ntfy_cnt=1
 hdebug: name=lance vmid=0 nr=53 ep=35592 lance: after sys_irqenable:0
 hdebug: name=lance vmid=0 nr=53 ep=35592 lance: after sys_irqenable:0
 hdebug: name=lance vmid=0 nr=53 ep=35592 lance receive(ANY, &m):0
 proc.c:833 s_proc_nr=53 s_id=19 s_flags=12 s_nr_irq=0 s_vmid=0 s_vm_bitmap=1 s_dr_bitmap=0
 proc.c:833 s_proc_nr=2 s_id=7 s_flags=12 s_nr_irq=0 s_vmid=0 s_vm_bitmap=1 s_dr_bitmap=0
 dst=rs src=53 src_id=19 ntfy_cnt=0

LANCE RECEIVE 
prtmsg: proc=lance vmid=0 source=35599 type=2055 m1i1=0 m1i2=35599 m1i3=0 m1p1=0 m1p2=C3F70 m1p3=1C617 
hdebug: name=lance vmid=0 nr=53 ep=35592  lance_task m.m_source:35599
hdebug: name=lance vmid=0 nr=53 ep=35592  lance_task m.m_type:2055

RS-NOTIFY->LANCE
hdebug: name=tty vmid=0 nr=5 ep=5 RS:status request to 35592:27
proc.c:927 vmid=0 nr=53 endp=35592 name=lance flags=8 misc=1 getf=35550 sent=27342 recv_vm=0
proc.c:1105 vmid=0 nr=53 endp=35592 name=lance flags=8 (RECEIVING) misc=1 (REPLY_PENDING) getf=35550 sent=27342 recv_vm=0

dst=lance src=rs src_id=7 ntfy_cnt=1

hdebug: name=tty vmid=0 nr=5 ep=5 RS: service 35592 reported lat:32

PREGUNTA: Porque LANCE esta en estado REPLY_PENDING si no hizo ningun SENDREC?????????????????

-------------------------------------------------------------------------------------------------------------------------
20150623:

LANCE->sendrec->PM
lance src_dst_e=0 function=3 source=35592 type=80 (GETPROCNR) m1i1=-1 m1i2=4 m1i3=-2 m1p1=B90 m1p2=1068 m1p3=1068

RS->notify->LANCE 
proc.c:935 vmid=0 nr=53 endp=35592 name=lance flags=C misc=1 getf=0 sent=0 recv_vm=0
proc.c:1114 vmid=0 nr=53 endp=35592 name=lance flags=C misc=1 getf=0 sent=0 recv_vm=0
MH_notify dst=lance src=rs src_id=7 ntfy_cnt=1

OBVIAMENTE COMO PM NO LE RESPONDIO (NI SIQUIERA RECIBIO EL MENSAJE) VENCE EL TEMPORIZADOR DE RS

hdebug: name=tty vmid=0 nr=5 ep=5 RS: service 35592 reported lat:32

Pero aun asi no funciona. Lo ultimo que le ocurre al PM es esto:
MH_notify dst=pm src=clock src_id=2 ntfy_cnt=1

HAY ALGUN TIPO DE DEADLOCK:
===========================
1)LANCE espera de PM GETPROCNR
	lance src_dst_e=0 function=3 source=35592 type=80 GETPROCNR m1i1=-1 m1i2=4 m1i3=-2 m1p1=B90 m1p2=1068 m1p3=1068
2) PM espera de FS
3) FS espera de INET
4)INET espera de LANCE DL_INIT
	src=inet dst=lance source=35599 type=2055 (DL_INIT) m1i1=0 m1i2=35599 m1i3=337148 m1p1=C m1p2=0 m1p3=56AD8 

MODIFICACION REALIZADA:
Cuando el RS no recibe una respuesta de un proceso, antes de matarlo verifica si esta esperando una respuesta de alguien en particular
Ademas verifica que no haya un DEADLOCK


-------------------------------------------------------------------------------------------------------------------------
20150624:

if((eth_tasknr=getprocnr()) < 0)
	panic("lance","couldn't get own proc nr", i);
_mhdebug("lance: eth_tasknr",eth_tasknr)

		hdebug: name=lance vmid=0 nr=53 ep=35592 lance: lance_task main:0
		lance src_dst_e=0 function=3 source=35592 type=80 m1i1=-1 m1i2=0 m1i3=0 m1p1=0 m1p2=5930 m1p3=EFBC 
		src=pm dst=lance source=0 type=0 m1i1=35592 m1i2=2 m1i3=0 m1p1=0 m1p2=0 m1p3=5930 
		hdebug: name=lance vmid=0 nr=53 ep=35592 lance: eth_tasknr:35592
		
-------------------------------------------------------------------------------------------------------------------------
20150706:
			Hice cambios en cuanto al comportamiento del recvvm y receive
			habilite si el recvvm espera recibir mensajes de la VM0
			aunque es casi identico a un receive() en realidad tiene q prender algunos flags.
!!!!!!!!!	LA EJECUCION DE LA VM1 es perfecta si no se levanta networking en VM0 !!!!!!!!!!!!111
		

LANCE (receive)->PM 		
lance src_dst_e=0 function=3 source=35592 type=80 m1i1=-1 m1i2=4 m1i3=5555 m1p1=B90 m1p2=29EF m1p3=FFFFFFFE 
PM (sendrec)->FS
FS (receive) ->INET
INET (receive)->LANCE
		
ATENCION:		EL PROBLEMA PUEDE DARSE QUE EL NOTIFY DE UNA VMX A UN PROMISCUO ES AHORA BLOQUEANTE 
				Por lo tanto antes no se consideraba la posibilidad de DEADLOCK y ahora SI PUEDE HABER deadlock

-------------------------------------------------------------------------------------------------------------------------
20150708:

Se inserto debug de LANCE en proc.c raw_notify();
y la forma en que se detecta LANCE 
Se agrego a los mensajes de NOTIFY
	(m_ptr)->NOTIFY_COUNT = priv(dst_ptr)->s_ntfy_cnt[priv(src_ptr)->s_id] 

POR CUESTIONES DE VERIFICACION VER QUE;:
                               if (dst_ptr->p_misc_flags & PROMICUOUS_TASK) {
									dst0_ptr = dst_ptr->p_promiscuous;
									MHASSERT( (dst0_ptr == proc_addr_vm(VM0, dst_p)));  TEMPORARIO 
                               }


-------------------------------------------------------------------------------------------------------------------------
20150709:

 WARNING WARNINGWARNING WARNINGWARNING WARNINGWARNING WARNINGWARNING WARNINGWARNING WARNINGWARNING WARNINGWARNING WARNING
 
 Posible problema con los procesos de sistema (lance, PCI, AT_WINI, etc) que son modificados para ejecutar con MHYPER
 Cuando el sistema arranca con MINIX tradicional NO FUNCIONARAN LA IPC !!!!

 Solucion:
	En funcion de la version de kernel debe poder ejecutar una primitiva u otra !!!
 
 SOLUCION EN CASO DE QUE NO FUNCIONE MINIX:
    1-  bootear con un DISCO de MINIX tradicional y montar el MHYPER para modificarlo 

 Se creo sys_mhyper() que retorna TRUE si se ejecuta en MHYPER 	
 
USAGE:
	int mhyper;
	
	mhyper = is_mhyper();
	.....
	if( mhyper) {
		recvvm(ANY, &m, ANY_VM);
	}else{
		receive(ANY, &m);
	}
	
EJEMPLO DE USO:
	Se cambio el IS para probar su funcionamiento:

	
PROBLEMA; AHORA DA MEMORY DUMP TANTO CON MINIX COMO CON MHYPER 
HAY QUE USAR OTRO DISCO.!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!111111

-------------------------------------------------------------------------------------------------------------------------
20150718:
	Generacion de un disco para EMERGENCIAS
		Esta compuesto de la version mhyper-20150705.tar.Z 
		y se le agregaron algunas modificiones 
include\minix 
	com.h 
kernel\proc.c 



usr\etc\rc
is\glo.h
is\inc.h
syslib.h
type.h
lib\syslib\
	sys_mhyper.c 
	Makefile

ERROR:
	hdebug: name=fs vmid=1 nr=1 ep=1 FS: dev_open dev:4096
	hdebug: name=fs vmid=1 nr=1 ep=1 FS: dev_open who_e:35589
	SENDREC: src=fs dst=35588 source=1 type=1030 m1i1=0 m1i2=35589 m1i3=578 m1p1=206E6570 m1p2=5F6F6877 m1p3=65 
	ASSERT proc.c:648 Kernel panic: proc.c 648
	MINIX will now be shut down ...
	proc.c:651 vmid=0 nr=44 endp=35583 name=random flags=8 misc=2 getf=31438 sent=27342 recv_vm=-1
	proc.c:737 vmid=0 nr=44 endp=35583 name=random flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1
	proc.c:833 vmid=1 nr=1 endp=1 name=fs flags=0 misc=201 getf=27342 sent=0 recv_vm=-1
	
-------------------------------------------------------------------------------------------------------------------------
20150719:	
	
	LA VM1 FUE PERFECTA.


-------------------------------------------------------------------------------------------------------------------------
20150723:
		Se documento y modifico el codigo de proc.c hasta MH_receive()
		SE CUELGA CON LAS MODIFICACIONES!!!
		
		exception proc=0 name= vmid=0 running_vm=0 vec_nr=13 sp=0 General protection
		cause_sig: proc_nr=0, sig_nr=11 running_vm=0


	ATENCION:	Con la version toqueteada de lance.c funciona mal incluso al cargar con MINIX original
			El tema se debe a que lance se instal y compila al hacer make world

TODO:
				Comparar los proc.c 

-------------------------------------------------------------------------------------------------------------------------
20150724:
		Se volvio atras con los cambios en proc.c y funciono
		se hability sys_mhyper() y funciono.
		
ESTRATEGIA:
==========
		Todos los programas del sistema (at_wini, is, inet, lance,etc) que se cargan
		por exec/service se modificaran de la siguiente forma

#ifdef MHYPER
	if( sys_mhyper) 
		CODIGO MHYPER
	else
#endif /*MHYPER*/
	CODIGO MINIX

-------------------------------------------------------------------------------------------------------------------------
20150725:
	Se modifico IS para que soporte ejecución en MINIX y MHYPER
		Funcionan BIEN en MINIX:
			F3- System image
			SF5- Print key mappings
			F5- Boot monitor parameters
			F6- IRQ hooks and policies
			F9- Scheduling queues
			F10- Kernel parameters
			
		Funcionan MAL en MINIX:
			F1- Kernel process table: La estructura de proceso en MINIX no coincide con MHYPER
			F2- Process memory maps: IDEM
			F4- Process privileges: IDEM
		
VERSION QUE FUNCIONA PERFECTAMENTE MHYPER SIN RED!!!!

IS:			ARRANCADA LA VM1
			De F1 a F11 funcionan perfectamente
			SF1, SF2, SF3, SF4, SF6, SF7 no funcionan
	
SE REHABILITO SENDRECVM!!!!!
			Lo usa el IS.
			
IS->PM	SENDRECVM		m.m1_p1 = where;
SENDRECVM: src=is dst=0 vmid=1 source=35565 type=79 m1i1=2 m1i2=0 m1i3=2147483647 m1p1=28AAC m1p2=20 m1p3=1 
proc.c:1546 vmid=1 nr=26 endp=35565 name=is flags=2 misc=40 getf=0 sent=27342 recv_vm=1
proc.c:1582 vmid=1 nr=0 endp=0 name=pm flags=0 misc=200 getf=27342 sent=27342 recv_vm=-1
proc.c:1612 vmid=0 nr=26 endp=35565 name=is flags=4 misc=3 getf=27342 sent=0 recv_vm=-1

PM receive()
hdebug: name=pm vmid=1 nr=0 ep=0 get_work vmid:1
proc.c:900 vmid=1 nr=0 endp=0 name=pm flags=0 misc=200 getf=27342 sent=27342 recv_vm=-1
MH_notify dst=pm src=clock src_id=2 ntfy_cnt=1
hdebug: name=pm vmid=1 nr=0 ep=0 PM get_work who_e:35565
hdebug: name=pm vmid=1 nr=0 ep=0 PM get_work call_nr:79

PM->SYSTASK vcopy()
SENDREC: src=pm dst=-2 source=0 type=1551 m1i1=65537 m1i2=35534 m1i3=35565 m1p1=CA7C m1p2=28AAC m1p3=C1C0 
proc.c:822 vmid=1 nr=-2 endp=-2 name=system flags=0 misc=0 getf=27342 sent=0 recv_vm=-1
proc.c:900 vmid=1 nr=0 endp=0 name=pm flags=0 misc=201 getf=27342 sent=27342 recv_vm=-1
PROMICUOUS_TASK virtual_copy[1] ep=35565 proc_nr=26 bytes=49600
system.c:702 vmid=0 nr=26 endp=35565 name=is flags=8 misc=3 getf=0 sent=27342 recv_vm=1
mem_vir=0 mem_phys=7A3 mem_len=5 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
ERROR system.c:705: SYSTEM: virtual_copy: dst proc limits:-14
proc.c:822 vmid=1 nr=0 endp=0 name=pm flags=0 misc=200 getf=27342 sent=27342 recv_vm=-1
proc.c:900 vmid=1 nr=-2 endp=-2 name=system flags=0 misc=0 getf=27342 sent=0 recv_vm=-1
hdebug: name=pm vmid=1 nr=0 ep=0 PM setreply:-14

PM->IS
SEND: src=pm dst=35565 source=0 type=-14 m1i1=35555 m1i2=1 m1i3=0 m1p1=0 m1p2=0 m1p3=5900 
proc.c:677 vmid=0 nr=26 endp=35565 name=is flags=8 misc=3 getf=0 sent=27342 recv_vm=1
proc.c:786 vmid=0 nr=26 endp=35565 name=is flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1
hdebug: name=is vmid=0 nr=26 ep=35565 IS getsysinfo_vm PM_PROC_NR:0

--------------------------------
IDEM CON FS
IS->FS
SENDRECVM: src=is dst=1 vmid=1 source=35565 type=79 m1i1=2 m1i2=0 m1i3=48 m1p1=34C6C m1p2=1 m1p3=A 
proc.c:1546 vmid=1 nr=26 endp=35565 name=is flags=2 misc=40 getf=0 sent=27342 recv_vm=1
proc.c:1566 vmid=0 nr=26 endp=35565 name=is flags=0 misc=3 getf=27342 sent=27342 recv_vm=-1
proc.c:1567 vmid=1 nr=1 endp=1 name=fs flags=8 misc=200 getf=31438 sent=27342 recv_vm=1

FS receive()
hdebug: name=fs vmid=1 nr=1 ep=1 FS2 get_work who_e:35565
hdebug: name=fs vmid=1 nr=1 ep=1 FS2 get_work call_nr:79
SENDREC: src=fs dst=-2 source=1 type=1551 m1i1=65537 m1i2=35534 m1i3=35565 m1p1=6040 m1p2=34C6C m1p3=47E0 
proc.c:822 vmid=1 nr=-2 endp=-2 name=system flags=0 misc=0 getf=27342 sent=0 recv_vm=-1
proc.c:900 vmid=1 nr=1 endp=1 name=fs flags=0 misc=201 getf=27342 sent=27342 recv_vm=1
PROMICUOUS_TASK virtual_copy[1] ep=35565 proc_nr=26 bytes=18400
system.c:702 vmid=0 nr=26 endp=35565 name=is flags=8 misc=3 getf=1 sent=27342 recv_vm=1
mem_vir=0 mem_phys=7A3 mem_len=5 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
ERROR system.c:705: SYSTEM: virtual_copy: dst proc limits:-14
proc.c:822 vmid=1 nr=1 endp=1 name=fs flags=0 misc=200 getf=27342 sent=27342 recv_vm=-1
proc.c:900 vmid=1 nr=-2 endp=-2 name=system flags=0 misc=0 getf=27342 sent=0 recv_vm=-1
hdebug: name=fs vmid=1 nr=1 ep=1 FS reply:-14

FS->IS
SEND: src=fs dst=35565 source=1 type=-14 m1i1=4 m1i2=5 m1i3=0 m1p1=F0 m1p2=0 m1p3=0 
proc.c:677 vmid=0 nr=26 endp=35565 name=is flags=8 misc=3 getf=1 sent=27342 recv_vm=1
proc.c:786 vmid=0 nr=26 endp=35565 name=is flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1
hdebug: name=tty vmid=0 nr=5 ep=5 File System (FS) process table:43


---------------------------------------------------------
IDEM  RS???
SENDRECVM: src=is dst=2 vmid=1 source=35565 type=79 m1i1=2 m1i2=9162752 m1i3=67096576 m1p1=3964C m1p2=0 m1p3=0 
proc.c:1546 vmid=1 nr=26 endp=35565 name=is flags=2 misc=40 getf=0 sent=27342 recv_vm=1
proc.c:1566 vmid=0 nr=26 endp=35565 name=is flags=0 misc=3 getf=27342 sent=27342 recv_vm=-1
proc.c:1567 vmid=1 nr=2 endp=2 name=rs flags=8 misc=200 getf=31438 sent=27342 recv_vm=1

SENDREC: src=rs dst=-2 source=2 type=1551 m1i1=65537 m1i2=35534 m1i3=35565 m1p1=D50 m1p2=3964C m1p3=4900 
proc.c:822 vmid=1 nr=-2 endp=-2 name=system flags=0 misc=0 getf=27342 sent=0 recv_vm=-1
proc.c:900 vmid=1 nr=2 endp=2 name=rs flags=0 misc=201 getf=27342 sent=27342 recv_vm=1
PROMICUOUS_TASK virtual_copy[1] ep=35565 proc_nr=26 bytes=18688
system.c:702 vmid=0 nr=26 endp=35565 name=is flags=8 misc=3 getf=2 sent=27342 recv_vm=1
mem_vir=0 mem_phys=7A3 mem_len=5 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
ERROR system.c:705: SYSTEM: virtual_copy: dst proc limits:-14
proc.c:822 vmid=1 nr=2 endp=2 name=rs flags=0 misc=200 getf=27342 sent=27342 recv_vm=-1
proc.c:900 vmid=1 nr=-2 endp=-2 name=system flags=0 misc=0 getf=27342 sent=0 recv_vm=-1
SEND: src=rs dst=35565 source=2 type=-14 m1i1=1 m1i2=235084 m1i3=18688 m1p1=FFFFFFF2 m1p2=4900 m1p3=8AED 
proc.c:677 vmid=0 nr=26 endp=35565 name=is flags=8 misc=3 getf=2 sent=27342 recv_vm=1
proc.c:786 vmid=0 nr=26 endp=35565 name=is flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1

ATENCION!!!!!!!!!!!!!!!!!! AMBAS DIRECCIONES SON IDENTICAS!!! ERROR
mem_vir=0 mem_phys=7A3 mem_len=5

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
		Y si el IS no se hace PROMISCUO y se hace REAL ????
Se hizo la prueba
	El problema es que habria q cambiar el tipo de procesos	
		El resultado lo tira en la CONSOLA de VM0 siempre
		se crearon 
			kernel/mnx_proc.h
			kernel/mnx_priv.h
			ds/mnx_store.h
			
	SE GUARDO UNA VERSION CON IS REAL PERO ESTA INCOMPLETA
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
	
-------------------------------------------------------------------------------------------------------------------------
20150726:
		Tratando de encontrar errores entre el IS y los servidores en el uso de getsysinfo_vm y de la copia de datos.
		
		Se modifico KERNEL.C (MH_receive)
		
IS->PM  GETSYSINFO
SENDRECVM: src=is dst=0 vmid=1 source=35565 type=79 m1i1=2 m1i2=0 m1i3=2147483647 m1p1=28AAC m1p2=20 m1p3=1 
proc.c:1561 vmid=1 nr=26 endp=35565 name=is flags=2 misc=40 getf=0 sent=27342 recv_vm=1
proc.c:1597 vmid=1 nr=0 endp=0 name=pm flags=0 misc=200 getf=27342 sent=27342 recv_vm=-1
proc.c:1627 vmid=0 nr=26 endp=35565 name=is flags=4 misc=3 getf=27342 sent=0 recv_vm=-1

PM receive()	
hdebug: name=pm vmid=1 nr=0 ep=0 get_work vmid:1
proc.c:900 vmid=1 nr=0 endp=0 name=pm flags=0 misc=200 getf=27342 sent=27342 recv_vm=-1
src_ep=35565 srcX_ep=35565
hdebug: name=pm vmid=1 nr=0 ep=0 PM get_work who_e:35565
hdebug: name=pm vmid=1 nr=0 ep=0 PM get_work call_nr:79

PM->SYSTASK vcopy
SENDREC: src=pm dst=-2 source=0 type=1551 m1i1=65537 m1i2=35534 m1i3=35565 m1p1=CB0C m1p2=28AAC m1p3=C1C0 
proc.c:822 vmid=1 nr=-2 endp=-2 name=system flags=0 misc=0 getf=27342 sent=0 recv_vm=-1
proc.c:900 vmid=1 nr=0 endp=0 name=pm flags=0 misc=201 getf=27342 sent=27342 recv_vm=-1
PROMICUOUS_TASK virtual_copy[1] ep=35565 proc_nr=26 bytes=49600
DST=35565 vmid=0 offset=28AAC (166572)  bytes=49600 seg_type=1  TOTAL 216172
system.c:708 vmid=0 nr=26 endp=35565 name=is flags=8 misc=3 getf=0 sent=27342 recv_vm=1
mem_vir=0 mem_phys=7A8 mem_len=74 (4a)
mem_vir=0 mem_phys=7A8 mem_len=74 (4a) 303104 bytes
ERROR system.c:714: SYSTEM: virtual_copy: dst proc limits:-14  (166572 +  49600) = 216172 < 303104!!!!!! ESTA BIEN!!
proc.c:822 vmid=1 nr=0 endp=0 name=pm flags=0 misc=200 getf=27342 sent=27342 recv_vm=-1
proc.c:900 vmid=1 nr=-2 endp=-2 name=system flags=0 misc=0 getf=27342 sent=0 recv_vm=-1
hdebug: name=pm vmid=1 nr=0 ep=0 PM setreply:-14
SEND: src=pm dst=35565 source=0 type=-14 m1i1=35555 m1i2=1 m1i3=0 m1p1=0 m1p2=0 m1p3=5900 
proc.c:677 vmid=0 nr=26 endp=35565 name=is flags=8 misc=3 getf=0 sent=27342 recv_vm=1
proc.c:786 vmid=0 nr=26 endp=35565 name=is flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1
hdebug: name=is vmid=0 nr=26 ep=35565 IS getsysinfo_vm PM_PROC_NR:0


								TEXT			DATA		STACK
 26 is        3565  69f18    0  7a3    5    0  7a8   4a   69  811    1   444K

 ERROR GROSSS DETECTADO EN SYSTEM.C
 #define FAULT_PROC_LIMITS(a,p,s) 	 ((a < (p->p_memmap[D].mem_phys<<CLICK_SHIFT)) ||\
	    (a > ((p->p_memmap[D].mem_phys+p->p_memmap[D].mem_len)<<CLICK_SHIFT)) ||  	\
	    ((a+s) > ((p->p_memmap[D].mem_phys+p->p_memmap[D].mem_len)<<CLICK_SHIFT))
		
 Se comparaba BYTES vs CLICKS!!
 
	Se probo la maquina virtual MINIX2 que bootea con /boot/image_big y funciono OK
 
TODO:	
		Funcionan MAL en MINIX:
			F1- Kernel process table: La estructura de proceso en MINIX no coincide con MHYPER
			F2- Process memory maps: IDEM
			F4- Process privileges: IDEM
		
		Incorporar estructuras necesarias y referirlas desde el IS.
		es decir en proc.h incluir 
#ifdef FOR_IS
struct mnx_proc {
	/* estructura original de minix */
}
#endif /*FOR_IS */

-------------------------------------------------------------------------------------------------------------------------
20150802:
		Por fin anduvo CMOS!!!
		Fue probado con :
			opcion 1: es un MINIX pero tiene alguna truchada
			ESC: image=/boot/image/3.1.2a imagen original de MINIX
			opcion 3: MHYPER 
				funciono bien la VM1
				
-------------------------------------------------------------------------------------------------------------------------
20150808:
		Se modificaron AT_WINI y PCI

		AT_WINI esta presentando algun tipo de problemas cuando arranca la VM1
		Envia un mensaje TASK_REPLY	  68 al VMM !!!!	

PM1->SYSTASK exec(at_wini) 
SENDREC: src=pm dst=-2 source=0 type=1537 m1i1=35555 m1i2=26990 m1i3=0 m1p1=11FE0 m1p2=1919 m1p3=0 
proc.c:822 vmid=1 nr=-2 endp=-2 name=system flags=0 misc=0 getf=27342 sent=0 recv_vm=-1
proc.c:900 vmid=1 nr=0 endp=0 name=pm flags=0 misc=201 getf=27342 sent=27342 recv_vm=-1
do_exec: in vmid=1 proc=16
do_exec: driver found at_wini type=154
do_exec: process at_wini MATCH on VM0 p_nr0=16 p_nrX=16
do_exec: in at_wini(VM0) exec:at_wini p_nrX=16
VMM->AT_WINI notify
do_exec: notifying at_wini type=154
do_exec: notifying 16

SYSTASK->PM reply
proc.c:822 vmid=1 nr=0 endp=0 name=pm flags=0 misc=200 getf=27342 sent=27342 recv_vm=-1
proc.c:900 vmid=1 nr=-2 endp=-2 name=system flags=0 misc=0 getf=27342 sent=0 recv_vm=-1

AT_WINI ->VMM reply!!!!! NO DEBERIA 
hdebug: name=tty vmid=0 nr=5 ep=5 VMM mtype=68:13
hdebug: name=tty vmid=0 nr=5 ep=5 VMM source=35555 type=68 m1i1=:72
hdebug: name=tty vmid=0 nr=5 ep=5 ERROR main.c:100: :18
hdebug: name=tty vmid=0 nr=5 ep=5 VMM got invalid call:21
hdebug: name=tty vmid=0 nr=5 ep=5 VMM mtype=68:13

-------------------------------------------------------------------------------------------------------------------------
20150809:
		Se modificaron AT_WINI		
	
ERROR:
		Booteando con 1 funciona bien
		Booteando con 3 se cuelga 


-------------------------------------------------------------------------------------------------------------------------
20151103:
Todo proceso (en VMx) tiene un bitmap de aquellas KERNEL CALLS que debe enviar al PROXY en lugar de a la SYSTASK (por 
default ninguno.). En kernel/priv.h)
	unsigned long s_call2proxy; /* signal what kernel calls are redirected to VM proxy		*/
Este campo se inicializa en kernel/main.c para todos los procesos 
Se limpian los campos variables de los privilegios en kernel/system/do_vmmreq.c


Se agrego un flag adicional que indique PARAVIRTUAL en minix/com.h 
#define  PARAVIRTUAL 0x1000		/* Only valid for REAL process types 	*/

y en kernel/proc.h para p_misc_flag
#define  PARAVIR_TASK 0x1000		/* Only valid for REAL process types 	*/	

En kernel/drivers.h
 { "printer"   ,REAL_PROC_TYPE | EXEC_LOADED | TASK_LEVEL | DONOT_NTFY  | PARAVIRTUAL  },	


Tambien se cambio en la interpretación del archivo de configuracion en test/vmmcmd.c
#define NR_PTYPE	5
flag_t proc_type[] = {
	{"DISABLED_PROC_TYPE",DISABLED_PROC_TYPE},
	{"REAL_PROC_TYPE",REAL_PROC_TYPE},	
	{"VIRTUAL_PROC_TYPE",VIRTUAL_PROC_TYPE},
	{"PROMISCUOUS_PROC_TYPE",PROMISCUOUS_PROC_TYPE},
	{"PARAVIRTUAL_PROC_TYPE",REAL_PROC_TYPE | PARAVIRTUAL }
};

El archivo etc/vmm.cfg deberia ser algo asi
machine MINIX1{
	size 64;
	boot_prog "/usr/src/proxy/loadvmimg";
	boot_image "/boot/MYMINIX.img";
	boot_bitmap 0xFFFFFFFF;
	process at_wini  VIRTUAL_PROC_TYPE EXEC_LOADED TASK_LEVEL EXEC_NTFY;
	process printer  PARAVIRTUAL_PROC_TYPE 0x0000000F;
	device  printer  VDEV_PRT_FILE /tmp/printer.out;
};
 

Para comparar s_call2proxy  utilizar c(n) definido en kernel/table.c
#define c(n)	(1 << ((n)-KERNEL_CALL))
Ejemplo: El codigo de PRINTER utiliza 
  sys_inb();				=> SYS_DEVIO	
  sys_vircopy() 			=> SYS_VIRCOPY
  sys_outb();				=> SYS_DEVIO
  sys_irqsetpolicy();			=> SYS_IRQCTL
  sys_irqenable()			=> SYS_IRQCTL
  sys_datacopy()			=> SYS_VIRCOPY
  sys_voutb();				=> SYS_VDEVIO


/* Ejemplo de definicion de BM */
#define PRINTER_BM (c(SYS_DEVIO) | c(SYS_VIRCOPY) | c(SYS_VDEVIO) | c(SYS_IRQCTL) )

Se modifico proc.c en MH_send() pero solo cuando se hace sendrec() a SYSTASK.
Cuando el PRINTER envía un mensaje a la SYSTASK, se analiza (p_misc_flags) si el proceso es PARAVIRTUAL  
En este caso se analiza el bitmap s_call2proxy para ver si el kernel call es válido para redirigir.
Si es válido se redirige al proxy, y se realizan los mismos pasos que para enviar un mensaje a un PROXY.

Por otro lado el PROXY debe admitir (en sus flags) la recepcion de mensajes provenientes de este tipo de procesos en el slot 
de la SYSTASK.

DIFERENCIA entre PRINTER por PROXY y PRINTER paravirtualizado.
=============================================================
	- Printer por Proxy:  el proxy ES el driver de PRINTER.
	- Printer paravirtualizado: El Printer es REAL y solicita kernel calls a al proxy. Por lo tanto el proxy debe EMULAR a SYSTASK


-------------------------------------------------------------------------------------------------------------------------
20151108:
	Se probo at_wini sin modificar y funciona OK al menos en la VM0.
	y at_wini modificado no funciona. 
	
	Aparentemente no esta recibiendo las interrupciones de HARDWARE.

hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_request from:1
hdebug: name=tty vmid=0 nr=5 ep=5 AT-D0: multiword DMA modes sup:44
hdebug: name=tty vmid=0 nr=5 ep=5 AT-D0: Ultra DMA modes support:40
hdebug: name=tty vmid=0 nr=5 ep=5 AT-D0: Ultra DMA mode selected:34
MH_notify dst=at_wini src=kernel src_id=4 ntfy_cnt=1

hdebug: name=tty vmid=0 nr=5 ep=5 AT-D0: AT driver detected :26
hdebug: name=tty vmid=0 nr=5 ep=5 VMware Virtual IDE Hard Drive :41
hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device to part::0
hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: style::1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: atapi::0
hdebug: name=tty vmid=0 nr=5 ep=5 AT-D0: timeout on command 0xc8:31

hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::0
hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::-1403392
hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device to part::1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: style::2
hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: atapi::0
MH_notify dst=at_wini src=kernel src_id=4 ntfy_cnt=1

hdebug: name=tty vmid=0 nr=5 ep=5 AT-D0: timeout on command 0x91:31
hdebug: name=tty vmid=0 nr=5 ep=5 AT-D0: timeout on command 0xc8:31
	
SOLUCIONADO: Error en w_intr_wait	
	
	
PRUEBA con vmm.cfg
# this is a comment 
machine MYMINIX {
	size		64;
#	tokens	32;
	boot_prog	"/usr/src/proxy/loadvmimg";
	boot_image  "/boot/MYMINIX.img";
	boot_bitmap 0xFFFFFFFF;
	process at_wini  PROMISCUOUS_PROC_TYPE   EXEC_LOADED   TASK_LEVEL  EXEC_NTFY;
	device  at_wini VDEV_DISK_MINOR 5;
#	process pm  REAL_PROC_TYPE  BOOT_LOADED  SERVER_LEVEL  DONOT_NTFY;
#	process fs REAL_PROC_TYPE   BOOT_LOADED  SERVER_LEVEL  DONOT_NTFY;
#	process tty	PROMISCUOUS_PROC_TYPE  BOOT_LOADED  TASK_LEVEL  BOOT_NTFY;
#	process floppy  VIRTUAL_PROC_TYPE   BOOT_LOADED  TASK_LEVEL  DONOT_NTFY;
};

PROBLEMA:
Al arrancar la VM1, se cuelga en "cmos" y presenta el prompt de booteo

-------------------------------------------------------------------------------------------------------------------------
20151110:

SENDREC: src=pm dst=-2 source=0 type=1537 m1i1=35567 m1i2=0 m1i3=0 m1p1=1FE4 m1p2=188A m1p3=0 
proc.c:848 vmid=1 nr=-2 endp=-2 name=system flags=0 misc=0 getf=27342 sent=0 recv_vm=-1
proc.c:926 vmid=1 nr=0 endp=0 name=pm flags=0 misc=201 getf=27342 sent=27342 recv_vm=-1
do_exec: in vmid=1 proc=28
do_exec: driver found cmos type=114
do_exec: process cmos MATCH on VM0 p_nr0=26 p_nrX=28 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
do_exec: in cmos(VM0) exec:cmos p_nrX=28
do_exec: notifying cmos type=114

			/* ONLY FOR DEBBUGGING - por ahora deben estar en la misma ranura */
			MHASSERT( (dst0_ptr == proc_addr_vm(VM0, dst_p)));

			
SENDREC: src=fs dst=35567 source=1 type=1030 m1i1=0 m1i2=35568 m1i3=4 m1p1=206E6570 m1p2=5F6F6877 m1p3=65 
ASSERT proc.c:674 
Kernel panic: proc.c 674
MINIX will now be shut down ...
proc.c:677 vmid=0 nr=26 endp=35565 name=cmos flags=8 misc=2 getf=31438 sent=27342 recv_vm=-1
proc.c:786 vmid=0 nr=26 endp=35565 name=cmos flags=0 misc=0 getf=27342 sent=27342 recv_vm=-1
proc.c:926 vmid=1 nr=1 endp=1 name=fs flags=0 misc=201 getf=27342 sent=27342 recv_vm=-1


MODIFICADO proc.c
#ifdef IPC_DBGxxxxxxx
			/* ONLY FOR DEBBUGGING - por ahora deben estar en la misma ranura */
			MHASSERT( (dst0_ptr == proc_addr_vm(VM0, dst_p)));
			/* ONLY FOR DEBUGGING */
			MHDEBUG(PROC_FORMAT, PROC_FIELDS(dst0_ptr));
#endif /* IPC_DBG */
			
	
PRUEBA 2:
	Ahora falla cuando intenta montar /dev/c0d0p0s2 minor 130
	
prtmsg: proc=at_wini vmid=0 source=1 type=1031 m1i1=130 m1i2=0 m1i3=0 m1p1=2874 m1p2=400 m1p3=400 
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini_minor:5
hdebug: name=at_wini vmid=0 nr=16 ep=35555 virt_minor:130 ==> /dev/c0d0p0s2 
hdebug: name=at_wini vmid=0 nr=16 ep=35555 real_minor:154 deberia ser 146 
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:154

NR_PARTITIONS =  4
DEV_PER_DRIVE =  1 + NR_PARTITIONS = 5
SUB_PER_DRIVE = 16

				m_ptr->DEVICE += ( ((at_wini_minor[rqst_vmid]/DEV_PER_DRIVE) * SUB_PER_DRIVE) +
									((virt_minor-128) * NR_PARTITIONS));
				= 130 + 	(5/5*16) + (130-128)*4 				
				= 130 + 16 + 8 = 154 !!!!
				
				m_ptr->DEVICE += ((at_wini_minor[rqst_vmid]/DEV_PER_DRIVE) * SUB_PER_DRIVE);
				= 130 + (5/5) 16 = 146
				
FUNCIONA VM1 OK 
		
-------------------------------------------------------------------------------------------------------------------------
20151114:	
		OJO, cambie PROC.C para que el descriptor de SYSTASK en VMx sea VIRTUAL y de esa forma las IPC tengan el mismo comportamiento
		que un driver.
		Tambien cambie do_vmmreq cuando arranca los procesos de booteo DISABLED_PROC_TYPE, que setea al descriptor SYSTASK en VMx como VIRTUAL.
		
		
do_exec: in vmid=1 proc=12
do_exec: REAL service
do_exec: in vmid=1 proc=13
do_exec: driver found floppy type=112
do_exec: VIRTUAL floppy
isokendpt_vm3: proc_ptr(system,-2,1,0) src_dst(VM1,78,0,1). running_vm=1 <<<<<< VM1=loadvmimg MUERTO!!
do_exec: BAD ENDPOINT for VIRTUAL_TASK floppy 
ERROR do_exec.c:177: do_exec: error -405
exception proc=13 name=floppy vmid=1 running_vm=1 vec_nr=13 sp=9E94 General protection
DATA proc=13 name=floppy vir=0 phys=F9B len=2
cause_sig: proc_nr=13, sig_nr=11 running_vm=1

loadvmimg se muere al ejecutar el vmmcmd START.
Esto puede deberse a algun error en el proxy dado q la VM parece arrancar correctamente.
		
-------------------------------------------------------------------------------------------------------------------------
20151115:
		Para ver que falla se hizo en kernel/drivers.h:
	1) se anulo SYSTASK como VIRTUAL y se volvio a DISABLED
	2) Se anulo FLOPPY como VIRTUAL y se puso DISABLED
	
	La VM1 bootea pero da error cuando trata de montar /dev/c0d0p0s2

-------------------------------------------------------------------------------------------------------------------------
20151120:	
	SE volvio a la version estable del 11/11 y 
	luego se aplicaron diferencias.
	Funciono OK.

-------------------------------------------------------------------------------------------------------------------------
20151121:
	Se modifico vmmcmd y do_exec para soportar PARAVIRTUAL
	Se cambio el formato de los archivos de configuracion PARAVIRTUAL_PROC_TYPE , agrega el bitmap pero mantiene el resto
	de los argumentos
	por otro lado, todo lo que sea FILENAMES en realidad ahora van a ser PATH
	de tal forma que el filename será el mismo que en original pero se le inserta en el principio el PATH
		ej: /dev/lp
		sera en VM0: /home/vm/MINIX1/dev/lp que será un archivo regular
	
# this is a comment 
machine MINIX1 {
	size		64;
	boot_prog	"/usr/src/proxy/loadvmimg";
	boot_image  "/boot/MINIX1.img";
	boot_bitmap 0xFFFFFFFF;
	process at_wini PROMISCUOUS_PROC_TYPE   EXEC_LOADED   TASK_LEVEL  EXEC_NTFY;
	device  at_wini VDEV_DISK_MINOR 5;
	process printer PARAVIRTUAL_PROC_TYPE 0x00A88000 EXEC_LOADED TASK_LEVEL  EXEC_NTFY;
	device  printer VDEV_PRT_FILE /home/vm/MINIX1;
};

do_exec: in vmid=1 proc=57
do_exec: driver found printer type=1151
do_exec: PARAVIRTUAL printer s_call2proxy=A88000
MH_send: PRINTER dst_ep=0

MH_send: PRINTER dst_ep=-2
MH_send: PARAVIR_TASK caller=printer running_vm=1
src=printer dst=system source=35596 type=1551 m1i1=66048 m1i2=35534 m1i3=35534 m1p1=408 m1p2=238 m1p3=2 
MH_send: PARAVIRTUAL caller_nr=57 call_nr=15 s_call2proxy=A88000
MH_send: SYSTASK s_id=3
notify_proxy: proxy_ep=35617 proxy_nr=78 driver_id=3
proc.c:2841 vmid=0 nr=78 endp=35617 name=VM1 flags=8 misc=10 getf=31438 sent=27342 recv_vm=0
proc.c:2842 s_proc_nr=78 s_id=21 s_flags=12 s_nr_irq=0 s_vmid=0 s_vm_bitmap=1 s_dr_bitmap=4008

TECLA F1
[-3]      0         -3  clock    00/08 04/08      0     0    280K -S---- pm
[-2]      0         -2  system   00/08 04/08      0     0    280K M----- VIRTUAL <<<<<<<<<<<<
[-1]      0         -1  kernel   00/08 04/08      0     0    280K -S---- pm
  0       0          0  pm       04/32 26/32     22     0    128K -SR--- fs
  1       0          1  fs       14/32 28/32   1204     0   4956K --R--- printer
  2       0          2  rs       06/04 04/04      0     0     48K --R--- ANY
  3       0          3  mem      03/04 03/04      3     0    584K --R--- ANY
  4       0          4  log      04/04 03/04      7     0     76K --R--- ANY
  5       0          5  tty      01/04 02/04      0     0    356K M----- PROMISC
  6       0          6  ds       03/04 02/04      0     0    132K --R--- ANY
  7       0          7  vmm      03/04 02/04      0     0     40K -S---- pm
  8       0          8  init     10/08 06/08      0     9     28K --R--- pm
 11       1      35550  pci      03/04 01/04      0     0     48K M----- PROMISC
 13       1      35552  floppy   03/03 01/04      0     0     28K ------ VIRTUAL
 16       1      35555  at_wini  04/04 02/04      0     0    100K M----- PROMISC
 26       1      35565  is       04/04 01/04      0     0    464K M----- PROMISC
 28       1      35567  cmos     04/04 01/04      0     0     16K M----- PROMISC
 49       1      35588  random   05/04 02/04      0     0     44K M----- PROMISC
 57       1      35596  printer  06/04 04/04      1     0    140K -SR--- system   <<<<<<<<<<<<
 62       1      35601  update   14/08 07/08      0     5     16K -SR--- fs
 64       1      35603  cron     14/08 04/08      1     4     64K --R--- pm
 68       1      35607  syslogd  14/08 04/08      1     7     72K --R--- fs
 
-------------------------------------------------------------------------------------------------------------------------
20151122:
	Se modifico proc.c el send para considerar a los procesos PARAVIRTUAL

 MH_send: PRINTER dst_ep=-2
 MH_send: PARAVIR_TASK caller=printer running_vm=1
 src=printer dst=system source=35596 type=1551 m1i1=66048 m1i2=35534 m1i3=35534 m1p1=408 m1p2=238 m1p3=2 
 MH_send: PARAVIRTUAL caller_nr=57 call_nr=15 s_call2proxy=A88000
 MH_send: SYSTASK s_id=3
 notify_proxy: proxy_ep=35617 proxy_nr=78 driver_id=3
 proc.c:2841 vmid=0 nr=78 endp=35617 name=VM1 flags=8 misc=10 getf=31438 sent=27342 recv_vm=0
 proc.c:2842 s_proc_nr=78 s_id=21 s_flags=12 s_nr_irq=0 s_vmid=0 s_vm_bitmap=1 s_dr_bitmap=4008

EL PROXY REPORTA: 
proxy_init: px_ep:35617
do_proxy: receive from:31438(ANY)
do_proxy: receive m_source:-1
do_proxy: receive NOTIFY_ARG:8
get_driver_nr: INPUT virtual_bm:8
get_driver_nr: driver_nr:-2
get_driver_nr: OUTPUT virtual_bm:0
do_proxy: driver_nr:-2
do_proxy: error virtual_bm:0
do_proxy: receive from:31438
 
do_exec: REAL service
do_exec: in vmid=1 proc=13 
do_exec: driver found floppy type=112 
do_exec: VIRTUAL floppy vmm_endpoint=35617 
isokendpt_vm3: proc_ptr(system,-2,1,0) src_dst(VM1,78,0,1). running_vm=1 <<<<<<< VM1=PROXY<<<< MURIO!!!! 
do_exec: BAD ENDPOINT for VIRTUAL_TASK floppy  
ERROR do_exec.c:190: do_exec: error -405 
exception proc=13 name=floppy vmid=1 running_vm=1 vec_nr=13 sp=9E94 General protection 
DATA proc=13 name=floppy vir=0 phys=FCD len=2 
cause_sig: proc_nr=13, sig_nr=11 running_vm=1 
 
PROBLEMAS CON AT_WINI
			OPEN
hdebug: name=fs vmid=1 nr=1 ep=1 FS: do_mount vmid:1
hdebug: name=fs vmid=1 nr=1 ep=1 FS: do_mount dev:898
hdebug: name=fs vmid=1 nr=1 ep=1 FS: do_mount who_e:35571
hdebug: name=fs vmid=1 nr=1 ep=1 FS: dev_open dev:898
hdebug: name=fs vmid=1 nr=1 ep=1 FS: dev_open who_e:35571
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_request rqst_vmid:1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_request from:1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: VIRTUAL minor:130
prtmsg: proc=at_wini vmid=0 source=1 type=1030 m1i1=130 m1i2=35571 m1i3=6 m1p1=206E6570 m1p2=5F6F6877 m1p3=65 
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: REAL minor:146
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini_minor:5
hdebug: name=at_wini vmid=0 nr=16 ep=35555 virt_minor:130
hdebug: name=at_wini vmid=0 nr=16 ep=35555 real_minor:146
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: DEV_OPEN:146
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:146

		READ SUPERBLOCK
hdebug: name=fs vmid=1 nr=1 ep=1 FS: read_super vmid:1 <<<<<<<<<<<<<<< (READ SUPERBLOCK)
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_request rqst_vmid:1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_request from:1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: VIRTUAL minor:130
prtmsg: proc=at_wini vmid=0 source=1 type=1027 m1i1=130 m1i2=1 m1i3=1024 m1p1=400 m1p2=0 m1p3=28A4  <<<< (READ)
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: REAL minor:146
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini_minor:5
hdebug: name=at_wini vmid=0 nr=16 ep=35555 virt_minor:130
hdebug: name=at_wini vmid=0 nr=16 ep=35555 real_minor:146
hdebug: name=at_wini vmid=0 nr=16 ep=35555 do_rdwt: sys_umapvm:1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:146
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer proc_nr:1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer opcode:1033
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer position:1024
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer nr_req:1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: Check disk address:1024
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer nbytes:1024
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer dv_size:0     <<<<<<<< DEVICE SIZE !!!!!!

			CLOSE 
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_request rqst_vmid:1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_request from:1
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: VIRTUAL minor:130
prtmsg: proc=at_wini vmid=0 source=1 type=1031 m1i1=130 m1i2=0 m1i3=0 m1p1=28A4 m1p2=400 m1p3=400 
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: REAL minor:146
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini_minor:5
hdebug: name=at_wini vmid=0 nr=16 ep=35555 virt_minor:130
hdebug: name=at_wini vmid=0 nr=16 ep=35555 real_minor:146
hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:146
hdebug: name=fs vmid=1 nr=1 ep=1 FS reply:-22


-------------------------------------------------------------------------------------------------------------------------
20151123: 
	Da error al montar en VM1  /dev/c0d0p0s2 
	
	Segùn lo que se ve en el LOG.

 hdebug: name=at_wini vmid=0 nr=16 ep=35555 P_SUB: disk::1 <<<<<<<<<<<<<<<<<<<<<
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 P_SUB: par::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 P_SUB: device::144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:144
 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::16777216

 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::2           <<<<<<<<<<<<<< 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0       <<<<<<<<<<<<<<
 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::3
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::6
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::843055104
	
	

 hdebug: name=at_wini vmid=0 nr=16 ep=35555 P_SUB: disk::1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 P_SUB: par::1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 P_SUB: device::148
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:148
 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::148
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::148
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::843055104
 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::148
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::2
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::148
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::3
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::6
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::2
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::-861236224
	
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 P_SUB: disk::1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 P_SUB: par::2
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 P_SUB: device::152
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:152
 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::152
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::152
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::152
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::2
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::-861236224
 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::152
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::3
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: device::6
 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: par::3
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 partition: dv_size::0
	
	
		NO SE PORQUE RAZON AT_WINI CAMBIA LOS MINOR DE LAS SUBPARTICIONES
O SEA, algunas veces funciona bien con una ecuacion y otras veces con otra

Esta (en mi opinion esta mal)
				m_ptr->DEVICE += ( ((at_wini_minor[rqst_vmid]/DEV_PER_DRIVE) * SUB_PER_DRIVE) +
									((virt_minor-128) * NR_PARTITIONS));				
O esta que se corresponde con los minors :
				m_ptr->DEVICE += ((at_wini_minor[rqst_vmid]/DEV_PER_DRIVE) * SUB_PER_DRIVE); 


AHORA FUNCIONA BIEN, PERO CON EL DEVICE CAMBIADO

 hdebug: name=fs vmid=1 nr=1 ep=1 FS: do_mount vmid:1
 hdebug: name=fs vmid=1 nr=1 ep=1 FS: do_mount dev:898
 hdebug: name=fs vmid=1 nr=1 ep=1 FS: do_mount who_e:35571
 hdebug: name=fs vmid=1 nr=1 ep=1 FS: dev_open dev:898
 hdebug: name=fs vmid=1 nr=1 ep=1 FS: dev_open who_e:35571
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_request rqst_vmid:1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_request from:1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: VIRTUAL minor:130	<<<<<<<<<<<<<<<<
 prtmsg: proc=at_wini vmid=0 source=1 type=1030 m1i1=130 m1i2=35571 m1i3=6 m1p1=206E6570 m1p2=5F6F6877 m1p3=65 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: REAL minor:154		<<<<<<<<<<<<<<<<<<<
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini_minor:5
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 virt_minor:130
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 real_minor:154
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: DEV_OPEN:154
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:154
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_request rqst_vmid:1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_request from:1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: VIRTUAL minor:128
 prtmsg: proc=at_wini vmid=0 source=1 type=1032 m1i1=128 m1i2=1 m1i3=4 m1p1=2000 m1p2=0 m1p3=2CA4 
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: REAL minor:144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini_minor:5
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 virt_minor:128
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 real_minor:144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_prepare device:144
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer proc_nr:1
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer opcode:1032
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer position:8192
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer nr_req:4
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: Check disk address:8192
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer nbytes:16384
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer dv_size:16777216
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: reinitialization:21
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: w_transfer do_dma:1
 MH_notify dst=at_wini src=kernel src_id=4 ntfy_cnt=1
 MH_notify dst=at_wini src=kernel src_id=4 ntfy_cnt=2
 hdebug: name=at_wini vmid=0 nr=16 ep=35555 at_wini: DEV_SCATTER:1
 
	
PROBANDO PRINTER PARAVIRTUAL

MH_send: PRINTER dst_ep=-2
MH_send: PARAVIR_TASK caller=printer running_vm=1
src=printer dst=system source=35596 type=1551 m1i1=66048 m1i2=35534 m1i3=35534 m1p1=408 m1p2=238 m1p3=2 
MH_send: PARAVIRTUAL caller_nr=57 call_nr=15 s_call2proxy=A88000
MH_send: SYSTASK s_id=3
notify_proxy: proxy_ep=35618 proxy_nr=79 driver_id=3
proc.c:2841 vmid=0 nr=79 endp=35618 name=VM1 flags=8 misc=10 getf=31438 sent=27342 recv_vm=0
proc.c:2842 s_proc_nr=79 s_id=21 s_flags=12 s_nr_irq=0 s_vmid=0 s_vm_bitmap=1 s_dr_bitmap=4008

El LOG del proxy muestra
inicializacion
 hdebug: name=VM1 vmid=0 nr=78 ep=35617 proxy_init: initializing proxy:2
 hdebug: name=VM1 vmid=0 nr=78 ep=35617 paraprinter_init:1

invocacion con echo xxxx  > /dev/lp
 MH_send: PRINTER dst_ep=-2
 MH_send: PARAVIR_TASK caller=printer running_vm=1
 src=printer dst=system source=35596 type=1551 m1i1=66048 m1i2=35534 m1i3=35534 m1p1=408 m1p2=238 m1p3=2 
 MH_send: PARAVIRTUAL caller_nr=57 call_nr=15 s_call2proxy=A88000
 MH_send: SYSTASK s_id=3
 notify_proxy: proxy_ep=35617 proxy_nr=78 driver_id=3
 proc.c:2841 vmid=0 nr=78 endp=35617 name=VM1 flags=8 misc=10 getf=31438 sent=27342 recv_vm=0
 proc.c:2842 s_proc_nr=78 s_id=21 s_flags=12 s_nr_irq=0 s_vmid=0 s_vm_bitmap=1 s_dr_bitmap=4008
 hdebug: name=VM1 vmid=0 nr=78 ep=35617 do_proxy: receive m_source:-1
 hdebug: name=VM1 vmid=0 nr=78 ep=35617 do_proxy: receive NOTIFY_ARG:8
 hdebug: name=VM1 vmid=0 nr=78 ep=35617 do_proxy: driver_nr:-2
 hdebug: name=VM1 vmid=0 nr=78 ep=35617 paraprinter_driver:-2

	
-------------------------------------------------------------------------------------------------------------------------
20151124:
		Se modifico VMMCMD para hacer un fork y exec y no necesitar ejecutar el VMMCMD LOAD XXXXX con &
		
		Se modifico el Scheduling:
			La VM0 acumula todos los tokens disponibles. En lugar de hacer el refresco de tokens cada t_refresh, 
			la replanificacion se hara cuando la VM0 tiene el total de tokens y entonces los vuelve a repartir.
			
FUNCIONA PERO:
			Falta verificar que efectivamente se hace la planificacion

-------------------------------------------------------------------------------------------------------------------------
20151212:
			Se esta tratando de depurar LANCE
			El ifconfig funciona si se setea en forma estatica
			cuando se hizo # hostaddr
			dio un PANIC por DEADLOCK detectado por RS
			
MH_notify dst=lance src=rs src_id=7 ntfy_cnt=1
hdebug: name=tty vmid=0 nr=5 ep=5 RS: service 35593 reported lat:32
MH_notify dst=fs src=log src_id=11 ntfy_cnt=1			
hdebug: name=tty vmid=0 nr=5 ep=5 manager.c:339 vmid=0 nr=54 end:80			
hdebug: name=tty vmid=0 nr=5 ep=5 cv_vm=0 :8			
hdebug: name=tty vmid=0 nr=5 ep=5 manager.c:346 vmid=0 nr=0 endp:80			
hdebug: name=tty vmid=0 nr=5 ep=5 m=0 :4			
hdebug: name=tty vmid=0 nr=5 ep=5 manager.c:346 vmid=0 nr=1 endp:80			
hdebug: name=tty vmid=0 nr=5 ep=5 cv_vm=0 :8			
hdebug: name=tty vmid=0 nr=5 ep=5 manager.c:346 vmid=0 nr=61 end:80			
hdebug: name=tty vmid=0 nr=5 ep=5 7342 recv_vm=0:15			
MH_notify dst=tty src=kernel src_id=4 ntfy_cnt=1			
hdebug: name=tty vmid=0 nr=5 ep=5 manager.c:346 vmid=0 nr=54 end:80			
hdebug: name=tty vmid=0 nr=5 ep=5 cv_vm=0:8			
hdebug: name=tty vmid=0 nr=5 ep=5 Panic in RS: deadlock found: 3:35			
cause_sig: proc_nr=2, sig_nr=9 running_vm=0			
MH_notify dst=pm src=system src_id=3 ntfy_cnt=1			
MH_send: caller=system dst_ep=2 dst_p=2 dst_ptr->p_vmid=0 running_vm=0 			
proc.c:668 vmid=0 nr=2 endp=2 name=rs flags=230 misc=1 getf=-2 sent=27342 recv_vm=-1			
RETURN proc.c:669: rcode=-109			
LOCKSEND src=system dst=2 			
SYSTEM, reply to call_nr=6 running_vm=0 ep=2 failed: -109			
SYSTEM: result=0 running_vm=0 rcode=-109 source=2 type=0 m5c1=Î m5c2=  m5i1=9 m5i2=1 m5l1=35 m5l2=0 m5l3=40808			
MH_notify dst=pm src=clock src_id=2 ntfy_cnt=1			
MH_notify dst=clock src=kernel src_id=4 ntfy_cnt=1			
	
hostaddr->fs->inet->lance->pm->fs !!!! DEADLOCK	

RS->LANCE	
MH_notify dst=lance src=rs src_id=7 ntfy_cnt=1

RS dice que LANCE se reporta tarde
hdebug: name=tty vmid=0 nr=5 ep=5 RS: service 35588 reported lat:32
hdebug: name=tty vmid=0 nr=5 ep=5 manager.c:339 vmid=0 nr=49 end:80
hdebug: name=tty vmid=0 nr=5 ep=5 35595 recv_vm=-1:17

PM->RS SIGCHLD
MH_notify dst=rs src=pm src_id=5 ntfy_cnt=1
hdebug: name=tty vmid=0 nr=5 ep=5 RS: got SIGCHLD signal, doing :56
hdebug: name=tty vmid=0 nr=5 ep=5 eth_write_port: sendrec to 355:46
hdebug: name=tty vmid=0 nr=5 ep=5 RS: proc 0, pid 51, :20
hdebug: name=tty vmid=0 nr=5 ep=5 killed, signal number 9:24
hdebug: name=tty vmid=0 nr=5 ep=5 Unexpected exit. Restarting /u:44
hdebug: name=tty vmid=0 nr=5 ep=5 eth_check_drivers: got a notif:49
hdebug: name=tty vmid=0 nr=5 ep=5 RS: started '/usr/sbin/lance',:76
hdebug: name=tty vmid=0 nr=5 ep=5 eth_check_drivers: got name: l:35
hdebug: name=tty vmid=0 nr=5 ep=5 eth_restart: restarting eth0, :49
hdebug: name=tty vmid=0 nr=5 ep=5 pci_init: called by '':23
hdebug: name=pci vmid=0 nr=11 ep=35550 pci_init: m_source=:71101
hdebug: name=pci vmid=0 nr=11 ep=35550 pci_init: sendvm=:71101
do_getinfo GET_MONPARAMS lance p_vmid=0
hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: dr_transfer:0
MH_notify dst=rs src=is src_id=16 ntfy_cnt=1
MH_notify dst=rs src=lance src_id=19 ntfy_cnt=1
MH_notify dst=rs src=rescue src_id=22 ntfy_cnt=1
hdebug: name=cmos vmid=0 nr=26 ep=35565 CMOS:  rqst_vmid:0
MH_notify dst=lance src=kernel src_id=4 ntfy_cnt=1
MH_notify dst=inet src=clock src_id=2 ntfy_cnt=1
MH_notify dst=random src=rs src_id=7 ntfy_cnt=1
MH_notify dst=lance src=rs src_id=7 ntfy_cnt=1
hdebug: name=tty vmid=0 nr=5 ep=5 RS: service 71101 reported lat:32
hdebug: name=log vmid=0 nr=4 ep=4 do_rdwt: dr_transfer:0
hdebug: name=tty vmid=0 nr=5 ep=5 manager.c:339 vmid=0 nr=23 end:80
hdebug: name=tty vmid=0 nr=5 ep=5 35595 recv_vm=-1:17
MH_notify dst=pm src=clock src_id=2 ntfy_cnt=1
MH_notify dst=random src=clock src_id=2 ntfy_cnt=

Aparentemente el problema es que LANCE se reporta tarde!!

RS->LANCE
MH_notify dst=lance src=rs src_id=7 ntfy_cnt=1	

como DEV_PING =	NOTIFY_FROM(RS_PROC_NR) /* driver liveness ping */
pero LANCE hace
	 _mhdebug("LANCE: receive from", m.m_source);
y no recibe ese notify!!!!	 

PROBLEMA: El notify del RS->LANCE no se recibe!!! porque ??

-------------------------------------------------------------------------------------------------------------------------
20151213:


................ CASO EN QUE LANCE ESTA ESPERANDO ......................

LANCE haciendo receive
hdebug: name=lance vmid=0 nr=49 ep=35588 LANCE: receiving:0

RS->LANCE DEV_PING
hdebug: name=rs vmid=0 nr=2 ep=2 RS notify:35588

LANCE recibe el DEV_PING de RS
hdebug: name=lance vmid=0 nr=49 ep=35588 LANCE: receive from:2

LANCE notify RS DEV_PING
hdebug: name=lance vmid=0 nr=49 ep=35588 LANCE: DEV_PING:2

RS recibe DEV_PING 
hdebug: name=rs vmid=0 nr=2 ep=2 RS:heartbeat notify:49

................ CASO EN QUE LANCE NO ESTA ESPERANDO ......................

LANCE haciendo receive
hdebug: name=lance vmid=0 nr=49 ep=35588 LANCE: receiving:0

HARDWARE->LANCE interrupcion
hdebug: name=lance vmid=0 nr=49 ep=35588 LANCE: receive from:-1

RS->LANCE DEV_PING
hdebug: name=rs vmid=0 nr=2 ep=2 RS notify:35588

LANCE NO ESTA ESPERANDO!!!!!
MH_notify dst=lance src=rs src_id=7 ntfy_cnt=1

RS REPORTA LANCE LATE
hdebug: name=tty vmid=0 nr=5 ep=5 RS: service 35588 reported lat:32

..................... ESTO PASO MAS ARRIBA ...................
hdebug: name=rs vmid=0 nr=2 ep=2 RS notify:35588
MH_notify dst=lance src=rs src_id=7 ntfy_cnt=1
hdebug: name=lance vmid=0 nr=49 ep=35588 LANCE: receiving:0
hdebug: name=lance vmid=0 nr=49 ep=35588 LANCE: receive from:2
hdebug: name=lance vmid=0 nr=49 ep=35588 LANCE: DEV_PING:2
hdebug: name=rs vmid=0 nr=2 ep=2 RS:heartbeat notify:49

Se ve claramente que LANCE responde al NOTIFY de RS aun cuando no estaba esperando!!

HIPOTESIS:
	1) Cuando se produce un interrupcion de hardware, algo pasa y LANCE no pasa a RECEIVING

INET->LANCE
src=inet dst=lance source=35595 type=2051 m1i1=0 m1i2=35595 m1i3=60 m1p1=0 m1p2=8B1D m1p3=4A7F8 

LANCE->INET reply con SEND, pero INET no esta esperando.
lance src_dst_e=35595 function=1 source=35588 type=2325 m1i1=0 m1i2=35595 m1i3=346 m1p1=2 m1p2=367 m1p3=1054 
proc.c:898 vmid=0 nr=49 endp=35588 name=lance flags=4 misc=0 getf=27342 sent=35595 recv_vm=-1

LANCE 	SR	PM			(GETPROCNR)
PM		SR	FS
FS		R	INET
INET	R	LANCE

FS->INET->LANCE->PM pero PM todavia 

INET-sendrec->LANCE 
inet src_dst_e=LANCE function=3 source=INET type=2052 m1i1=0 m1i2=INET m1i3=4 m1p1=0 m1p2=0 m1p3=A32A8 
src=inet dst=lance source=INET type=2052 m1i1=0 m1i2=INET m1i3=4 m1p1=0 m1p2=0 m1p3=A32A8 

Aqui LANCE deberia haber hecho un  LANCE: receive from:INET
En cambio le responde a INET sin haber recibido mensaje de peticion.
Como INET quedo colgado tratando se hacer un SENDREC 

lance src_dst_e=INET function=1 source=LANCE type=2325 m1i1=0 m1i2=INET m1i3=91 m1p1=2 m1p2=195 m1p3=1054 
proc.c:899 vmid=0 nr=49 endp=LANCE name=lance flags=4 misc=0 getf=27342 sent=INET recv_vm=-1

-------------------------------------------------------------------------------------------------------------------------
20160512:
PRUEBA 1
		Se probo desde VM1 escribir algo en el disco
		En la VM1 se ve que lo escribio (cache), pero si se monta el disco en la VM0 no aparece lo escrito.
		De igual forma si desde la VM0 se escribe algo en el disco de la VM1 aparece escrito (cache) pero desde la VM1 no aparece.
		Luego de finalizar la VM1 si se hace un ls en la VM0 aparece el archivo generado desde la VM0, pero no el generado por VM1.
		Ademas da un FS panic (super.c) tried to free unused inode 385
		Supongo que esto se debe a la DOBLE administracion del disco por parte del FS0 y FS1
		Luego de arrancar la VM0 y hacer un #fsck /dev/c0d1 da un error fatal
		bad magic number in super block
		
PRUEBA 2
	Arranque VM0
	Arranque VM1
	desde la VM1
	cree un archivo en /  (que usa /dev/c0d1p0s0 ) 
	cree un archivo en /home  (que usa /dev/c0d1p0s1)
	hice sync, sync , halt  en la VM1

	Luego sync, sync, en la VM0

	Arranque VM0
	monto  /dev/c0d1p0s0 y veo el archivo creado desde VM1
	monto  /dev/c0d1p0s1 y veo el archivo creado desde VM1
	!!!!! Quiere decir que SI esta escribiendo en el disco!!!!!!
		

			
***************************************************************************************************************************
***************************************************************************************************************************
***************************************************************************************************************************
***************************************************************************************************************************
***************************************************************************************************************************
***************************************************************************************************************************

TODO:	Generar un MINIX 3.1.2a limpio e instalar MHYPER	

TODO:	Falta incluir la lectura del nombre del archivo en at_wini por PROXY desde el DS
	process at_wini  VIRTUAL_PROC_TYPE   EXEC_LOADED   TASK_LEVEL  DONOT_NTFY;
	device  at_wini VDEV_DISK_FILE /home/MINIX2/MINIX2.img

TODO:	FALTA PROBAR PARAVIRTUAL
	
TODO:
		Las VMs tiene el campo vm_proxy que indica el p_endpoint del PROXY
		Habria que agregar por rendimiento vm_ptr_proxy para que apunte directamente al descriptor cuando se arranca la VM
			de lo contrario requiere convertir de enpoint a p_nr y luego a puntero
			
TODO:	
ATENCION: Puede que el NOTIFY con bloqueo de un proceso de una VMx hacia un proceso PROMICUO de la VM0 provoque un deadlock.
A  pesar de que el planificador SIEMPRE buscara procesos de la VM0 ante todo, puede que el proceso PROMISCUO este bloqueado por otra razón.
Seria conveniente entonces EVITAR la planificación de la VMx hasta tanto el NOTIFY sea recibido.-
	
TODO: 
	NOTIFYVM setea el bit del proceso promiscuo ,pero en realidad deberia setear el del proceso en la VMx
	para esto hay que completar la estructura priv de los procesos en VMx tanto en el load de BOOT como EXEC.

	src_id = priv(caller_ptr)->s_id; /*<<<<<<<<<<<<<<<<< deberia ser priv(caller_ptrX)->s_id  */
	set_sys_bit(priv(dst_ptr)->s_notify_pending, src_id); 
	priv(dst_ptr)->s_ntfy_cnt[src_id]++;
/*	if( priv(dst_ptr)->s_ntfy_cnt[src_id] != 1) */
		MHDEBUG("MH_ntfyvm dst=%s src=%s src_id=%d ntfy_cnt=%d\n", 
			dst_ptr->p_name, caller_ptr->p_name, src_id, 
			priv(dst_ptr)->s_ntfy_cnt[src_id] );		
		

TODO:	UNA VM, incluyendo la VM0 pueden montar un disco de otra VM pero en modo SOLO LECTURA!!!

TODO A FUTURO:
	Cuando finaliza una VM, como hacer para borrar una VM, sus PROC y VDEV del DS ???
	

SOSPECHOZO!!:	Las tareas y servidores estan usando las colas de BAJA PRIORIDAD 13,14 en lugar de las de ALTA !!
	Se anulo balance_queues()
	
			
PROBLEMA:	El problema que se tiene es que cuando se arranca una nueva VM que solicitya Y tokens y quedan X tokens (X < Y) 
			no hay forma de reorganizar los tokens de las VMs.		
	
TODO:		Ver la forma en que en lugar de TOKENs se especifique un porcentaje de uso de CPU (habia un paper al respecto)
			CD 44 : Lottery Scheduling Flexible Proportional-Share Resource Management
			
Ejemplo:	Supongamos que el numero maximo de tickets que puede adquirir una VM es 255
			Cuando arranca VM1 adquiere 64 tickets
			Como no hay nadie que compita  VM1_tickets/Total_tickets = 100%
			
			Para poder solucionar el planificador, se tiene que importar la variable token_bucket de la interface 
			de la VM que esta activa.
			No contener otra porque no va a poder importarse de otra manera.
			es para considera la exportacion de reglas desde una VM a un drivar.
		
TODO:		DECIDIR QUE ALMACENAR EN EL DS!!!
			1) La configuracion de las VMs (una configuracion puede servir para arrancar varias VMs) (Esto se puede hacer con el archivo de config)
			2) El estado de las VMs (Esto ya lo tiene el VMM) 
	
		
PENDIENTES:
		+ PROBLEMA AT WINI QUE EN REALIDAD ES DE IPC
		+ PROBLEMA INIT 
		+ PROBLEMA IS 


				
-------------------------------------------------------------------------------------------------------------------------

TODO: Ver si no hay DOBLE VERIFICACION DE ENDPOINTS de la funcion principal 
	PUBLIC int sys_call(call_nr, src_dst_e, m_ptr, bit_map)
y las funciones individuales que le dan tratamiento
	

ATENCION:	Cuando se vaya a detener una VM hay que :
			* remover los IRQ_HOOKS que tenga asignados
			* enviar NOTIFY_MESSAGE a todos los proceso promiscuos para que la supriman


TODO:
Se podría hacer un dst = rcvas(src, &msg, dst ); donde dst puede ser ANY
A diferencia del actual rcvas() este se puede bloquear.
Si el proxy está bloqueado entonces el send() desde un proceso dentro de una VMx se hace directamente al proxy evitando el NOTIFY()
Si el dst = SELF es porque recibió un mensaje desde un proceso en la VM0.

+ VER DE QUE MANERA SE PUEDE GENERAR UN KERNEL SOLO PARA VMS (chroot?)
ver tools/release.sh


ERROR:		INIT

 _mhdebug("PARENT waits for",pid);
/* Parent just waits. */
r = wait(NULL);	
	hdebug: name=init vmid=1 nr=8 ep=8 init.c:109
	hdebug: name=init vmid=1 nr=8 ep=8 PARENT waits for:11
	SENDREC: src=init dst=0 source=8 type=7 m1i1=7499622 m1i2=0 m1i3=0 m1p1=0 m1p2=0 m1p3=0 
	proc.c:480 vmid=1 nr=0 endp=0 name=pm flags=8 misc=0 getf=31438 sent=27342 recv_vm=-1

El PM -> INIT
	SEND: src=pm dst=8 source=0 type=11 m1i1=0 m1i2=0 m1i3=0 m1p1=0 m1p2=0 m1p3=0 
	proc.c:480 vmid=1 nr=8 endp=8 name=init flags=8 misc=1(REPLY_PENDING)  getf=0(PM) sent=0 recv_vm=-1
	exception proc=8 name=init vmid=1 running_vm=1 vec_nr=13 
	raw_notify: src_p=-2 dst_p=0

ATENCION!!!! Cambiar el /usr/etc/rc del disco de la VM1 - quitarle los comentarios.

ERROR:		Reviasar AT_WINI para que no reciba mensajes hasta no terminar con la peticion actual

ERROR:		INIT DE LA VM1
SEND: src=pm dst=8 source=0 type=11 m1i1=0 m1i2=0 m1i3=0 m1p1=0 m1p2=0 m1p3=0 
proc.c:476 vmid=1 nr=8 endp=8 name=init flags=8 misc=1 getf=0 sent=0 recv_vm=-1
exception proc=8 name=init vmid=1 running_vm=1 vec_nr=13 ´
raw_notify: src_p=-2 dst_p=0

PROXY FLOPPY: 
			hacer sys_getproc desde la systask de tal forma de saber las direcciones
			fisicas del proceso y de esa forma poder hacer las transferencias directamente mediante conversiones
			desde el FS al proceso de la VMx
			Tener un cache solo para los NR_SYS_PROCS, para el resto hacer el pedido a systask.	
			La otra posibilidad es traer la tabla entera y controlar si el endpoint coincide o no con el q esta en la tabla de cache.
						
TODO:		Por ahora la tabla en driver.c requiere compilacion si se cambia drivers.h
			Se podria hacer que sys_getinfo() copie la tabla que tiene el kernel a un proceso de usuario, incluso el IS.

TODO:		Hacer que el RS no admita la ejecucion de ningun proceso PRIVILEGIADO que no este debidamente habilitado
				
TODO:		Los tipos de drivers (VIRTUAL, PROMISCUOUS,DISABLED, REAL) se estableceran FIJOS si se cargan  en booteo.
			Pero se estableceran por archivo de configuracion si se carcan con EXEC.
			
TODO:		DARLE A JAVIER EL TRABAJO DE QUE USE 
			INIPARSER para obtener los parametros de ejecucion.
			Entre los parametros de ejecucion, el vmmcmd deberá leer del archivo de configuracion el 
			path del programa loader (en base a loadvmimage)

			
+ PROC.C : RECVVM/SENDVM

+ PUERTO SERIE DE VMx PARAVIRTUALIZADO, para ello habría que cambiar el driver de TTY!!

TODO:		OTRA FORMA DE OBTENER LA DIRECCION DE UN PROCESO EN EL PROXY ES 
			OBTENIENDO LA INFORMACION DE LA TABLA DE PROCESOS DE LA VM DESDE EL KERNEL
			Sabe la ubicacion del proxy en VM0
			Sabe la ubicacion del proceso en VMx
			obtiene la diferencia.
			
TODO:		INCORPORAR LEER EL ROOT DIRECTORY EN READFS

TODO:		MODIFICAR EL KILL PARA UN PROCESO DE UNA VM

TODO:		Modificar para producir 256 = 4 * 64 = (64 << 2) ticks por segundo

	const.h
			#define HZ	          64	/* clock freq (software settable on IBM-PC) */

	clock.c
			#define TIMER_COUNT ((unsigned) (TIMER_FREQ/HZ/4)) /* initial value for counter*/

			clock_handler()
				if( (realtime << 4 >> 4) == realtime)
					realtime += ticks;
					
			do_clock_tick()
				token_bucket();
				ejecutar lo que hace MINIX 
ERROR:
		FS/AT_WINI: Queda resolver este error.
		DO_VMMCMD:  Cuando se activa un proceso PROMISCUO enviar un NOTIFY del VMM para que sepa
					que ahora incluya una nueva VM para antender (Esto ya se hace para TTY)
					Hay que extenderlo a todo los PROMISCUOS y darle tratamiento dentro del 
					driver de igual forma a TTY, con el bitmap de VMs activas.

										
TOKEN BUCKET:	

POLITICA:
			*	Cada VM tiene su propio set de colas READY.
			*	El numero de ticks por segundo TICK_RATE = 256
			*   El numero maximo de VMs MAX_VMS=16
			*   El tamaño de un bucket es fijo BUCKET_SIZE = TICK_RATE/MAX_VMS =  16
					El objetivo es que las VMs no queden esperando demasiado tiempo
			*   nr_vms: numero de VMs activas  1 <= nr_vms <= NR_VMS <= MAX_VMS
			*   El numero de tokens del sistema es nr_tokens = BUCKET_SIZE * nr_vms;
			*	Se genera un token en cada TICK de reloj (si es que no hay deuda de tokens (token_debt > 0) 
			*	Se consume un token en cada TICK de reloj
			*   El objetivo es que las TAREAS no se retrasen por ejecutar procesos en otras VMs
				-   Si el proceso en ejecucion no es un TASK y hay TASKs pendientes (task_pending !=0) en alguna otra VM
					se cambia de VM en el proximo tick de reloj
				-	Si el proceso en ejecucion es un TASK el nro de token <= 0 
					se cambia de VM en el proximo tick de reloj
			*	Por cada tick de reloj un token se asigna a una VM en round robin (por ahora, sencillito).
			*	Si no hay actividad en una VM su bucket se va llenando hasta BUCKET_SIZE. 
				Cuando se llena (token[VMx] == BUCKET_SIZE) los tokens se asignan entre a las otras VMs
			*	Si una VM finaliza, sus tokens quedan en deuda por lo que durante los ticks de reloj siguientes
				no se generan tokens nuevos hasta cancelar esa deuda.
			
	Cuando el sistema arranca
				NR_VMS: constante Numero maximo de VMs activas admitido por el sistema 1 <= NR_VMS <= MAX_VMS
				token_debt = 0;				/* Tokens pendientes por finalizacion de VM */
				bucket[VM0] = BUCKET_SIZE;	/* Todos los tokens para la VM0				*/ 
				nr_vms = 1;					/* Numero de VMs activas     				*/
				vm_bitmap = (1 << VM0); 	/* bitmap de VMs activas					*/
				vm = VM0;					/* ultima VM a  la que se le asigno token  	*/
				next_vm = VM0;				/* proxima VM a ejecutar en:				*/
											/* 1) tick de reloj 						*/
											/* 2) enqueue() o dequeue()					*/
				running_vm = next_vm;

	Cuando arranca una VMx:
				nr_vms++;
				vm_bitmap = (1 << VMx);		/* incorpora la VM al bitmap 				*/
				bucket[VMx] = BUCKET_SIZE;	/* se le asignan tokens al bucket de la VM 	*/
	
	Cuando finaliza una VMx:
				token_debt  += (BUCKET_SIZE - bucket[VMx]);  /* se devuelven los tokens de la VM pero puede quedar deuda */
				nr_vms--;
				vm_bitmap &= ~(1 << VMx);	/* elimina la VM de bitmap */
				vm = VM0;
				pick_vm();
			
	En cada TICK de reloj	
			on_timer_tick() {
				add_token();
				sub_token();
			}
			
		/* Se acumula un token en una VM o ninguno 		*/
		/* si hay deuda de tokens x q una VM termino 	*/
		add_token() {	
			if( token_debt > 0)  {
				token_debt--;		/* no se asigna token en este tick de reloj */ 
				return;
			}	
			/* Hay que asignar un token a una VM Activa */
			i = 0; 									/* usada para controlar la cantidad de loops <= nr_vms */
			do {
				do {
					vm++;
					vm = vm%NR_VMS;				
				} while( !(vm_bitmap & (1 << vm));  /* buscar una VM activa , VM0 siempre estara activa */
				i++;
			}while(i < nr_vms && bucket[vm] >= BUCKET_SIZE);
			if( i == nr_vms)
				bucket[running_vm]++; 	/* este caso ocurre cuando todos los tokens estan repartidos 	*/
										/* equitativamente entre todas las VMs, todos lo buckets tiene	*/
										/* BUCKET_SIZE tokens, por lo que se le asigna un token mas 	*/
										/* al bucket de la running_vm dado que sub_token() se lo quitara*/
			else	
				bucket[vm]++;
		}
		
		sub_token() {
			/* se debe cobrar un token a la VM actual 	*/
			/* y controlar si aun tiene tokens 			*/
			next_vm = running_vm;
			bucket[running_vm]--;
			if ( bucket[running_vm] > 0 ) { 						/* hay tokens remanentes 				*/
				if( task_pending == TRUE) { 						/* hay TASK pendientes en alguna VM		*/
					if ( !proc_ptr->p_misc_flag & PROC_TYPE_TASK ){ /* no es una tarea, es server o usuario */
						pick_vm();									/* elegir otra VM						*/
						running_vm = next_vm;
						return;
					}
				}
			} else {												/* Se le terminaron los tokens 			*/
				pick_vm();											/* elegir otra VM						*/	
				running_vm = next_vm;
				return;
			}
n		return;
			/* sigue ejecutando la misma VM */
		}
		
			
		/* pick_vm: selecciona el par {running_vm, proc_ptr} 	*/	
		/* dentro de los procesos READY de las VMs activas		*/
		/* si no hay tasks READY setea task_pending = FALSE		*/
		pick_vm() 
		{
			/* Primero rastrea todas las VMs que tengan tasks READY */
			if( task_pending == TRUE) {
				search_for_tasks();
				if(proc_ptr != NULL) return;
			}
			
			/* Ahora rastrea todas las VMs que tengan procesos READY */
			search_for_process()
			if(proc_ptr != NULL) return;

			/* si no encuentro ningun proceso activo, IDLE se ejecutara */
			proc_ptr = IDLE;  
			next_vm  = VM0 
			max_priority = IDLE_Q; 	/* la unica q tiene IDLE es VM0 */		
			return;
		}	

		search_for_tasks() 
		{
			int i = 0;
			next_vm = running_vm;
			
			do {
				do {
					next_vm++;
					next_vm = next_vm%NR_VMS;				
				} while(!(vm_bitmap & (1 << next_vm));  /* buscar una VM activa , VM0 siempre estara activa */
				/* rastrea las colas READY de la nueva VM activa buscando TASKS para ejecutar */
				for(prio = TASK_Q; prio < (TASK_Q+1); prio++) {
					proc_ptr = get_prio_queue(next_vm, prio);
					if(proc_ptr != NULL && bucket[next_vm] > 0) {	/* Se encontro una tarea, su VM tiene tokens? */
						return;		/* ya tengo running_vm y proc_ptr seteados*/
					}else{ 
						proc_ptr == NULL;	
					}
				}
				i++;
			}while(i < nr_vms && proc_ptr == NULL);
			task_pending = FALSE;
			return;
		}	
		
		search_for_process() 
		{
			int i = 0; 
			next_vm = running_vm;

			do {
				do {
					next_vm++;
					next_vm = next_vm%NR_VMS;				
				} while( !(vm_bitmap & (1 << next_vm));  /* buscar una VM activa , VM0 siempre estara activa */
				/* rastrea las colas READY de la nueva VM activa buscando PROCESOS para ejecutar */
				for(prio = (TASK_Q+1); prio < (IDLE_Q-1); prio++) {
					proc_ptr = get_prio_queue(next_vm, prio);
					if(proc_ptr != NULL && bucket[next_vm] > 0) {
						return;		/* ya tengo running_vm y proc_ptr seteados*/
					}else{ 
						proc_ptr == NULL;	
					}
				}
				i++
			}while(i < nr_vms && proc_ptr == NULL);
			return;
		}
					
		/* 
		* Cuando un proceso en una VM se bloquea y 
		* el planificador scannea su cola de READY 
		* no hay proceso pendientes de mayor prioridad a IDLE_Q
		* ejecutar pick_vm()							
		*/
		dequeue() 
		{
			remover_de_ready(p_ptr->p_vmid, p_ptr->p_priority);	/* remover de READY 			*/
			pick_proc(); 										/* nuevo proc_ptr 				*/	
			if (proc_ptr->p_nr == IDLE)
				pick_vm();  									/* nuevo proc_ptr y running_vm 	*/
			return; 
		}
		
		/* Cuando un proceso de una VM pasa a READY */
		enqueue() {
			insertar_en_ready(p_ptr->p_vmid, p_ptr->p_priority);	/* insertar en READY 	*/
			if( p_ptr->p_misc_flag & PROC_TYPE_TASK)  
				task_pending = TRUE; 			/* Indicar que hay TASK pendiente */
			pick_proc();	/* busca nuevo proceso dentro de la misma VM */
		}

		


		
			HACER potencia de 2
				TICK_RATE 
				NR_VMS 
				NR_PROCS+NR_TASKS 
				BUCKET	=> TASK_BUCKET = BUCKET & TASK_MASK
				PROC_BUCKET = (BUCKET & PROC_MASK) >> TASK_SHIFT
	
FRONDEND/BACKEND DD:
			The front-end and back-end drivers also cooperate to establish the necessary shared memory areas between
			user processes and service domains.
			We adapted a FIFO/LIFO lock-free queue with ABA tagging
			[30,40,52] to ensure that the request queue, as well
			as other shared queues, can be accessed safely by both
			the user process and the service domain.
				[30]. Herlihy and N. Shavit. The Art of Multiprocessor Programming. Morgan Kaufmann Publishers
				Inc., San Francisco, CA, USA, 2008.
				[40]M. M. Michael and M. L. Scott. Simple, fast,
				and practical non-blocking and blocking concurrent
				queue algorithms. In Proceedings of the 15th
				Annual ACM Symposium on Principles of Dis-
				tributed Computing, PODC96, pages 267275,
				Philadelphia, PA, USA, 1996.
				[52] R. K. Treiber. Systems Programming: Coping with
				Parallelism. Technical Report RJ 5118, IBM Almaden
				Research Center, Apr. 1986

			
A FUTURO:		COPIA DE VMS
========		MIGRACION DE VMS
			MULTIKERNEL - SMP: Asignar a cada VM una CPU en forma fija.

			
TODO:		OTRA POSIBILIDAD es que cuando la SYSTASK sys_vmmreq has START or END le envia un notify de VM_START a los drivers promiscuos y PROXY.
			Estos hacen un esa forma el DRIVER PROMISCUO puede inicilizar/finalizar las estructuras de datos correspondiente a los recursos 
			de la VM nueva.					
			
TODO:		Controlar que todo tipo de copia de espacios de direcciones de vmid!=VM0 se haga dentro de los limites de la VM.
			
TODO:		OTRA POSIBILIDAD es que cada vez qeu el VMM hace un START/END le envia un mensaje de VM_START a los drivers promiscuos y PROXY.
			De esa forma el DRIVER PROMISCUO puede inicilizar las estructuras de datos correspondiente a los recursos de la VM nueva.
		
			
	/* ATENCION!!! ESTO ES UNA PERDIDA DE TIEMPO ENORME!!!  */
	/* SE RASTREAN TODAS LAS TTYS DE TODAS LAS VMS !!!      */
	for( v = VM0; v < NR_VMS ; v++) {
		for (tp = FIRST_TTY; tp < END_TTY; tp++) {
			if (tp->tty_events) handle_events(tp);
		}
	}

TODO:		Los PROMISCOUS_DRIVERS deberian registrarse como tales cuando se hace "service"
			si service se ejecuta en la VM != VM0 y es un PROMISCOUS_DRIVERS entonces no tienen que cargar
			nada excepto setear el descriptor del proceso del KERNEL en la VMx 

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!! ONLY FOR TESTS !!!!!!!!!!!!!!!!!!!!!!!!!!*/
    	for ( p=0 ; p < MAXPROM; p++) {
		for( i = HARDWARE+1;  i < NR_PROCS; i++) {
			xp = &vm_hyper[VM0].vm_proc[i+NR_TASKS];
			if(strcmp( xp->p_name, prom[p]) == 0) {
				rp = proc_addr(xp->p_nr);
				rp->p_rts_flags = 0;
				rp->p_misc_flags = PROMICUOUS_TASK;
				rp->p_max_priority  = 0;
				rp->p_priority 	    = 0;
				rp->p_quantum_size  = 0;
				rp->p_ticks_left    = 0;
				strcpy(rp->p_name, xp->p_name);
				rp->p_endpoint = xp->p_endpoint;
				rp->p_reg.retreg = 0;
  				rp->p_user_time = 0;
  				rp->p_sys_time = 0;
  				rp->p_ticks_left = 0;
				rp->p_vmid = vmid;

				ret = get_priv(rp, ((SYS_PROC) & SYS_PROC));   /*   assign priv structure 	*/
    				if( ret != OK) MHERROR("mh_main: getpriv error:\n",ret);
				priv(rp)->s_flags = SYS_PROC;			/* process flags 		*/
				priv(rp)->s_trap_mask = (~0);			/* allowed traps 		*/
				priv(rp)->s_call_mask = (~0);			/* kernel call mask		*/
				priv(rp)->s_ipc_to.chunk[0] = (~0);		/*  restrict targets 		*/

				MHDEBUG("mh_main: p_name=%s p_nr=%d flags=%X tmask=%X cmask=%X ipc_to=%X \n",
					rp->p_name, 
					rp->p_nr, 
					priv(rp)->s_flags,
					priv(rp)->s_trap_mask,
					priv(rp)->s_call_mask,
					priv(rp)->s_ipc_to.chunk[0]);
				
				i = NR_PROCS;
			}
		}     	
	}


	/*!!!!!!!!!!!!!!!!!!!!!!!!!!! ONLY FOR TESTS !!!!!!!!!!!!!!!!!!!!!!!!!!*/


TODO:		Las impresion en pantalla de las scheduling QUEUES (son punteros a procesos de diferentes VMs)
			obliga a cambiar el IS y el do_getinfo de tal forma de que cuando se solicita esto
			la SYSTASK le copia TODA la tabla de VMs al IS y de alli puede jugar con los punteros a procesos.
			Actualmente solo usa una tabla de procesos de la VM0.
			Esa misma rutina que transfiere toda esa info, puede ser usada por el IS para imprimir mas info
			sobre las VMs.
		
	
TODO:	Se deberia mejorar la legibilidad del codigo del init_server del RS y de do_getinfo() de la SYSTASK.	


PROBLEMA:		No puedo lograr que loadvmimg.c  imprima en consola ni tty* pero si envia a archivo de texto.
									
TODO:			Quizás la SYSTASK puede trabajar como PROMISCUOUS_TASK y eliminar running_vm.
			Esto puede requerir hacer macro que utilicen como parámetro el VMID en lugar del implicito running_vm
			Por ejemplo, el driver ETHERNET podria ser promiscuo

			
TODO ??? 		Que pasa si el PROXY_SERVER le envía un mensaje al REAL_DRIVER donde 
			le transfiere la dirección del mensaje recibido en el VIRTUAL_DRIVER
			y el vmid del driver
				m1_i1: vmid 
				m1_p1: mensaje del SERVER de la VMx
	
			El REAL_DRIVER ahora tiene el mensaje del SERVER de la VM0 que le hizo el pedido
			y puede gestionarlo en consecuencia.
				OPCION 1: El REAL_DRIVER podría enviar el mensaje de respuesta directamente 
					al SERVER de la VM0 para ello habría que modificar el msendas para 
					que incluya el VMID del proceso.
				OPCION 2: El REAL_DRIVER le envia un mensaje de ACK al PROXY_SERVER para que 
					continue con sus funciones. Una vez terminada la peticion, arma el 
					mensaje de respuesta y le envia un mensaje similar al que el PROXY_SERVER
					le envio. 
						m1_i1: dst_ep				
						m1_p1: mensaje del SERVER de la VMx
					El PROXY_SERVER copie el mensaje a su espacio de direcciones y 
						se lo envia al SERVER de VMx usand msendas()


			PROBLEMAS en el DRIVER: 
				- El endpoint del SERVER de la VMx no existe en la VM0
				- El REAL_DRIVER no tiene la direccion fisica del driver
									

TODO:			Para obtener info de la VMx, IS de la VM0 debe enviar una peticion al PROXY_SERVER 
			de la VMx quien, en nombre del IS de VMx solicita info a PM, FS, etc
			Cuando FS, PM responde (via send) el VIRTUAL_SERVER, el kernel al detectar que es un VIRTUAL_SERVER
			Copia el mensaje al PROXY_SERVER que debe estar en RECEIVING.
			Para ello es necesario implementar un mini_sendrecas()
					
							
TODO:			Probar incorporar patch_mem_chunks para ver que resulta.
			Probar el loop de procesos de booteo donde solo se habilita "ds"
			Ver que resultado da patch_mem_chunks
			El mapa de memoria de SYSTASK debe quedar tal como si se ejecutase en la VMx porque el PM
			patchea la memoria libre en funcion de ello.
			A los efectos de no desperdiciar memoria, el inicio del memchuck deberia ser el inicio de donde 
			se carga SYSTASK en lugar del inicio de memoria libre.
			Usar el inicio de memoria libre para constratar con el calculado por PM.

TODO:			Ver el truco (similar a el de VIRTUAL_TASK y PROXY_SERVER) para que el IS de la VM0 pueda recibir información
			de el PM y FS de la VMx.


TODO:			Disponer de una tabla para cada VM de los procesos de BOOTEO habilitados para ejecucion.
			En priv.h crear un nuevo flag
				#define VIRTUAL_TASK	0x0100	/* The process is a VIRTUAL TASK, and only use a slot but NEVER RUNs  */
				#define DISABLED_TASK	0x0200	/* The process must not be considered when booting a VM */

			previo a mh_main deberia cambiarse 
				vmm_ptr->vmm_img.image[i].flags = VIRTUAL_TASK
			para eso, por cada proceso de booteo, comparar contra los procesos habilitados. 
			Si esos proceso no están habilitados y son tareas  
	

TODO:		Por cada VM se necesita una tabla para cada proceso de booteo que indique
				- si se carga y ejecuta como un proceso de la nueva VM
				- si es una VIRTUAL_TASK 
				- si se ignora su carga (SYSTASK, HARDWARE, IDLE, CLOCK). Deberia ser default.
			Cambiar mh_main, para que arranque los procesos indicados en la tabla. 
						
TODO:		Modifificar proc.c para que controle privilegios
			En kernel/table.c estan los atributos necesarios para cada proceso.
			cuando se hace vmmcmd START deberían otorgarseles atributos de server SRV_T.
			para que puede efectuar cualquier tipo de IPC a cualquier proceso.
			Ver system/do_privctl.c
			
TODO: 		Probar arrancar el PM de la VM1 (PM1) insertando receive() para cortar el flujo
				if( pm_vmid != VM0) receive(ANY, &m);

TODO:			- Crear flags MIS_PROXY_TASK y MIS_PROXY_SERVER
				- Crear GETFROM y SENDTO
				- Hacer el LOOP del LOADER
				- Ver que flag es la que mantiene al PROXY_SERVER INMORTAL 
					en PM: mproc[p_nr].mp_flags |= VM_PROC;	/* This process can not be killed */
				
TODO:		Probar PM de VM1
		
			
TODO:		Modificar el PM exec.c porque no se distingue cual es el codigo original respecto al nuevo
			El VMM al hacer el VMM LOAD le pidio al PM datos sobre la VM. El PM le retorna esos datos.
				rmp->mp_reply.m1_i2 = mproc[p_nr].mp_endpoint;
				rmp->mp_reply.m1_i3 = mproc[p_nr].mp_vmsize;

TODO:		Modificar el comportamiento de mini_chvmid(vmid) que deberia ser mini_chvmid(vmid, proc)
				si proc==SELF el propio proceso se cambia de VMI
				si proc!=SELF se cambia el VMID de otro proceso siempre que exista.
				
			Modificar el comando service para que permita crear servidores para una VM determinada.

TODO: 		cambiar vmmcmd para que en el LOAD pida el nro de VM.
	
TODO:		Ojo que el putc() que usa el kprintf hoy envía solo a RS232.
		Se debería tener una constante figurativa que habilite uno u otro.

					

	
		
